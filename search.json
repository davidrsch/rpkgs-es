[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Paquetes de R",
    "section": "",
    "text": "¡Bienvenidos!\nBienvenidos a la versión online de la 2ª edición de “Paquetes de R” de Hadley Wickham y Jennifer Bryan. Los paquetes son las unidades fundamentales del código R reproducible. Incluyen funciones R reutilizables, la documentación que describe cómo usarlas y datos de muestra. En este libro aprenderá cómo convertir su código en paquetes que otros puedan descargar y usar fácilmente. Escribir un paquete puede parecer abrumador al principio. Así que comience con lo básico y mejórelo con el tiempo. No importa si tu primera versión no es perfecta siempre y cuando la próxima versión sea mejor.\nEste sitio web es y será siempre gratuito, con licencia bajo la Licencia CC BY-NC-ND 4.0. Si desea una copia física del libro, puede solicitarla en Amazon.",
    "crumbs": [
      "¡Bienvenidos!"
    ]
  },
  {
    "objectID": "index.html#sobre-la-traducción",
    "href": "index.html#sobre-la-traducción",
    "title": "Paquetes de R",
    "section": "Sobre La Traducción",
    "text": "Sobre La Traducción\n Esta traducción de “Paquetes de R” es un proyecto personal de David Díaz Rodríguez con el objetivo de facilitar el estudio de construcción de paquetes de R, tanto al propio traductor como a todas aquellas personas de habla hispana que deseen aprender sobre este tema.\nSeñalar que esta es una traducción textual del libro por lo que cuando los autores se refieren a sí mismo en primera persona, serán Hadley Wickham & Jenny Bryan no el traductor.\nLa traducción fue realizada usando Google Translate y fueron corregidos algunos errores gramaticales y de coherencia. Si detecta algún error relacionado con el contenido de la traducción, siéntase libre de abrir un issue o un pull request en este repositorio.",
    "crumbs": [
      "¡Bienvenidos!"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Prefacio",
    "section": "",
    "text": "Agradecimientos\n¡Bienvenido a la segunda edición de R Packages! Si está familiarizado con la primera edición, este prefacio describe los cambios más importantes para que pueda centrar su lectura en las nuevas áreas.\nHay varios objetivos principales para esta edición:\nTodo el contenido ha sido completamente revisado y actualizado. Muchos capítulos son nuevos o están reorganizados y se han eliminado algunos:\nDesde que se publicó la primera edición de Paquetes de R, los paquetes que respaldan los flujos de trabajo descritos aquí han experimentado un amplio desarrollo. El trío original de devtools, roxygen2 y testthat se ha expandido para incluir los paquetes creados por el “desacoplamiento consciente” de devtools, como se describe en devtools, usethis, y usted. La mayoría de estos paquetes se originan en Hadley Wickham (HW), debido a sus raíces devtools. Hay muchos otros contribuyentes importantes, muchos de los cuales ahora sirven como mantenedores:\nEste libro fue escrito y revisado abiertamente y es verdaderamente un esfuerzo comunitario: muchas personas leen borradores, corrigen errores tipográficos, sugieren mejoras y contribuyen con contenido. Sin esos colaboradores, el libro no sería tan bueno como es y estamos profundamente agradecidos por su ayuda. Estamos en deuda con nuestros colegas de Posit, especialmente con el equipo de tidyverse, por estar siempre dispuestos a discutir prácticas de desarrollo de paquetes. El libro ha mejorado enormemente gracias a las sugerencias de nuestro fantástico equipo de revisores técnicos: Malcolm Barrett, Laura DeCicco, Zhian Kamvar, Tom Mock y Maëlle Salmon.\nGracias a todos los contribuyentes de la primera y segunda edición. (en orden alfabético por nombre de usuario de GitHub):\n@aaelony, @aaronwolen (Aaron Wolen), @ablejec (Andrej Blejec), @adamcduncan (Adam Duncan), @adessy, @adrtod (Adrien Todeschini), @aghaynes (Alan Haynes), @agrueneberg (Alexander Grueneberg), @alejandrohagan (Alejandro Hagan), @alesantuz (Ale Santuz), @alexandrehsd (Alexandre Henrique), @alexholcombe (Alex O. Holcombe), @alexpghayes (alex hayes), @alforj (Justin Alford), @almartin82 (Andrew Martin), @aluxh (Alex Ho), @AmelZulji, @andreaphsz (Andrea Cantieni), @andrewdolman (Andrew Dolman), @andrewpbray (Andrew Bray), @AndrewsOR (John Andrews), @andycraig (Andrew Craig), @angela-li (Angela Li), @anjalisilva (Anjali Silva), @apomatix (Brad Friedman), @apreshill (Alison Presmanes Hill), @arashHaratian (Arash), @arilamstein (Ari Lamstein), @arneschillert (Arne Schillert), @arni-magnusson (Arni Magnusson), @asadow (Adam Sadowski), @ateucher (Andy Teucher), @avisser (Andy Visser), @ayormark (Adam Yormark), @azzaea (Azza Ahmed), @batpigandme (Mara Averick), @bclipp (Brian L), @beevabeeva, @behrman (Bill Behrman), @benmarwick (Ben Marwick), @BernhardKonrad (Bernhard Konrad), @bgreenwell (Brandon Greenwell), @Bisaloo (Hugo Gruson), @bklamer (Brett Klamer), @bm5tev3, @bms63 (Ben Straub), @bpbond (Ben Bond-Lamberty), @bquast (Bastiaan Quast), @Br-Johnson (Brett Johnson), @brews (Brewster Malevich), @brianrice2 (Brian Rice), @brry (Berry Boessenkool), @btruel, @calligross (Calli), @carldotac (Carl Lieberman), @carloscinelli (Carlos Cinelli), @CDCookJr, @cderv (Christophe Dervieux), @chambm (Matt Chambers), @charliejhadley (Charlie Joey Hadley), @chezou (Aki Ariga), @chsafouane (Safouane Chergui), @clente (Caio Lente), @cmarmstrong, @cooknl (CAPN), @CorradoLanera (Corrado Lanera), @craigcitro (Craig Citro), @crtahlin (Crt Ahlin), @daattali (Dean Attali), @danhalligan (Dan Halligan), @daroczig (Gergely Daróczi), @datarttu (Arttu Kosonen), @davidkane9 (David Kane), @DavisVaughan (Davis Vaughan), @deanbodenham, @dfalbel (Daniel Falbel), @dgrtwo (David Robinson), @dholstius (David Holstius), @DickStartz, @dkgaraujo (Douglas K. G. Araujo), @dlukes (David Lukes), @DOH-PXC5303 (Philip Crain), @dongzhuoer (Zhuoer Dong), @DougManuel (Doug Manuel), @dpprdan (Daniel Possenriede), @dracodoc (dracodoc), @drag05 (Dragos Bandur), @drvinceknight (Vince Knight), @dryzliang, @dyavorsky (Dan Yavorsky), @e-pet, @earino (E. Ariño de la Rubia), @echelleburns, @eeholmes (Eli Holmes), @eipi10 (Joel Schwartz), @ekbrown (Earl Brown), @EllaKaye (Ella Kaye), @EmilHvitfeldt (Emil Hvitfeldt), @eogoodwin, @erictleung (Eric Leung), @erikerhardt (Erik Erhardt), @espinielli (Enrico Spinielli), @ewan (Ewan Dunbar), @fbertran (Frederic Bertrand), @federicomarini (Federico Marini), @fenguoerbian (Chao Cheng), @fkohrt (Florian Kohrt), @florisvdh (Floris Vanderhaeghe), @floswald (Florian Oswald), @franrodalg (Francisco Rodríguez-Algarra), @franticspider (Simon Hickinbotham), @frycast (Daniel Vidali Fryer), @fsavje (Fredrik Sävje), @gajusmiknaitis, @gcpoole (Geoffrey Poole), @geanders (Brooke Anderson), @georoen (Jee Roen), @GerardTromp (Gerard Tromp), @GillesSanMartin (Gilles San Martin), @gmaubach (Georg Maubach), @gonzalezgouveia (Rafael Gonzalez Gouveia), @gregmacfarlane (Greg Macfarlane), @gregrs-uk (Greg), @grst (Gregor Sturm), @gsrohde (Scott Rohde), @guru809, @gustavdelius (Gustav W Delius), @haibin (Liu Haibin), @hanneoberman (Hanne Oberman), @harrismcgehee (Harris McGehee), @havenl (Haven Liu), @hcyvan (程一航), @hdraisma (Harmen), @hedderik (Hedderik van Rijn), @heists ((ꐦ°᷄д°)ა), @helske (Jouni Helske), @henningte (Henning Teickner), @HenrikBengtsson (Henrik Bengtsson), @heogden (Helen Ogden), @hfrick (Hannah Frick), @Holzhauer (Sascha Holzhauer), @howardbaek (Howard Baek), @howbuildingsfail (How Buildings Fail), @hq9000 (Sergey Grechin), @hrbrmstr (boB Rudis), @iangow (Ian Gow), @iargent, @idmn (Iaroslav Domin), @ijlyttle (Ian Lyttle), @imchoyoung (Choyoung Im), @InfiniteCuriosity (Russ Conte), @ionut-stefanb (Ionut Stefan-Birdea), @Ironholds (Os Keyes), @ismayc (Chester Ismay), @isomorphisms (i), @jackwasey (Jack Wasey), @jacobbien (Jacob Bien), @jadeynryan (Jadey Ryan), @jameelalsalam (Jameel Alsalam), @jameslairdsmith (James Laird-Smith), @janzzon (Stefan Jansson), @JayCeBB, @jcainey (Joe Cainey), @jdblischak (John Blischak), @jedwards24 (James Edwards), @jemus42 (Lukas Burk), @jenniferthompson (Jennifer Thompson), @jeremycg (Jeremy Gray), @jgarthur (Joey Arthur), @jimhester (Jim Hester), @jimr1603 (James Riley), @jjesusfilho (José de Jesus Filho), @jkeirstead (James Keirstead), @jmarca (James Marca), @jmarshallnz (Jonathan Marshall), @joethorley (Joe Thorley), @johnbaums (John), @jolars (Johan Larsson), @jonthegeek (Jon Harmon), @jowalski (John Kowalski), @jpinelo (Joao Pinelo Silva), @jrdnbradford (Jordan), @jthomasmock (Tom Mock), @julian-urbano (Julián Urbano), @jwpestrak, @jzadra (Jonathan Zadra), @jzhaoo (Joanna Zhao), @kaetschap (Sonja), @karthik (Karthik Ram), @KasperThystrup (Kasper Thystrup Karstensen), @KatherineCox, @katrinleinweber (Katrin Leinweber), @kbroman (Karl Broman), @kekecib (Ibrahim Kekec), @KellenBrosnahan, @kendonB (Kendon Bell), @kevinushey (Kevin Ushey), @kikapp (Kristopher Kapphahn), @KirkDSL, @KJByron (Karen J. Byron), @klmr (Konrad Rudolph), @KoderKow (Kyle Harris), @kokbent (Ben Toh), @kongdd (Dongdong Kong), @krlmlr (Kirill Müller), @kwenzig (Knut Wenzig), @kwstat (Kevin Wright), @kylelundstedt (Kyle G. Lundstedt), @lancelote (Pavel Karateev), @lbergelson (Louis Bergelson), @LechMadeyski (Lech Madeyski), @Lenostatos (Leon), @lindbrook, @lionel- (Lionel Henry), @LluisRamon (Lluís Ramon), @lorenzwalthert (Lorenz Walthert), @lwjohnst86 (Luke W Johnston), @maelle (Maëlle Salmon), @maiermarco, @maislind (David M), @majr-red (Matthew Roberts), @malcolmbarrett (Malcolm Barrett), @malexan (Alexander Matrunich), @manuelreif (Manuel Reif), @MarceloRTonon (Marcelo Tonon), @mariacuellar (Maria Cuellar), @markdly (Mark Dulhunty), @Marlin-Na (Marlin), @martin-mfg, @matanhakim (Matan Hakim), @matdoering, @matinang (Matina Angelopoulou), @mattflor (Matthias Flor), @maurolepore (Mauro Lepore), @maxheld83 (Max Held), @mayankvanani (Mayank Vanani), @mbjones (Matt Jones), @mccarthy-m-g (Michael McCarthy), @mdequeljoe (Matthew de Queljoe), @mdsumner (Michael Sumner), @michaelboerman (Michael Boerman), @MichaelChirico (Michael Chirico), @michaelmikebuckley (Michael Buckley), @michaelweylandt (Michael Weylandt), @miguelmorin, @MikeJohnPage, @mikelnrd (Michael Leonard), @mikelove (Mike Love), @mikemc (Michael McLaren), @MilesMcBain (Miles McBain), @mjkanji (Muhammad Jarir Kanji), @mkuehn10 (Michael Kuehn), @mllg (Michel Lang), @mohamed-180 (Mohamed El-Desokey), @moodymudskipper (Antoine Fabri), @Moohan (James McMahon), @MrAE (Jesse Leigh Patsolic), @mrcaseb, @ms609 (Martin R. Smith), @mskyttner (Markus Skyttner), @MWilson92 (Matthew Wilson), @myoung3, @nachti (Gerhard Nachtmann), @nanxstats (Nan Xiao), @nareal (Nelson Areal), @nattalides, @ncarchedi (Nick Carchedi), @ndphillips (Nathaniel Phillips), @nick-youngblut (Nick Youngblut), @njtierney (Nicholas Tierney), @nsheff (Nathan Sheffield), @osorensen (Øystein Sørensen), @PabRod (Pablo Rodríguez-Sánchez), @paternogbc (Gustavo Brant Paterno), @paulrougieux (Paul Rougieux), @pdwaggoner (Philip Waggoner), @pearsonca (Carl A. B. Pearson), @perryjer1 (Jeremiah), @petermeissner (Peter Meissner), @petersonR (Ryan Peterson), @petzi53 (Peter Baumgartner), @PhilipPallmann (Philip Pallmann), @philliplab (Phillip Labuschagne), @phonixor (Gerrit-Jan Schutten), @pkimes (Patrick Kimes), @pnovoa (Pavel Novoa), @ppanko (Pavel Panko), @pritesh-shrivastava (Pritesh Shrivastava), @PrzeChoj (PrzeChoj), @PursuitOfDataScience (Y. Yu), @pwaeckerle, @raerickson (Richard Erickson), @ramiromagno (Ramiro Magno), @ras44, @rbirkelbach (Robert Birkelbach), @rcorty (Robert W. Corty), @rdiaz02 (Ramon Diaz-Uriarte), @realAkhmed (Akhmed Umyarov), @reikookamoto (Reiko Okamoto), @renkun-ken (Kun Ren), @retowyss (Reto Wyss), @revodavid (David Smith), @rgknight (Ryan Knight), @rhgof (Richard), @rmar073, @rmflight (Robert M Flight), @rmsharp (R. Mark Sharp), @rnuske (Robert Nuske), @robertzk (Robert Krzyzanowski), @Robinlovelace (Robin Lovelace), @robiRagan (Robi Ragan), @Robsteranium (Robin Gower), @romanzenka (Roman Zenka), @royfrancis (Roy Francis), @rpruim (Randall Pruim), @rrunner, @rsangole (Rahul), @ryanatanner (Ryan), @salim-b (Salim B), @SamEdwardes (Sam Edwardes), @SangdonLim (Sangdon Lim), @sathishsrinivasank (Sathish), @sbgraves237, @schifferl (Lucas Schiffer), @scw (Shaun Walbridge), @sdarodrigues (Sabrina Rodrigues), @sebffischer (Sebastian Fischer), @serghiou (Stylianos Serghiou), @setoyama60jp, @sfirke (Sam Firke), @shannonpileggi (Shannon Pileggi), @Shelmith-Kariuki (Shel), @SheridanLGrant (Sheridan Grant), @shntnu (Shantanu Singh), @sibusiso16 (S’busiso Mkhondwane), @simdadim (Simen Buodd), @SimonPBiggs (SPB), @simonthelwall (Simon Thelwall), @SimonYansenZhao (Simon He Zhao), @singmann (Henrik Singmann), @Skenvy (Nathan Levett), @Smudgerville (Richard M. Smith), @sn248 (Satyaprakash Nayak), @sowla (Praer (Suthira) Owlarn), @srushe (Stephen Rushe), @statnmap (Sébastien Rochette), @steenharsted (Steen Harsted), @stefaneng (Stefan Eng), @stefanherzog (Stefan Herzog), @stephen-frank (Stephen Frank), @stephenll (Stephen Lienhard), @stephenturner (Stephen Turner), @stevenprimeaux (Steven Primeaux), @stevensbr, @stewid (Stefan Widgren), @sunbeomk (Sunbeom Kwon), @superdesolator (Po Su), @syclik (Daniel Lee), @symbolrush (Adrian Stämpfli-Schmid), @taekyunk (Taekyun Kim), @talgalili (Tal Galili), @tanho63 (Tan Ho), @tbrugz (Telmo Brugnara), @thisisnic (Nic Crane), @TimHesterberg (Tim Hesterberg), @titaniumtroop (Nathan), @tjebo, @tklebel (Thomas Klebel), @tmstauss (Tanner Stauss), @tonybreyal (Tony Breyal), @tonyfischetti (Tony Fischetti), @TonyLadson (Tony Ladson), @trickytank (Rick Tankard), @TroyVan, @uribo (Shinya Uryu), @urmils, @valeonte, @vgonzenbach (Virgilio Gonzenbach), @vladpetyuk (Vlad Petyuk), @vnijs (Vincent Nijs), @vspinu (Vitalie Spinu), @wcarlsen (Willi Carlsen), @wch (Winston Chang), @wenjie2wang (Wenjie Wang), @werkstattcodes, @wiaidp, @wibeasley (Will Beasley), @wilkinson (Sean Wilkinson), @williamlief (Lief Esbenshade), @winterschlaefer (Christof Winter), @wlamnz (William Lam), @wrathematics (Drew Schmidt), @XiangyunHuang (Xiangyun Huang), @xiaochi-liu (Xiaochi), @XiaoqiLu (Xiaoqi Lu), @xiaosongz (Xiaosong Zhang), @yihui (Yihui Xie), @ynsec37, @yonicd, @ysdgroot, @yui-knk (Yuichiro Kaneko), @Zedseayou (Calum You), @zeehio (Sergio Oller), @zekiakyol (Zeki Akyol), @zenggyu (Guangyu Zeng), @zhaoy, @zhilongjia (Zhilong), @zhixunwang, @zkamvar (Zhian N. Kamvar), @zouter (Wouter Saelens).",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "preface.html#agradecimientos",
    "href": "preface.html#agradecimientos",
    "title": "Prefacio",
    "section": "",
    "text": "devtools: HW, Winston Chang, Jim Hester (mantenedor, &gt;= v1.13.5), Jennifer Bryan (mantenedor &gt;= v2.4.3)\nusethis: HW, Jennifer Bryan (mantenedor &gt;= v1.5.0), Malcolm Barrett\nroxygen2: HW (mantenedor), Peter Danenburg, Manuel Eugster\n\ntestthat: HW (mantenedor)\ndesc: Gábor Csárdi (mantenedor), Kirill Müller, Jim Hester\n\npkgbuild: HW, Jim Hester, Gábor Csárdi (mantenedor &gt;= v1.2.1)\npkgload: HW, Jim Hester, Winston Chang, Lionel Henry (mantenedor &gt;= v1.2.4)\nrcmdcheck: Gábor Csárdi (mantenedor)\nremotes: HW, Jim Hester, Gábor Csárdi (mantenedor), Winston Chang, Martin Morgan, Dan Tenenbaum\n\nrevdepcheck: HW, Gábor Csárdi (mantenedor)\nsessioninfo: HW, Gábor Csárdi (mantenedor), Winston Chang, Robert Flight, Kirill Müller, Jim Hester\n\n\n\n#&gt; ── Attaching core tidyverse packages ──────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#&gt; ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n#&gt; Rows: 410 Columns: 3\n#&gt; ── Column specification ────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (3): user, name, maybe_name\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "preface.html#convenciones",
    "href": "preface.html#convenciones",
    "title": "Prefacio",
    "section": "Convenciones",
    "text": "Convenciones\nA lo largo de este libro, escribimos fun() para referirnos a funciones, var para referirnos a variables y argumentos de funciones, y path/ para rutas.\nLos bloques de código más grandes entremezclan entrada y salida. El resultado se comenta de modo que, si tiene una versión electrónica del libro, por ejemplo, https://r-pkgs.org, puedes copiar y pegar ejemplos fácilmente en R. Los comentarios de salida tienen el formato #&gt; para distinguirlos de los comentarios normales.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "preface.html#colofón",
    "href": "preface.html#colofón",
    "title": "Prefacio",
    "section": "Colofón",
    "text": "Colofón\nEste libro fue escrito usando Quarto dentro de RStudio. El sitio web está alojado con Netlify, y se actualiza automáticamente después de cada confirmación mediante acciones de GitHub. La fuente completa está disponible en GitHub.\nEsta versión del libro fue construida con:\n\nlibrary(devtools)\n#&gt; Loading required package: usethis\nlibrary(roxygen2)\nlibrary(testthat)\n#&gt; \n#&gt; Attaching package: 'testthat'\n#&gt; The following object is masked from 'package:devtools':\n#&gt; \n#&gt;     test_file\n#&gt; The following object is masked from 'package:dplyr':\n#&gt; \n#&gt;     matches\n#&gt; The following object is masked from 'package:purrr':\n#&gt; \n#&gt;     is_null\n#&gt; The following objects are masked from 'package:readr':\n#&gt; \n#&gt;     edition_get, local_edition\n#&gt; The following object is masked from 'package:tidyr':\n#&gt; \n#&gt;     matches\ndevtools::session_info()\n#&gt; ─ Session info ───────────────────────────────────────────────────\n#&gt;  setting  value\n#&gt;  version  R version 4.4.0 (2024-04-24)\n#&gt;  os       Ubuntu 24.04.2 LTS\n#&gt;  system   x86_64, linux-gnu\n#&gt;  ui       X11\n#&gt;  language (EN)\n#&gt;  collate  C.UTF-8\n#&gt;  ctype    C.UTF-8\n#&gt;  tz       UTC\n#&gt;  date     2025-08-23\n#&gt;  pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown)\n#&gt; \n#&gt; ─ Packages ───────────────────────────────────────────────────────\n#&gt;  ! package     * version date (UTC) lib source\n#&gt;  P bit           4.0.5   2022-11-15 [?] RSPM (R 4.4.0)\n#&gt;  P bit64         4.0.5   2020-08-30 [?] RSPM (R 4.4.0)\n#&gt;  P brio          1.1.5   2024-04-24 [?] RSPM (R 4.4.0)\n#&gt;  P cachem        1.1.0   2024-05-16 [?] RSPM (R 4.4.0)\n#&gt;  P cli           3.6.2   2023-12-11 [?] RSPM (R 4.4.0)\n#&gt;  P colorspace    2.1-0   2023-01-23 [?] RSPM (R 4.4.0)\n#&gt;  P crayon        1.5.2   2022-09-29 [?] RSPM (R 4.4.0)\n#&gt;  P devtools    * 2.4.5   2022-10-11 [?] RSPM (R 4.4.0)\n#&gt;  P digest        0.6.35  2024-03-11 [?] RSPM (R 4.4.0)\n#&gt;  P dplyr       * 1.1.4   2023-11-17 [?] RSPM (R 4.4.0)\n#&gt;  P ellipsis      0.3.2   2021-04-29 [?] RSPM (R 4.4.0)\n#&gt;  P evaluate      0.23    2023-11-01 [?] RSPM (R 4.4.0)\n#&gt;  P fansi         1.0.6   2023-12-08 [?] RSPM (R 4.4.0)\n#&gt;  P fastmap       1.2.0   2024-05-15 [?] RSPM (R 4.4.0)\n#&gt;  P forcats     * 1.0.0   2023-01-29 [?] RSPM (R 4.4.0)\n#&gt;  P fs            1.6.4   2024-04-25 [?] RSPM (R 4.4.0)\n#&gt;  P generics      0.1.3   2022-07-05 [?] RSPM (R 4.4.0)\n#&gt;  P ggplot2     * 3.5.1   2024-04-23 [?] RSPM (R 4.4.0)\n#&gt;  P glue          1.7.0   2024-01-09 [?] RSPM (R 4.4.0)\n#&gt;  P gtable        0.3.5   2024-04-22 [?] RSPM (R 4.4.0)\n#&gt;  P hms           1.1.3   2023-03-21 [?] RSPM (R 4.4.0)\n#&gt;  P htmltools     0.5.8.1 2024-04-04 [?] RSPM (R 4.4.0)\n#&gt;  P htmlwidgets   1.6.4   2023-12-06 [?] RSPM (R 4.4.0)\n#&gt;  P httpuv        1.6.15  2024-03-26 [?] RSPM (R 4.4.0)\n#&gt;  P jsonlite      1.8.8   2023-12-04 [?] RSPM (R 4.4.0)\n#&gt;  P knitr         1.47    2024-05-29 [?] RSPM (R 4.4.0)\n#&gt;  P later         1.3.2   2023-12-06 [?] RSPM (R 4.4.0)\n#&gt;  P lifecycle     1.0.4   2023-11-07 [?] RSPM (R 4.4.0)\n#&gt;  P lubridate   * 1.9.3   2023-09-27 [?] RSPM (R 4.4.0)\n#&gt;  P magrittr      2.0.3   2022-03-30 [?] RSPM (R 4.4.0)\n#&gt;  P memoise       2.0.1   2021-11-26 [?] RSPM (R 4.4.0)\n#&gt;  P mime          0.12    2021-09-28 [?] RSPM (R 4.4.0)\n#&gt;  P miniUI        0.1.1.1 2018-05-18 [?] RSPM (R 4.4.0)\n#&gt;  P munsell       0.5.1   2024-04-01 [?] RSPM (R 4.4.0)\n#&gt;  P pillar        1.9.0   2023-03-22 [?] RSPM (R 4.4.0)\n#&gt;  P pkgbuild      1.4.4   2024-03-17 [?] RSPM (R 4.4.0)\n#&gt;  P pkgconfig     2.0.3   2019-09-22 [?] RSPM (R 4.4.0)\n#&gt;  P pkgload       1.3.4   2024-01-16 [?] RSPM (R 4.4.0)\n#&gt;  P profvis       0.3.8   2023-05-02 [?] RSPM (R 4.4.0)\n#&gt;  P promises      1.3.0   2024-04-05 [?] RSPM (R 4.4.0)\n#&gt;  P purrr       * 1.0.2   2023-08-10 [?] RSPM (R 4.4.0)\n#&gt;  P R6            2.5.1   2021-08-19 [?] RSPM (R 4.4.0)\n#&gt;  P Rcpp          1.0.12  2024-01-09 [?] RSPM (R 4.4.0)\n#&gt;  P readr       * 2.1.5   2024-01-10 [?] RSPM (R 4.4.0)\n#&gt;  P remotes       2.5.0   2024-03-17 [?] RSPM (R 4.4.0)\n#&gt;    renv          1.0.7   2024-04-11 [1] RSPM (R 4.4.0)\n#&gt;  P rlang         1.1.4   2024-06-04 [?] RSPM (R 4.4.0)\n#&gt;  P rmarkdown     2.26    2024-03-05 [?] RSPM (R 4.4.0)\n#&gt;  P roxygen2    * 7.3.1   2024-01-22 [?] RSPM (R 4.4.0)\n#&gt;  P scales        1.3.0   2023-11-28 [?] RSPM (R 4.4.0)\n#&gt;  P sessioninfo   1.2.2   2021-12-06 [?] RSPM (R 4.4.0)\n#&gt;  P shiny         1.8.1.1 2024-04-02 [?] RSPM (R 4.4.0)\n#&gt;  P stringi       1.8.4   2024-05-06 [?] RSPM (R 4.4.0)\n#&gt;  P stringr     * 1.5.1   2023-11-14 [?] RSPM (R 4.4.0)\n#&gt;  P testthat    * 3.2.1.1 2024-04-14 [?] RSPM (R 4.4.0)\n#&gt;  P tibble      * 3.2.1   2023-03-20 [?] RSPM (R 4.4.0)\n#&gt;  P tidyr       * 1.3.1   2024-01-24 [?] RSPM (R 4.4.0)\n#&gt;  P tidyselect    1.2.1   2024-03-11 [?] RSPM (R 4.4.0)\n#&gt;  P tidyverse   * 2.0.0   2023-02-22 [?] RSPM (R 4.4.0)\n#&gt;  P timechange    0.3.0   2024-01-18 [?] RSPM (R 4.4.0)\n#&gt;  P tzdb          0.4.0   2023-05-12 [?] RSPM (R 4.4.0)\n#&gt;  P urlchecker    1.0.1   2021-11-30 [?] RSPM (R 4.4.0)\n#&gt;  P usethis     * 2.2.3   2024-02-19 [?] RSPM (R 4.4.0)\n#&gt;  P utf8          1.2.4   2023-10-22 [?] RSPM (R 4.4.0)\n#&gt;  P vctrs         0.6.5   2023-12-01 [?] RSPM (R 4.4.0)\n#&gt;  P vroom         1.6.5   2023-12-05 [?] RSPM (R 4.4.0)\n#&gt;  P withr         3.0.0   2024-01-16 [?] RSPM (R 4.4.0)\n#&gt;  P xfun          0.44    2024-05-15 [?] RSPM (R 4.4.0)\n#&gt;  P xml2          1.3.6   2023-12-04 [?] RSPM (R 4.4.0)\n#&gt;  P xtable        1.8-4   2019-04-21 [?] RSPM (R 4.4.0)\n#&gt;  P yaml          2.3.8   2023-12-11 [?] RSPM (R 4.4.0)\n#&gt; \n#&gt;  [1] /home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu\n#&gt;  [2] /home/runner/.cache/R/renv/sandbox/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/3df92652\n#&gt; \n#&gt;  P ── Loaded and on-disk path mismatch.\n#&gt; \n#&gt; ──────────────────────────────────────────────────────────────────\n\n\n\n\n\nMüller, Kirill, y Lorenz Walthert. 2018. styler: Non-Invasive Pretty Printing of R Code. http://styler.r-lib.org.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introducción",
    "section": "",
    "text": "Filosofía\nEn R, la unidad fundamental de código compartible es el paquete. Un paquete agrupa código, datos, documentación y pruebas, y es fácil de compartir con otros. En marzo de 2023, había más de 19 000 paquetes disponibles en la red Comprehensive R Aarchive Network, o CRAN, la cámara de compensación pública para paquetes R. Esta enorme variedad de paquetes es una de las razones por las que R tiene tanto éxito: lo más probable es que alguien ya haya resuelto un problema en el que estás trabajando y puedas beneficiarte de su trabajo descargando su paquete.\nSi estás leyendo este libro, ya sabes cómo trabajar con paquetes de las siguientes maneras:\nEl objetivo de este libro es enseñarle cómo desarrollar paquetes para que pueda escribir los suyos propios, no sólo utilizar los de otras personas. ¿Por qué escribir un paquete? Una razón de peso es que tienes un código que quieres compartir con otros. Agrupar su código en un paquete facilita su uso para otras personas porque, al igual que usted, ellos ya saben cómo utilizar los paquetes. Si su código está en un paquete, cualquier usuario de R puede descargarlo, instalarlo y aprender a usarlo fácilmente.\nPero los paquetes son útiles incluso si nunca compartes tu código. Como dice Hilary Parker en su introducción a los paquetes: “En serio, no tiene por qué tratarse de compartir tu código (¡aunque eso es un beneficio adicional!). Se trata de ahorrar tiempo”. Organizar el código en un paquete le facilita la vida porque los paquetes vienen con convenciones. Por ejemplo, pones código R en R/, pones pruebas en tests/ y pones datos en data/. Estas convenciones son útiles porque:\nIncluso es posible utilizar paquetes para estructurar sus análisis de datos (por ejemplo, Marwick, Boettiger, y Mullen (2018a) o Marwick, Boettiger, y Mullen (2018b)), aunque no profundizaremos en ese caso de uso aquí.\nEste libro defiende nuestra filosofía de desarrollo de paquetes: todo lo que pueda automatizarse, debe automatizarse. Haga lo menos posible a mano. Haga todo lo posible con las funciones. El objetivo es dedicar su tiempo a pensar en lo que quiere que haga su paquete en lugar de pensar en los detalles de la estructura del paquete.\nEsta filosofía se logra principalmente a través del paquete devtools, que es la cara pública de un conjunto de funciones de R que automatizan tareas de desarrollo comunes. El lanzamiento de la versión 2.0.0 en octubre de 2018 marcó su reestructuración interna en un conjunto de paquetes más enfocados, con devtools convirtiéndose más en un metapaquete. El paquete usethis es el subpaquete con el que es más probable que interactúe directamente; Explicamos la relación devtools-usethis en devtools, usethis, y usted.\nComo siempre, el objetivo de devtools es hacer que el desarrollo de paquetes sea lo más sencillo posible. Resume las mejores prácticas desarrolladas por Hadley Wickham, inicialmente de sus años como prolífico desarrollador en solitario. Más recientemente, ha reunido un equipo de desarrolladores en Posit (anteriormente conocido como RStudio), que en conjunto se ocupan de cientos de paquetes R de código abierto, incluidos los conocidos como the tidyverse. El alcance de este equipo nos permite explorar el espacio de todos los posibles errores a una escala extraordinaria. Afortunadamente, también nos brinda la oportunidad de reflexionar sobre los éxitos y los fracasos, en compañía de colegas expertos y comprensivos. Intentamos desarrollar prácticas que hagan la vida más agradable tanto para el mantenedor como para los usuarios de un paquete. El metapaquete devtools es donde estas lecciones se concretan.\ndevtools trabaja mano a mano con RStudio, que creemos que es el mejor entorno de desarrollo para la mayoría de los usuarios de R. La alternativa más popular a RStudio es actualmente Visual Studio Code (VS Code) con la extensión R habilitado. Este puede ser un entorno gratificante y poderoso, sin embargo, requiere un poco más de trabajo para configurarlo y personalizarlo 1.\nJuntos, devtools y RStudio lo aíslan de los detalles de bajo nivel sobre cómo se crean los paquetes. A medida que comience a desarrollar más paquetes, le recomendamos encarecidamente que obtenga más información sobre esos detalles. El mejor recurso para conocer los detalles oficiales del desarrollo de paquetes es siempre el manual oficial de escritura de extensiones R 2. Sin embargo, este manual puede resultar difícil de entender si aún no está familiarizado con los conceptos básicos de los paquetes. También es exhaustivo y cubre todos los componentes posibles del paquete, en lugar de centrarse en los componentes más comunes y útiles, como lo hace este libro. Escribir extensiones de R es un recurso útil una vez que dominas los conceptos básicos y deseas aprender qué sucede bajo el capó.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "introduction.html#sec-intro-phil",
    "href": "introduction.html#sec-intro-phil",
    "title": "Introducción",
    "section": "",
    "text": "RStudio\n\n\n\nA lo largo del libro, destacamos formas específicas en las que RStudio puede acelerar el flujo de trabajo de desarrollo de paquetes, en secciones con formato especial como esta.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "introduction.html#sec-intro-outline",
    "href": "introduction.html#sec-intro-outline",
    "title": "Introducción",
    "section": "En este libro",
    "text": "En este libro\nLa primera parte del libro trata de brindarle todas las herramientas que necesita para comenzar su viaje de desarrollo de paquetes y le recomendamos encarecidamente que lo lea en orden. Comenzamos en 1  Todo el juego con un recorrido por el desarrollo completo de un paquete pequeño. Su objetivo es pintar el panorama general y sugerir un flujo de trabajo, antes de pasar al tratamiento detallado de los componentes clave de un paquete R. Luego, en 2  Configuración del sistema aprenderá cómo preparar su sistema para el desarrollo de paquetes, y en 3  Estructura y estado del paquete aprenderá la estructura básica de un paquete y cómo varía entre los diferentes estados. A continuación, en 4  Flujos de trabajo de desarrollo fundamentales, cubriremos los flujos de trabajo principales que surgen repetidamente para los desarrolladores de paquetes. La primera parte del libro termina con otro estudio de caso (5  El paquete en el interior de su código), esta vez centrándose en cómo se puede convertir un script en un paquete y analizando los desafíos que enfrentará en el camino.\nEl resto del libro está diseñado para leerse según sea necesario. Elija entre los capítulos a medida que surjan los distintos temas en su proceso de desarrollo.\nPrimero cubrimos los componentes clave del paquete: 6  Código R analiza dónde reside su código y cómo organizarlo, 7  Datos le muestra cómo incluir datos en su paquete y 8  Otros componentes cubre algunos archivos y directorios menos importantes que hay que discutirlo en alguna parte.\nA continuación, profundizaremos en los metadatos del paquete, comenzando con DESCRIPTION en 9  DESCRIPTION. Luego profundizaremos en las dependencias. En 10  Dependencias: mentalidad y antecedentes, cubriremos los costos y beneficios de asumir dependencias y brindaremos algunos antecedentes técnicos sobre los espacios de nombres de los paquetes y la ruta de búsqueda. En 11  Dependencias: en la práctica, nos centramos en cuestiones prácticas, como cómo utilizar diferentes tipos de dependencias en diferentes partes de su paquete. Aquí también hablamos de las funciones de exportación, que es lo que hace posible que otros paquetes y proyectos dependan de su paquete. Terminaremos esta parte echando un vistazo a las licencias en 12  Licencias.\nPara garantizar que su paquete funcione según lo diseñado (y continúe funcionando a medida que realiza cambios), es esencial probar su código, por lo que los siguientes tres capítulos cubren el arte y la ciencia de las pruebas. 13  Conceptos básicos de pruebas le ayuda a comenzar con los conceptos básicos de las pruebas con el paquete testthat. 14  Diseñar su conjunto de pruebas te enseña cómo diseñar y organizar pruebas de la forma más eficaz. Luego terminamos nuestra cobertura de pruebas en 15  Técnicas de prueba avanzadas, que le enseña habilidades avanzadas para afrontar situaciones desafiantes.\nSi desea que otras personas (¡incluido usted en el futuro!) comprendan cómo utilizar las funciones de su paquete, deberá documentarlas. 16  Documentación de la función le ayuda a empezar a utilizar roxygen2 para documentar las funciones de su paquete. La documentación de funciones solo es útil si sabe qué función buscar, por lo que a continuación en 17  Viñetas analizaremos las viñetas, que le ayudarán a documentar el paquete en su conjunto. Terminaremos la documentación con una discusión sobre otros archivos de maquetación importantes como README.md y NEWS.md en 18  Otros archivos markdown, y creando un sitio web de paquete con pkgdown en 19  Sitio web.\nEl libro concluye volviendo a considerar las prácticas de desarrollo, como el beneficio de utilizar el control de versiones y la integración continua (20  Prácticas de desarrollo de software). Concluiremos analizando el ciclo de vida (21  Ciclo de vida) de un paquete, incluido su lanzamiento en CRAN (22  Subiendo a CRAN).\nHay mucho que aprender, pero no se sienta abrumado. Comience con un subconjunto mínimo de funciones útiles (por ejemplo, ¡solo un directorio R/!) y acumule con el tiempo. Parafraseando al monje zen Shunryu Suzuki: “Cada paquete es perfecto tal como está — y necesitaría una pequeña mejora”.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "introduction.html#qué-no-hay-aquí",
    "href": "introduction.html#qué-no-hay-aquí",
    "title": "Introducción",
    "section": "¿Qué no hay aquí?",
    "text": "¿Qué no hay aquí?\nTambién hay prácticas específicas que tienen poco o ningún tratamiento aquí simplemente porque no las usamos lo suficiente como para tener una visión especial. ¿Significa esto que desalentamos activamente esas prácticas? Probablemente no, ya que intentamos ser explícitos sobre las prácticas que creemos que deberías evitar. Entonces, si algo no se cubre aquí, simplemente significa que se construyen un par de cientos de paquetes R muy utilizados sin una dependencia significativa de esa técnica. Esa observación debería motivarlo a evaluar qué tan probable es que sus requisitos de desarrollo realmente no se superpongan con los nuestros. Pero a veces la respuesta es un claro “sí”, en cuyo caso simplemente necesitarás consultar otro recurso.\n\n\n\n\nMarwick, Ben, Carl Boettiger, y Lincoln Mullen. 2018a. «Packaging Data Analytical Work Reproducibly Using R (and Friends)». The American Statistician 72 (1): 80-88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. «Packaging data analytical work reproducibly using R (and friends)». PeerJ Preprints 6 (marzo): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "introduction.html#footnotes",
    "href": "introduction.html#footnotes",
    "title": "Introducción",
    "section": "",
    "text": "Los usuarios de Emacs Speaks Statistics (ESS) encontrarán que muchos de los flujos de trabajo descritos en este libro también están disponibles allí. Para aquellos leales a vim, recomendamos el Nvim-R plugin.↩︎\nTambién puede disfrutar de la versión “en Quarto” en https://rstudio.github.io/r-manuals/r-exts/.↩︎",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "1  Todo el juego",
    "section": "",
    "text": "1.1 Cargar devtools y amigos\n¡Alerta de spoiler!\nEste capítulo recorre el desarrollo de un pequeño paquete de juguete. Su objetivo es pintar el panorama general y sugerir un flujo de trabajo, antes de pasar al tratamiento detallado de los componentes clave de un paquete R.\nPara mantener el ritmo rápido, aprovechamos las comodidades modernas del paquete devtools y el IDE de RStudio. En capítulos posteriores, seremos más explícitos acerca de lo que esos ayudantes están haciendo por nosotros.\nEste capítulo es independiente, ya que completar el ejercicio no es un requisito estricto para continuar con el resto del libro; sin embargo, le sugerimos encarecidamente que lo siga y cree este paquete de juguete con nosotros.\nPuede iniciar su nuevo paquete desde cualquier sesión de R activa. No necesita preocuparse por si está en un proyecto nuevo o existente o no. Las funciones que utilizamos garantizan que creemos un nuevo proyecto limpio para el paquete.\nCargue el paquete devtools, que es la cara pública de un conjunto de paquetes que admiten varios aspectos del desarrollo de paquetes. El más obvio de ellos es el paquete usethis, que verá que también se está cargando.\nlibrary(devtools)\n#&gt; Loading required package: usethis\n¿Tienes una versión antigua de devtools? Compare su versión con la nuestra y actualícela si es necesario.\npackageVersion(\"devtools\")\n#&gt; [1] '2.4.5'",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#paquete-de-juguete-regexcite",
    "href": "whole-game.html#paquete-de-juguete-regexcite",
    "title": "1  Todo el juego",
    "section": "\n1.2 Paquete de juguete: regexcite",
    "text": "1.2 Paquete de juguete: regexcite\nPara ayudarle a través del proceso, utilizamos varias funciones de devtools para crear un pequeño paquete de juguete desde cero, con características que se ven comúnmente en los paquetes lanzados:\n\nFunciones para abordar una necesidad específica, en este caso ayudantes para trabajar con expresiones regulares.\nControl de versiones y proceso de desarrollo abierto.\n\nEsto es completamente opcional en tu trabajo, pero muy recomendable. Verás cómo Git y GitHub nos ayudan a exponer todas las etapas intermedias de nuestro paquete de juguete.\n\n\nAcceso a flujos de trabajo establecidos para instalación, obtención de ayuda y verificación de calidad.\n\nDocumentación para funciones individuales mediante roxygen2.\nPruebas unitarias con testthat.\nDocumentación del paquete en su conjunto a través de un ejecutable. README.Rmd.\n\n\n\nLlamamos al paquete regexcite y contiene un par de funciones que facilitan las tareas comunes con expresiones regulares. Tenga en cuenta que estas funciones son muy simples y solo las utilizamos aquí como medio para guiarlo a través del proceso de desarrollo del paquete. Si está buscando ayudas reales para trabajar con expresiones regulares, existen varios paquetes de R adecuados que abordan este espacio problemático:\n\n\nstringr (which uses stringi)\nstringi\nrex\nrematch2\n\nNuevamente, el paquete regexcite en sí es solo un dispositivo para demostrar un flujo de trabajo típico para el desarrollo de paquetes con devtools.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#vista-previa-del-producto-terminado",
    "href": "whole-game.html#vista-previa-del-producto-terminado",
    "title": "1  Todo el juego",
    "section": "\n1.3 Vista previa del producto terminado",
    "text": "1.3 Vista previa del producto terminado\nSe realiza un seguimiento del paquete regexcite durante su desarrollo con el sistema de control de versiones Git. Esto es puramente opcional y ciertamente puede seguirlo sin implementarlo. Un buen beneficio adicional es que eventualmente lo conectamos a un repositorio remoto en GitHub, lo que significa que puedes ver el glorioso resultado por el que estamos trabajando visitando regexcite en GitHub: https://github.com/jennybc/regexcite. Al inspeccionar el commit history y especialmente las diferencias, puedes ver exactamente qué cambios en cada paso del proceso que se detalla a continuación.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#create_package",
    "href": "whole-game.html#create_package",
    "title": "1  Todo el juego",
    "section": "\n1.4 create_package()\n",
    "text": "1.4 create_package()\n\nLlame a create_package() para inicializar un nuevo paquete en un directorio de su computadora. create_package() creará automáticamente ese directorio si aún no existe (y ese suele ser el caso). Consulte Sección 4.1 para obtener más información sobre la creación de paquetes.\nElija deliberadamente dónde crear este paquete en su computadora. Probablemente debería estar en algún lugar de su directorio de inicio, junto con sus otros proyectos de R. No debe estar anidado dentro de otro proyecto RStudio, paquete R o repositorio Git. Tampoco debería estar en una biblioteca de paquetes de R, que contiene paquetes que ya han sido creados e instalados. La conversión del paquete fuente que creamos aquí en un paquete instalado es parte de lo que facilita devtools. ¡No intentes hacer el trabajo de devtools por el!\nUna vez que haya seleccionado dónde crear este paquete, sustituya la ruta elegida por una llamada create_package() como esta:\n\ncreate_package(\"~/path/to/regexcite\")\n\nPara la creación de este libro tenemos que trabajar en un directorio temporal, porque el libro está construido de forma no interactiva en la nube. Detrás de escena, estamos ejecutando nuestro propio comando create_package(), pero no te sorprendas si nuestra salida difiere un poco de la tuya.\n\n#&gt; ✔ Creating '/tmp/Rtmp3Xe5yE/regexcite/'\n#&gt; ✔ Setting active project to '/tmp/Rtmp3Xe5yE/regexcite'\n#&gt; ✔ Creating 'R/'\n#&gt; ✔ Writing 'DESCRIPTION'\n#&gt; Package: regexcite\n#&gt; Title: What the Package Does (One Line, Title Case)\n#&gt; Version: 0.0.0.9000\n#&gt; Authors@R (parsed):\n#&gt;     * First Last &lt;first.last@example.com&gt; [aut, cre] (YOUR-ORCID-ID)\n#&gt; Description: What the package does (one paragraph).\n#&gt; License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n#&gt;     license\n#&gt; Encoding: UTF-8\n#&gt; Roxygen: list(markdown = TRUE)\n#&gt; RoxygenNote: 7.3.1\n#&gt; ✔ Writing 'NAMESPACE'\n#&gt; ✔ Writing 'regexcite.Rproj'\n#&gt; ✔ Adding '^regexcite\\\\.Rproj$' to '.Rbuildignore'\n#&gt; ✔ Adding '.Rproj.user' to '.gitignore'\n#&gt; ✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\n\nSi está trabajando en RStudio, debería encontrarse en una nueva instancia de RStudio, abierta en su nuevo paquete regexcite (y Proyecto). Si de alguna manera necesita hacer esto manualmente, navegue hasta el directorio y haga doble clic en regexcite.Rproj. RStudio tiene un manejo especial para paquetes y ahora debería ver una pestaña Build en el mismo panel que Environment e History.\nProbablemente necesites llamar a library(devtools) nuevamente, porque create_package() probablemente te haya llevado a una nueva sesión de R, en tu nuevo paquete.\n\nlibrary(devtools)\n\n¿Qué hay en este nuevo directorio que también es un paquete R y, probablemente, un proyecto RStudio? Aquí hay una lista (localmente, puede consultar su panel Files):\n\n\n\n\npath\ntype\n\n\n\n.Rbuildignore\nfile\n\n\n.gitignore\nfile\n\n\nDESCRIPTION\nfile\n\n\nNAMESPACE\nfile\n\n\nR\ndirectory\n\n\nregexcite.Rproj\nfile\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nEn el panel Files, vaya a More (símbolo de engranaje) &gt; Show Hidden Files para alternar la visibilidad de archivos ocultos (a.k.a. “dotfiles”). Unos pocos seleccionados están visibles todo el tiempo, pero a veces quieres verlos todos.\n\n\n\n\n.Rbuildignore enumera los archivos que necesitamos tener a mano pero que no deben incluirse al crear el paquete R desde el código fuente. Si no está utilizando RStudio, es posible que create_package() no cree este archivo (ni tampoco .gitignore) al principio, ya que no hay ninguna maquinaria relacionada con RStudio que deba ignorarse. Sin embargo, es probable que en algún momento desarrolle la necesidad de .Rbuildignore, independientemente del editor que esté utilizando. Se analiza con más detalle en Sección 3.3.1.\n\n.Rproj.user, si lo tiene, es un directorio utilizado internamente por RStudio.\n\n.gitignore anticipa el uso de Git y le dice a Git que ignore algunos archivos estándar detrás de escena creados por R y RStudio. Incluso si no planeas usar Git, esto es inofensivo.\n\nDESCRIPTION proporciona metadatos sobre su paquete. Editaremos esto en breve y Capítulo 9 cubre el tema general del archivo DESCRIPTION.\n\nNAMESPACE declara las funciones que su paquete exporta para uso externo y las funciones externas que su paquete importa de otros paquetes. En este punto, está vacío, excepto por un comentario que declara que este es un archivo que no debes editar a mano.\nEl directorio R/ es el “final comercial” de su paquete. Pronto contendrá archivos .R con definiciones de funciones.\n\nregexcite.Rproj es el archivo que convierte este directorio en un proyecto RStudio. Incluso si no utiliza RStudio, este archivo es inofensivo. O puede suprimir su creación con create_package(..., rstudio = FALSE). Más en Sección 4.2.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_git",
    "href": "whole-game.html#use_git",
    "title": "1  Todo el juego",
    "section": "\n1.5 use_git()\n",
    "text": "1.5 use_git()\n\nEl directorio regexcite es un paquete fuente de R y un proyecto RStudio. Ahora lo convertimos también en un repositorio Git, con use_git(). (Por cierto, use_git() funciona en cualquier proyecto, independientemente de si es un paquete R).\n\nuse_git()\n#&gt; ✔ Initialising Git repo\n#&gt; ✔ Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\n\nEn una sesión interactiva, se le preguntará si desea enviar algunos archivos aquí y deberá aceptar la oferta. Detrás de escena, también enviaremos esos mismos archivos.\nEntonces, ¿qué ha cambiado en el paquete? Sólo la creación de un directorio .git, que está oculto en la mayoría de los contextos, incluido el explorador de archivos RStudio. Su existencia es evidencia de que efectivamente hemos inicializado un repositorio de Git aquí.\n\n\n\n\npath\ntype\n\n\n.git\ndirectory\n\n\n\n\nSi está utilizando RStudio, probablemente solicitó permiso para reiniciarse en este proyecto, lo cual debería hacer. Puede hacerlo manualmente saliendo y luego reiniciando RStudio haciendo doble clic en regexcite.Rproj. Ahora, además del soporte para el desarrollo de paquetes, tiene acceso a un cliente Git básico en la pestaña Git del panel Environment/History/Build.\n\nHaga clic en Historial (el ícono del reloj en el panel de Git) y, si dio su consentimiento, verá una confirmación inicial realizada a través de use_git():\n\n\n\n\ncommit\nauthor\nmessage\n\n\n2d6dda0ee0…\nQuarto GHA Workflow Runner quarto-github-actions-publish@example.com\n\nInitial commit\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio puede inicializar un repositorio Git, en cualquier proyecto, incluso si no es un paquete R, siempre que haya configurado la integración de RStudio + Git. Hacer Tools &gt; Version Control &gt; Project Setup. Entonces seleccione Version control system: Git y initialize a new git repository for this project.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#escribe-la-primera-función.",
    "href": "whole-game.html#escribe-la-primera-función.",
    "title": "1  Todo el juego",
    "section": "\n1.6 Escribe la primera función.",
    "text": "1.6 Escribe la primera función.\nUna tarea bastante común cuando se trata de cadenas es la necesidad de dividir una única cadena en muchas partes. La función strsplit() en base R hace exactamente esto.\n\n(x &lt;- \"alfa,bravo,charlie,delta\")\n#&gt; [1] \"alfa,bravo,charlie,delta\"\nstrsplit(x, split = \",\")\n#&gt; [[1]]\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nObserve de cerca el valor de retorno.\n\nstr(strsplit(x, split = \",\"))\n#&gt; List of 1\n#&gt;  $ : chr [1:4] \"alfa\" \"bravo\" \"charlie\" \"delta\"\n\nLa forma de este valor de retorno a menudo sorprende a la gente o, al menos, les incomoda. La entrada es un vector de caracteres de longitud uno y la salida es una lista de longitud uno. Esto tiene mucho sentido a la luz de la tendencia fundamental de R hacia la vectorización. Pero a veces sigue siendo un poco fastidioso. A menudo sabes que tu entrada es moralmente un escalar, es decir, es solo una cadena y realmente quieres que la salida sea el vector de caracteres de sus partes.\nEsto lleva a los usuarios de R a emplear varios métodos para “deslistar” el resultado:\n\nunlist(strsplit(x, split = \",\"))\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nstrsplit(x, split = \",\")[[1]]\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nLa segunda solución, más segura, es la base para la función inaugural de regexcite: strsplit1().\n\nstrsplit1 &lt;- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\nEste libro no le enseña cómo escribir funciones en R. Para obtener más información al respecto, eche un vistazo a Capítulo de funciones de R para Ciencia de Datos y el Capítulo de funciones de R Avanzado.\n\n\n\n\n\n\nTip\n\n\n\nEl nombre de strsplit1() es un guiño al muy útil paste0(), que apareció por primera vez en R 2.15.0 en 2012. paste0() fue creado para abordar el caso de uso extremadamente común de pegar - unir cadenas sin un separador. paste0() ha sido descrito cariñosamente como “la contribución más influyente de la informática estadística del siglo XXI”.\nLa función strsplit1() fue tan inspiradora que ahora es una función real en el paquete stringr: stringr::str_split_1()!",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_r",
    "href": "whole-game.html#use_r",
    "title": "1  Todo el juego",
    "section": "\n1.7 use_r()\n",
    "text": "1.7 use_r()\n\n¿Dónde deberías poner la definición de strsplit1()? Guárdelo en un archivo .R, en el subdirectorio R/ de su paquete. Una posición inicial razonable es crear un nuevo archivo .R para cada función orientada al usuario en su paquete y nombrar el archivo después de la función. A medida que agregue más funciones, querrá relajar esto y comenzar a agrupar funciones relacionadas. Guardaremos la definición de strsplit1() en el archivo R/strsplit1.R.\nEl asistente use_r() crea y/o abre un script debajo de R/. Realmente brilla en un paquete más maduro, cuando se navega entre archivos .R y el archivo de prueba asociado. Pero incluso en este caso es útil evitar dejarse llevar demasiado mientras se trabaja en Untitled4.\n\nuse_r(\"strsplit1\")\n#&gt; • Edit 'R/strsplit1.R'\n\nColoque la definición de strsplit1() y solo la definición de strsplit1() en R/strsplit1.R y guárdela. El archivo R/strsplit1.R NO debe contener ningún otro código de nivel superior que hayamos ejecutado recientemente, como la definición de nuestra entrada de práctica x, library(devtools) o use_git() . Esto presagia un ajuste que deberá realizar a medida que pasa de escribir scripts R a paquetes R. Los paquetes y scripts utilizan diferentes mecanismos para declarar su dependencia de otros paquetes y almacenar código de ejemplo o de prueba. Exploramos esto más a fondo en Capítulo 6.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#sec-whole-game-load-all",
    "href": "whole-game.html#sec-whole-game-load-all",
    "title": "1  Todo el juego",
    "section": "\n1.8 load_all()\n",
    "text": "1.8 load_all()\n\n¿Cómo probamos strsplit1()? Si se tratara de un script R normal, podríamos usar RStudio para enviar la definición de la función a la Consola R y definir strsplit1() en el entorno global. O tal vez llamaríamos source (\"R/strsplit1.R\"). Sin embargo, para el desarrollo de paquetes, devtools ofrece un enfoque más sólido.\nLlame a load_all() para que strsplit1() esté disponible para la experimentación.\n\nload_all()\n#&gt; ℹ Loading regexcite\n\nAhora llame a strsplit1(x) para ver cómo funciona.\n\n(x &lt;- \"alfa,bravo,charlie,delta\")\n#&gt; [1] \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\nTenga en cuenta que load_all() ha hecho que la función strsplit1() esté disponible, aunque no existe en el entorno global.\n\nexists(\"strsplit1\", where = globalenv(), inherits = FALSE)\n#&gt; [1] FALSE\n\nSi ve TRUE en lugar de FALSE, eso indica que todavía está utilizando un flujo de trabajo orientado a secuencias de comandos y obteniendo sus funciones. A continuación le indicamos cómo volver a la normalidad:\n\nLimpie el entorno global y reinicie R.\nVuelva a adjuntar devtools con library(devtools) y vuelva a cargar regexcite con load_all().\nRedefina la entrada de prueba x y llame a strsplit1(x, split = \",\") nuevamente. ¡Esto debería funcionar!\nEjecute exists(\"strsplit1\", donde = globalenv(), hereda = FALSE) nuevamente y debería ver FALSE.\n\nload_all() Simula el proceso de construcción, instalación y conexión del paquete regexcite. A medida que su paquete acumula más funciones, algunas exportadas, otras no, algunas de las cuales se llaman entre sí, algunas de las cuales llaman a funciones de paquetes de los que depende, load_all() le brinda una idea mucho más precisa de cómo se está desarrollando el paquete que funciones de conducción de prueba definidas en el entorno global. Además, load_all() permite una iteración mucho más rápida que construir, instalar y adjuntar el paquete. Consulte Sección 4.4 para obtener más información sobre load_all().\nPara revisar lo que hemos hecho hasta ahora:\n\nEscribimos nuestra primera función, strsplit1(), para dividir una cadena en un vector de caracteres (no una lista que contenga un vector de caracteres).\nUsamos load_all() para hacer que esta función esté disponible rápidamente para uso interactivo, como si hubiéramos creado e instalado regexcite y lo hubiéramos adjuntado a través de library(regexcite).\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone load_all() en el menu Build, en el panel Build via More &gt; Load All, y en atajos de teclado Ctrl + Shift + L (Windows & Linux) o Cmd + Shift + L (macOS).\n\n\n\n1.8.1 Commit strsplit1()\n\nSi estás usando Git, usa tu método preferido para enviar el nuevo archivo R/strsplit1.R. Lo hacemos detrás de escena aquí y aquí está la diferencia asociada.\n\ndiff --git a/R/strsplit1.R b/R/strsplit1.R\nnew file mode 100644\nindex 0000000..29efb88\n--- /dev/null\n+++ b/R/strsplit1.R\n@@ -0,0 +1,3 @@\n+strsplit1 &lt;- function(x, split) {\n+  strsplit(x, split = split)[[1]]\n+}\n\nA partir de este momento, realizaremos un commit después de cada paso. Recuerda estos commits están disponibles en el repositorio público.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#check",
    "href": "whole-game.html#check",
    "title": "1  Todo el juego",
    "section": "\n1.9 check()\n",
    "text": "1.9 check()\n\nTenemos evidencia empírica e informal de que strsplit1() funciona. Pero, ¿cómo podemos estar seguros de que todas las partes móviles del paquete regexcite siguen funcionando? Puede parecer una tontería comprobarlo después de una adición tan pequeña, pero es bueno establecer el hábito de comprobarlo con frecuencia.\nR CMD check, ejecutado en el shell, es el estándar de oro para comprobar que un paquete R está en pleno funcionamiento. check() es una forma conveniente de ejecutar esto sin salir de la sesión de R.\nTenga en cuenta que check() produce una salida bastante voluminosa, optimizada para el consumo interactivo. Lo interceptamos aquí y solo revelamos un resumen. Su salida local check() será diferente.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 5.6s\n\n❯ checking DESCRIPTION meta-information ... WARNING\n  Non-standard license specification:\n    `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\n  Standardizable: FALSE\n\n0 errors ✔ | 1 warning ✖ | 0 notes ✔\n\n¡Es esencial leer realmente el resultado del cheque! Aborde los problemas tempranamente y con frecuencia. Es como el desarrollo incremental de archivos .R y .Rmd. Cuanto más tiempo pase entre comprobaciones completas de que todo funciona, más difícil será identificar y resolver sus problemas.\nEn este punto, esperamos 1 advertencia (y 0 errores, 0 notas):\nNon-standard license specification:\n  `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n  license\nAbordaremos eso pronto, haciendo exactamente lo que dice. Puedes aprender más sobre check() en Sección 4.5.\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone check() en el menú Build, en el panel Build a través de Check y en los atajos de teclado Ctrl + Shift + E (Windows & Linux) o Cmd + Shift + E (macOS).",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#editar-description",
    "href": "whole-game.html#editar-description",
    "title": "1  Todo el juego",
    "section": "\n1.10 Editar DESCRIPTION\n",
    "text": "1.10 Editar DESCRIPTION\n\nEl archivo DESCRIPTION proporciona metadatos sobre su paquete y se trata completamente en Capítulo 9. Este es un buen momento para echar un vistazo a la descripción actual de regexcite. Verá que está lleno de contenido repetitivo, que debe ser reemplazado.\nPara agregar sus propios metadatos, realice estas ediciones:\n\nConviértete en el autor. Si no tiene un ORCID, puede omitir la parte coment = ....\nEscriba un texto descriptivo en los campos Title y Description.\n\n\n\n\n\n\n\nRStudio\n\n\n\nUse Ctrl + . en RStudio y comienza a escribir “DESCRIPTION” para activar un asistente que facilita la apertura de un archivo para editarlo. Además de un nombre de archivo, su sugerencia puede ser el nombre de una función. Esto es muy útil cuando un paquete tiene muchos archivos.\n\n\nCuando termines, DESCRIPTION debería verse similar a esto:\n\n\nPackage: regexcite\nTitle: Haga que las expresiones regulares sean más emocionantes\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"Jane\", \"Doe\", , \"jane@example.com\", role = c(\"aut\", \"cre\"))\nDescription: Funciones convenientes para facilitar un poco algunas tareas\n    comunes con manipulación de cadenas y expresiones regulares.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.2",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_mit_license",
    "href": "whole-game.html#use_mit_license",
    "title": "1  Todo el juego",
    "section": "\n1.11 use_mit_license()\n",
    "text": "1.11 use_mit_license()\n\n\nElija una licencia, cualquier licencia. – Jeff Atwood\n\nActualmente tenemos un marcador de posición en el campo License de DESCRIPTION que es deliberadamente inválido y sugiere una solución.\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nPara configurar una licencia válida para el paquete, llame use_mit_license().\n\nuse_mit_license()\n#&gt; ✔ Adding 'MIT + file LICENSE' to License\n#&gt; ✔ Writing 'LICENSE'\n#&gt; ✔ Writing 'LICENSE.md'\n#&gt; ✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n\nEsto configura correctamente el campo License para la licencia MIT, que promete nombrar a los titulares de los derechos de autor y el año en un archivo LICENSE. Abra el archivo LICENSE recién creado y confirme que se ve así:\n\nYEAR: 2025\nCOPYRIGHT HOLDER: regexcite authors\n\nAl igual que otros asistentes de licencia, use_mit_license() también coloca una copia de la licencia completa en LICENSE.md y agrega este archivo a .Rbuildignore. Se considera una buena práctica incluir una licencia completa en el código fuente de su paquete, como en GitHub, pero CRAN no permite la inclusión de este archivo en un paquete. Puede obtener más información sobre las licencias en Capítulo 12.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#sec-whole-game-document",
    "href": "whole-game.html#sec-whole-game-document",
    "title": "1  Todo el juego",
    "section": "\n1.12 document()\n",
    "text": "1.12 document()\n\n¿No sería bueno recibir ayuda sobre strsplit1(), tal como lo hacemos con otras funciones de R? Esto requiere que su paquete tenga un archivo de documentación R especial, man/strsplit1.Rd, escrito en un lenguaje de marcado específico de R que es algo así como LaTeX. Afortunadamente, no necesariamente tenemos que crear eso directamente.\nEscribimos un comentario con formato especial justo encima de strsplit1(), en su archivo fuente, y luego dejamos que un paquete llamado roxygen2 manejar la creación de man/strsplit1.Rd. La motivación y la mecánica de roxygen2 se tratan en Capítulo 16.\nSi usa RStudio, abra R/strsplit1.R en el editor de código fuente y coloque el cursor en algún lugar de la definición de la función strsplit1(). Ahora haz Code &gt; Insert roxygen skeleton. Debería aparecer un comentario muy especial encima de tu función, en el que cada línea comienza con #'. RStudio solo inserta una plantilla básica, por lo que deberá editarla para que se vea así a continuación.\nSi no utiliza RStudio, cree el comentario usted mismo. De todos modos, debes modificarlo para que se vea así:\n\n#' dividir una cadena de caracteres\n#'\n#' @param x Un vector de caracteres con un elemento..\n#' @param split En qué dividirse.\n#'\n#' @return Un vector de caracteres.\n#' @export\n#'\n#' @examples\n#' x &lt;- \"alfa,bravo,charlie,delta\"\n#' strsplit1(x, split = \",\")\nstrsplit1 &lt;- function(x, split) {\n  strsplit(x, split = split)[[1]]\n}\n\n\n¡Pero aún no hemos terminado! Todavía tenemos que activar la conversión de este nuevo comentario de roxygen en man/strsplit1.Rd con document():\n\ndocument()\n#&gt; ℹ Updating regexcite documentation\n#&gt; Setting `RoxygenNote` to \"7.3.1\"\n#&gt; ℹ Loading regexcite\n#&gt; Writing 'NAMESPACE'\n#&gt; Writing 'strsplit1.Rd'\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone document() en el menú Build, en el panel Build a través de More &gt; Document y con atajos de teclado Ctrl + Shift + D (Windows & Linux) o Cmd + Shift + D (macOS).\n\n\nAhora debería poder obtener una vista previa de su archivo de ayuda de esta manera:\n\n?strsplit1\n\nVerás un mensaje como “Rendering development documentation for ‘strsplit1’”, lo que recuerda que básicamente está obteniendo una vista previa del borrador de la documentación. Es decir, esta documentación está presente en el código fuente de su paquete, pero aún no está presente en un paquete instalado. De hecho, todavía no hemos instalado regexcite, pero lo haremos pronto. Si ?strsplit1 no funciona para usted, es posible que deba llamar a load_all() primero y luego intentarlo nuevamente.\nTenga en cuenta también que la documentación de su paquete no se conectará correctamente hasta que se haya construido e instalado formalmente. Esto elimina detalles como los enlaces entre archivos de ayuda y la creación de un índice de paquetes.\n\n1.12.1 NAMESPACE cambios\nAdemás de convertir el comentario especial de strsplit1() en man/strsplit1.Rd, la llamada a document() actualiza el archivo NAMESPACE, basándose en las etiquetas @export que se encuentran en los comentarios de roxygen. Abra NAMESPACE para su inspección. Los contenidos deben ser:\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(strsplit1)\n\nLa directiva de exportación en NAMESPACE es lo que hace que strsplit1() esté disponible para un usuario después de adjuntar regexcite a través de library(regexcite). Así como es completamente posible crear archivos .Rd “a mano”, puedes administrar NAMESPACE explícitamente tú mismo. Pero elegimos delegar esto a devtools (y a roxygen2).",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#check-de-nuevo",
    "href": "whole-game.html#check-de-nuevo",
    "title": "1  Todo el juego",
    "section": "\n1.13 check() de nuevo",
    "text": "1.13 check() de nuevo\nregexcite debería pasar la R CMD check limpiamente ahora y para siempre: 0 errores, 0 advertencias, 0 notas.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 6.9s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#install",
    "href": "whole-game.html#install",
    "title": "1  Todo el juego",
    "section": "\n1.14 install()\n",
    "text": "1.14 install()\n\nAhora que sabemos que tenemos un producto mínimo viable, instalemos el paquete regexcite en su biblioteca mediante install():\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file ‘/tmp/Rtmp3Xe5yE/regexcite/DESCRIPTION’ ... OK\n* preparing ‘regexcite’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building ‘regexcite_0.0.0.9000.tar.gz’\nRunning /opt/R/4.4.0/lib/R/bin/R CMD INSTALL \\\n  /tmp/Rtmp3Xe5yE/regexcite_0.0.0.9000.tar.gz --install-tests \n* installing to library ‘/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu’\n* installing *source* package ‘regexcite’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone una funcionalidad similar en el menu Build y en el panel Build via Install and Restart, y con atajos de teclado Ctrl + Shift + B (Windows & Linux) o Cmd + Shift + B (macOS).\n\n\nUna vez completada la instalación, podemos adjuntar y usar regexcite como cualquier otro paquete. Revisemos nuestro pequeño ejemplo desde arriba. Este también es un buen momento para reiniciar su sesión de R y asegurarse de tener un espacio de trabajo limpio.\n\nlibrary(regexcite)\n\nx &lt;- \"alfa,bravo,charlie,delta\"\nstrsplit1(x, split = \",\")\n#&gt; [1] \"alfa\"    \"bravo\"   \"charlie\" \"delta\"\n\n¡Éxito!",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_testthat",
    "href": "whole-game.html#use_testthat",
    "title": "1  Todo el juego",
    "section": "\n1.15 use_testthat()\n",
    "text": "1.15 use_testthat()\n\nHemos probado strsplit1() de manera informal, en un solo ejemplo. Podemos formalizar esto como una prueba unitaria. Esto significa que expresamos una expectativa concreta sobre el resultado correcto de strsplit1() para una entrada específica.\nPrimero, declaramos nuestra intención de escribir pruebas unitarias y usar el paquete testthat para esto, a través de use_testthat():\n\nuse_testthat()\n#&gt; ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n#&gt; ✔ Adding '3' to Config/testthat/edition\n#&gt; ✔ Creating 'tests/testthat/'\n#&gt; ✔ Writing 'tests/testthat.R'\n#&gt; • Call `use_test()` to initialize a basic test file and open it for editing.\n\nEsto inicializa la maquinaria de prueba unitaria para su paquete. Añade Suggests: testthat a DESCRIPTION, crea el directorio tests/testthat/, y añade el script tests/testthat.R. Notarás que la prueba probablemente se agregó con una versión mínima de 3.0.0 y un segundo campo DESCRIPTION, Config/testthat/edition: 3. Hablaremos más sobre esos detalles en Capítulo 13.\nSin embargo, ¡todavía depende de USTED escribir las pruebas reales!\nEl asistente use_test() abre y/o crea un archivo de prueba. Puede proporcionar el nombre base del archivo o, si está editando el archivo fuente relevante en RStudio, se generará automáticamente. Para muchos de ustedes, si R/strsplit1.R es el archivo activo en RStudio, pueden simplemente llamar a use_test(). Sin embargo, dado que este libro no se creó de forma interactiva, debemos proporcionar el nombre base de forma explícita:\n\nuse_test(\"strsplit1\")\n#&gt; ✔ Writing 'tests/testthat/test-strsplit1.R'\n#&gt; • Edit 'tests/testthat/test-strsplit1.R'\n\nEsto crea el archivo tests/testthat/test-strsplit1.R. Si ya hubiera existido, use_test() simplemente lo habría abierto. Notarás que hay una prueba de ejemplo en el archivo recién creado; elimina ese código y reemplázalo con este contenido:\n\ntest_that(\"strsplit1() splits a string\", {\n  expect_equal(strsplit1(\"a,b,c\", split = \",\"), c(\"a\", \"b\", \"c\"))\n})\n\nEsto prueba que strsplit1() da el resultado esperado al dividir una cadena de caracteres.\nEjecute esta prueba de forma interactiva, como lo hará cuando escriba la suya propia. Si no se puede encontrar test_that() o strsplit1(), eso sugiere que probablemente necesites llamar a load_all().\nEn el futuro, sus pruebas se ejecutarán principalmente en masa y en condiciones de plena competencia a través de test():\n\n\ntest()\n#&gt; ℹ Testing regexcite\n#&gt; ✔ | F W  S  OK | Context\n#&gt; \n#&gt; ⠏ |          0 | strsplit1                                          \n#&gt; ✔ |          1 | strsplit1\n#&gt; \n#&gt; ══ Results ═════════════════════════════════════════════════════════\n#&gt; [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone test() en el menú Build, en el panel Build via More &gt; Test package, y con atajos de teclado Ctrl + Shift + T (Windows & Linux) o Cmd + Shift + T (macOS).\n\n\nSus pruebas también se ejecutan cada vez que check() el paquete. De esta manera, básicamente aumentas los controles estándar con algunos propios, que son específicos de tu paquete. Es una buena idea utilizar el paquete covr para realizar un seguimiento de qué proporción del código fuente de su paquete se ejerce mediante las pruebas. Se pueden encontrar más detalles en Sección 14.1.1.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_package",
    "href": "whole-game.html#use_package",
    "title": "1  Todo el juego",
    "section": "\n1.16 use_package()\n",
    "text": "1.16 use_package()\n\nInevitablemente querrás utilizar una función de otro paquete en tu propio paquete. Necesitaremos usar métodos específicos de paquetes para declarar los otros paquetes que necesitamos (es decir, nuestras dependencias) y para usar estos paquetes en los nuestros. Si planea enviar un paquete a CRAN, tenga en cuenta que esto se aplica incluso a funciones en paquetes que considera “siempre disponibles”, como stats::median() o utils::head().\nUn dilema común al utilizar las funciones de expresión regular de R es la incertidumbre sobre si solicitar perl = TRUE o perl = FALSE. Y luego, a menudo, pero no siempre, hay otros argumentos que alteran la forma en que se combinan los patrones, como fixed, ignore.case e invert. Puede ser difícil realizar un seguimiento de qué funciones utilizan qué argumentos y cómo interactúan los argumentos, por lo que muchos usuarios nunca llegan al punto en el que conservan estos detalles sin volver a leer los documentos.\nEl paquete stringr “proporciona un conjunto coherente de funciones diseñadas para hacer que trabajar con cadenas de caracteres sea lo más fácil posible”. En particular, stringr usa un sistema de expresión regular en todas partes (expresiones regulares ICU) y usa la misma interfaz en cada función para controlar comportamientos coincidentes, como la distinción entre mayúsculas y minúsculas. A algunas personas les resulta más fácil internalizar y programar esto. Imaginemos que decide que prefiere construir regexcite basado en stringr (y stringi) que en las funciones de expresión regular de base R.\nPrimero, declare su intención general de utilizar algunas funciones del espacio de nombres stringr con use_package():\n\nuse_package(\"stringr\")\n#&gt; ✔ Adding 'stringr' to Imports field in DESCRIPTION\n#&gt; • Refer to functions with `stringr::fun()`\n\nEsto agrega el paquete stringr al campo Imports de DESCRIPTION. Y eso es todo lo que hace.\nVolvamos a visitar strsplit1() para hacerlo más parecido a una cadena. Aquí hay una nueva versión1:\n\nstr_split_one &lt;- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) &lt;= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\nTenga en cuenta que nosotros:\n\nCambie el nombre de la función a str_split_one(), para indicar que es un contenedor alrededor de stringr::str_split().\nAdopte los nombres de los argumentos de stringr::str_split(). Ahora tenemos string y pattern (y n), en lugar de x y split.\nIntroducir un poco de verificación de argumentos y manejo de casos extremos. Esto no está relacionado con el cambio a stringr y sería igualmente beneficioso en la versión construida en strsplit().\nUtilice el formulario paquete::función() al llamar a stringr::str_split(). Esto especifica que queremos llamar a la función str_split() desde el espacio de nombres stringr. Hay más de una forma de llamar a una función desde otro paquete y la que recomendamos aquí se explica detalladamente en Capítulo 11.\n\n¿Dónde deberíamos escribir esta nueva definición de función? Si queremos seguir la convención en la que nombramos el archivo .R después de la función que define, ahora necesitamos realizar algunos cambios complicados en los archivos. Debido a que esto ocurre con bastante frecuencia en la vida real, tenemos la función rename_files(), que coreografía el cambio de nombre de un archivo en R/ y sus archivos complementarios asociados debajo de test/.\n\nrename_files(\"strsplit1\", \"str_split_one\")\n#&gt; ✔ Moving 'R/strsplit1.R' to 'R/str_split_one.R'\n#&gt; ✔ Moving 'tests/testthat/test-strsplit1.R' to 'tests/testthat/test-str_split_one.R'\n\nRecuerde: el trabajo del nombre del archivo es puramente aspiracional. ¡Aún necesitamos actualizar el contenido de estos archivos!\nAquí están los contenidos actualizados de R/str_split_one.R. Además de cambiar la definición de la función, también actualizamos el encabezado de roxygen para reflejar los nuevos argumentos e incluir ejemplos que muestren las características de stringr.\n\n#' dividir una cadena de caracteres\n#'\n#' @param string Un vector de caracteres con, como máximo, un elemento.\n#' @inheritParams stringr::str_split\n#'\n#' @return Un vector de caracteres.\n#' @export\n#'\n#' @examples\n#' x &lt;- \"alfa,bravo,charlie,delta\"\n#' str_split_one(x, pattern = \",\")\n#' str_split_one(x, pattern = \",\", n = 2)\n#'\n#' y &lt;- \"192.168.0.1\"\n#' str_split_one(y, pattern = stringr::fixed(\".\"))\nstr_split_one &lt;- function(string, pattern, n = Inf) {\n  stopifnot(is.character(string), length(string) &lt;= 1)\n  if (length(string) == 1) {\n    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]\n  } else {\n    character()\n  }\n}\n\n¡No olvides actualizar también el archivo de prueba!\nAquí están los contenidos actualizados de tests/testthat/test-str_split_one.R. Además del cambio en el nombre y los argumentos de la función, agregamos un par de pruebas más.\n\ntest_that(\"str_split_one() divide una cadena de caracteres\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\"), c(\"a\", \"b\", \"c\"))\n})\n\ntest_that(\"str_split_one() errores si la longitud de entrada &gt; 1\", {\n  expect_error(str_split_one(c(\"a,b\",\"c,d\"), \",\"))\n})\n\ntest_that(\"str_split_one() expone características de stringr::str_split()\", {\n  expect_equal(str_split_one(\"a,b,c\", \",\", n = 2), c(\"a\", \"b,c\"))\n  expect_equal(str_split_one(\"a.b\", stringr::fixed(\".\")), c(\"a\", \"b\"))\n})\n\nAntes de probar el nuevo str_split_one(), necesitamos llamar a document(). ¿Por qué? Recuerde que document() realiza dos tareas principales:\n\nConvierte nuestros comentarios de roxygen en documentación R adecuada.\n(Re)genera NAMESPACE.\n\nEl segundo trabajo es especialmente importante aquí, ya que ya no exportaremos strsplit1() y ahora exportaremos str_split_one(). No se desanime por la advertencia sobre \"Objects listed as exports, but not present in namespace: strsplit1\". Eso siempre sucede cuando eliminas algo del espacio de nombres.\n\ndocument()\n#&gt; ℹ Updating regexcite documentation\n#&gt; ℹ Loading regexcite\n#&gt; Warning: Objects listed as exports, but not present in namespace:\n#&gt; • strsplit1\n#&gt; Writing 'NAMESPACE'\n#&gt; Writing 'str_split_one.Rd'\n#&gt; Deleting 'strsplit1.Rd'\n\nPruebe la nueva función str_split_one() simulando la instalación del paquete mediante load_all():\n\nload_all()\n#&gt; ℹ Loading regexcite\nstr_split_one(\"a, b, c\", pattern = \", \")\n#&gt; [1] \"a\" \"b\" \"c\"",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_github",
    "href": "whole-game.html#use_github",
    "title": "1  Todo el juego",
    "section": "\n1.17 use_github()\n",
    "text": "1.17 use_github()\n\nNos has visto haciendo commits durante el proceso de desarrollo de regexcite. Puede ver un historial indicativo en https://github.com/jennybc/regexcite. Nuestro uso del control de versiones y la decisión de exponer el proceso de desarrollo significa que puede inspeccionar el estado de la fuente de regexcite en cada etapa de desarrollo. Al observar las llamadas diferencias, puede ver exactamente cómo cada función auxiliar de devtools modifica los archivos fuente que constituyen el paquete regexcite.\n¿Cómo conectaría su paquete regexcite local y su repositorio Git a un repositorio complementario en GitHub? Aquí hay tres enfoques:\n\n\nuse_github() es una ayuda que recomendamos a largo plazo. No lo demostraremos aquí porque requiere cierta configuración de credenciales por su parte. Tampoco queremos derribar y reconstruir el paquete público de regexcite cada vez que construimos este libro.\n¡Primero configura el repositorio de GitHub! Suena contrario a la intuición, pero la forma más fácil de llevar su trabajo a GitHub es iniciarlo allí y luego usar RStudio para comenzar a trabajar en una copia local sincronizada. Este enfoque se describe en los flujos de trabajo de Happy Git Nuevo proyecto, GitHub primero y Proyecto existente, GitHub primero.\nLa línea de comando Git siempre se puede usar para agregar un repositorio remoto post hoc. Esto se describe en el flujo de trabajo de Happy Git Proyecto existente, GitHub último.\n\nCualquiera de estos enfoques conectará su proyecto regexcite local a un repositorio de GitHub, público o privado, al que puede enviar o extraer usando el cliente Git integrado en RStudio. En Capítulo 20, explicamos por qué vale la pena incorporar el control de versiones (por ejemplo, Git) y, específicamente, el control de versiones alojado (por ejemplo, GitHub) en su proceso de desarrollo de paquetes.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#use_readme_rmd",
    "href": "whole-game.html#use_readme_rmd",
    "title": "1  Todo el juego",
    "section": "\n1.18 use_readme_rmd()\n",
    "text": "1.18 use_readme_rmd()\n\nAhora que su paquete está en GitHub, el archivo README.md es importante. Es la página de inicio y el tapete de bienvenida del paquete, al menos hasta que decida darle un sitio web (ver Capítulo 19), agregar una viñeta (ver Capítulo 17) o enviarlo a CRAN (ver Capítulo 22 ).\nLa función use_readme_rmd() inicializa un README.Rmd básico y ejecutable listo para que usted pueda editar:\n\nuse_readme_rmd()\n#&gt; ✔ Writing 'README.Rmd'\n#&gt; ✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n#&gt; • Update 'README.Rmd' to include installation instructions.\n#&gt; ✔ Writing '.git/hooks/pre-commit'\n\nAdemás de crear README.Rmd, esto agrega algunas líneas a .Rbuildignore y crea un enlace de confirmación previa de Git para ayudarlo a mantener sincronizados README.Rmd y README.md.\nREADME.Rmd ya tiene secciones que le solicitan que:\n\nDescribe el propósito del paquete.\nProporcionar instrucciones de instalación. Si se detecta un control remoto de GitHub cuando se llama a use_readme_rmd(), esta sección está completa con instrucciones sobre cómo instalar desde GitHub.\nMuestra un poco de uso..\n\n¿Cómo poblar este esqueleto? Copie material generosamente de DESCRIPTION y cualquier prueba o ejemplo formal e informal que tenga. Algo es mejor que nada. Esto es útil porque la gente probablemente no instalará su paquete ni revisará los archivos de ayuda individuales para descubrir cómo usarlo.\nNos gusta escribir el README en R Markdown, para que pueda incluir el uso real. La inclusión de código en vivo también hace que sea menos probable que su README se vuelva obsoleto y no esté sincronizado con su paquete real.\nPara realizar sus propias ediciones, si RStudio aún no lo ha hecho, abra README.Rmd para editar. Asegúrese de que muestre algún uso de str_split_one().\nEl README.Rmd que utilizamos está aquí: README.Rmd y esto es lo que contiene:\n\n---\noutput: github_document\n---\n\n&lt;!-- README.md is generated from README.Rmd. Please edit that file --&gt;\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n\n**NOTE: This is a toy package created for expository purposes, for the second edition of [R Packages](https://r-pkgs.org). It is not meant to actually be useful. If you want a package for factor handling, please see [stringr](https://stringr.tidyverse.org), [stringi](https://stringi.gagolewski.com/),\n[rex](https://cran.r-project.org/package=rex), and\n[rematch2](https://cran.r-project.org/package=rematch2).**\n\n# regexcite\n\n&lt;!-- badges: start --&gt;\n&lt;!-- badges: end --&gt;\n\nThe goal of regexcite is to make regular expressions more exciting!\nIt provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.\n\n## Installation\n\nYou can install the development version of regexcite from [GitHub](https://github.com/) with:\n      \n``` r\n# install.packages(\"devtools\")\ndevtools::install_github(\"jennybc/regexcite\")\n```\n\n## Usage\n\nA fairly common task when dealing with strings is the need to split a single string into many parts.\nThis is what `base::strplit()` and `stringr::str_split()` do.\n\n```{r}\n(x &lt;- \"alfa,bravo,charlie,delta\")\nstrsplit(x, split = \",\")\nstringr::str_split(x, pattern = \",\")\n```\n\nNotice how the return value is a **list** of length one, where the first element holds the character vector of parts.\nOften the shape of this output is inconvenient, i.e. we want the un-listed version.\n\nThat's exactly what `regexcite::str_split_one()` does.\n\n```{r}\nlibrary(regexcite)\n\nstr_split_one(x, pattern = \",\")\n```\n\nUse `str_split_one()` when the input is known to be a single string.\nFor safety, it will error if its input has length greater than one.\n\n`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.\n\n```{r}\nstr_split_one(x, pattern = \",\", n = 2)\n\ny &lt;- \"192.168.0.1\"\nstr_split_one(y, pattern = stringr::fixed(\".\"))\n```\n\n¡No olvides renderizarlo para crear README.md! El enlace de confirmación previa debería recordarle si intenta confirmar README.Rmd, pero no README.md, y también cuando README.md parece estar desactualizado.\nLa mejor manera de renderizar README.Rmd es con build_readme(), porque se encarga de renderizar con la versión más actual de su paquete, es decir, instala una copia temporal de la fuente actual.\n\nbuild_readme()\n#&gt; ℹ Installing regexcite in temporary library\n#&gt; ℹ Building '/tmp/Rtmp3Xe5yE/regexcite/README.Rmd'\n\nPuede ver el README.md renderizado simplemente visitando regexcite en GitHub.\nFinalmente, no olvides hacer una última confirmación. Y realiza un push, si estás usando GitHub.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#el-último-check-e-install",
    "href": "whole-game.html#el-último-check-e-install",
    "title": "1  Todo el juego",
    "section": "\n1.19 El último: check() e install()\n",
    "text": "1.19 El último: check() e install()\n\nEjecutemos check() nuevamente para asegurarnos de que todo esté bien.\n\ncheck()\n\n\n── R CMD check results ─────────────────── regexcite 0.0.0.9000 ────\nDuration: 8.1s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nregexcite No debe tener errores, advertencias o notas. Este sería un buen momento para reconstruirlo e instalarlo correctamente. ¡Y celebra!\n\ninstall()\n\n\n── R CMD build ─────────────────────────────────────────────────────\n* checking for file ‘/tmp/Rtmp3Xe5yE/regexcite/DESCRIPTION’ ... OK\n* preparing ‘regexcite’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nRemoved empty directory ‘regexcite/tests/testthat/_snaps’\n* building ‘regexcite_0.0.0.9000.tar.gz’\nRunning /opt/R/4.4.0/lib/R/bin/R CMD INSTALL \\\n  /tmp/Rtmp3Xe5yE/regexcite_0.0.0.9000.tar.gz --install-tests \n* installing to library ‘/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu’\n* installing *source* package ‘regexcite’ ...\n** using staged installation\n** R\n** tests\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (regexcite)\n\nNo dude en visitar el paquete regexcite en GitHub, que aparece exactamente como se desarrolló aquí. El historial de commits refleja cada paso individual, así que utilice las diferencias para ver la adición y modificación de archivos a medida que evoluciona el paquete. El resto de este libro detalla cada paso que has visto aquí y mucho más.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#revisión",
    "href": "whole-game.html#revisión",
    "title": "1  Todo el juego",
    "section": "\n1.20 Revisión",
    "text": "1.20 Revisión\nEste capítulo está destinado a darle una idea del flujo de trabajo típico de desarrollo de paquetes, resumido como un diagrama en Figura 1.1. Todo lo que ve aquí se ha abordado en este capítulo, con la excepción de las Acciones de GitHub, sobre las cuales aprenderá más en Sección 20.2.1.\n\n\n\n\n\n\n\nFigura 1.1: El flujo de trabajo de desarrollo del paquete devtools.\n\n\n\n\nAquí hay una revisión de las funciones clave que ha visto en este capítulo, organizadas aproximadamente por su papel en el proceso de desarrollo.\nEstas funciones configuran partes del paquete y normalmente se llaman una vez por paquete:\n\ncreate_package()\nuse_git()\nuse_mit_license()\nuse_testthat()\nuse_github()\nuse_readme_rmd()\n\nLlamará a estas funciones de forma regular, a medida que agregue funciones y pruebas o asuma dependencias:\n\nuse_r()\nuse_test()\nuse_package()\n\nLlamará a estas funciones varias veces por día o por hora, durante el desarrollo:\n\nload_all()\ndocument()\ntest()\ncheck()",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "whole-game.html#footnotes",
    "href": "whole-game.html#footnotes",
    "title": "1  Todo el juego",
    "section": "",
    "text": "Recuerde que este ejemplo fue tan inspirador que ahora es una función real en el paquete stringr: `stringr::str_split_1()`!↩︎",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Todo el juego</span>"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "2  Configuración del sistema",
    "section": "",
    "text": "2.1 Prepare su sistema\nPara comenzar, asegúrese de tener la última versión de R (al menos 4.4.0, que es la versión que se utiliza para generar este libro), luego ejecute el siguiente código para obtener los paquetes que necesitará:\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))\nAsegúrese de tener una versión reciente del entorno de desarrollo integrado (IDE) de RStudio. Se lanzan nuevas versiones periódicamente, por lo que recomendamos actualizarlas con frecuencia para obtener acceso a las funciones más recientes y mejores.\nDescargue la versión actual de RStudio Desktop aquí: https://posit.co/download/rstudio-desktop/. La mayoría de los lectores pueden utilizar la versión gratuita y de código abierto de RStudio Desktop.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuración del sistema</span>"
    ]
  },
  {
    "objectID": "setup.html#sec-setup-usage",
    "href": "setup.html#sec-setup-usage",
    "title": "2  Configuración del sistema",
    "section": "\n2.2 devtools, usethis, y usted",
    "text": "2.2 devtools, usethis, y usted\n\n“Soy grande, contengo multitudes.”\n— Walt Whitman, Song of Myself\n\nComo se menciona en Sección 1, devtools es un ‘metapaquete’ que abarca y expone la funcionalidad mantenida en varios paquetes más pequeños1. Por ejemplo, devtools podría proporcionar una función contenedora para establecer valores predeterminados fáciles de usar, introducir un comportamiento interactivo útil o combinar funcionalidades de múltiples subpaquetes. En algunos casos, simplemente reexporta una función de otro paquete para que esté fácilmente disponible cuando se adjunta devtools.\n¿Cuál es nuestro enfoque recomendado para usar devtools y sus paquetes constituyentes? Varía, dependiendo de tu intención:\n\nSi está utilizando las funciones de forma interactiva para ayudarle a desarrollar su paquete, debe pensar en devtools como el proveedor de sus funciones favoritas para el desarrollo de paquetes. En este caso, debe adjuntar devtools con library(devtools) y llamar a las funciones sin calificación (por ejemplo, load_all()).\nSi está utilizando funciones de devtools y amigos dentro del código del paquete que está escribiendo, NO debe depender de devtools, sino que debe acceder a las funciones a través del paquete que es su hogar principal.\n\ndevtools rara vez debería aparecer en el rol de pkg en una llamada calificada del formato pkg::fcn(). En cambio, pkg debería ser el paquete donde se define fcn(). Por ejemplo, si está creando una función en su paquete en la que necesita consultar el estado de la sesión R del usuario, use sessioninfo::session_info() en su paquete en lugar de devtools::session_info().\n\n\nSi encuentra errores, intente informarlos en el paquete que es el hogar principal de una función. La ayuda para devtools::fcn() generalmente indica cuándo devtools está reexportando una función de otro paquete.\n\nEl paquete usethis es el único paquete constituyente que más personas pueden conocer y que pueden utilizar directamente. Contiene las funciones que actúan sobre los archivos y carpetas de un proyecto de R, especialmente para cualquier proyecto que también sea un paquete de R. devtools facilita el acceso a las funciones usethis de forma interactiva, ya que cuando llama a library(devtools), usethis también se adjunta. Luego puede usar cualquier función en usethis sin calificación, por ejemplo, simplemente llame a use_testthat(). Si elige especificar el espacio de nombres, como cuando trabaja con un estilo más programático, asegúrese de calificar la llamada con usethis, por ejemplo, usethis::use_testthat().\n\n2.2.1 Configuración de inicio personal\nPuede adjuntar herramientas de desarrollo así:\n\nlibrary(devtools)\n\nPero pronto se vuelve irritante adjuntar repetidamente devtools en cada sesión de R. Por lo tanto, recomendamos encarecidamente adjuntar2 devtools en su archivo de inicio .Rprofile, así:\n\nif (interactive()) {\n  suppressMessages(require(devtools))\n}\n\nPara mayor comodidad, la función use_devtools() crea .Rprofile, si es necesario, lo abre para editarlo y coloca las líneas de código necesarias en el portapapeles y en la pantalla.\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn general, es una mala idea adjuntar paquetes en .Rprofile, ya que te invita a crear scripts R que no reflejan todas sus dependencias mediante llamadas explícitas a library(foo). Pero devtools es un paquete de flujo de trabajo que simplifica el proceso de desarrollo de paquetes y, por lo tanto, es poco probable que se incluya en algún script de análisis. Tenga en cuenta que todavía nos preocupamos de adjuntar únicamente en sesiones interactivas.\n\n\nusethis consulta ciertas opciones al, por ejemplo, crear paquetes R de novo. Esto le permite especificar valores predeterminados personales para usted como mantenedor de paquetes o para su licencia preferida. A continuación se muestra un ejemplo de un fragmento de código que podría incluirse .Rprofile:\n\noptions(\n  \"Authors@R\" = utils::person(\n    \"Jane\", \"Doe\",\n    email = \"jane@example.com\",\n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"0000-1111-2222-3333\")\n  ),\n  License = \"MIT + file LICENSE\"\n)\n\nEl siguiente código muestra cómo instalar las versiones de desarrollo de devtools y utilizarlas. En ocasiones, este libro puede describir nuevas funciones que se encuentran en la versión de desarrollo de devtools y paquetes relacionados, pero que aún no se han publicado.\n\ndevtools::install_github(\"r-lib/devtools\")\ndevtools::install_github(\"r-lib/usethis\")\n\n# or, alternatively\npak::pak(\"r-lib/devtools\")\npak::pak(\"r-lib/usethis\")",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuración del sistema</span>"
    ]
  },
  {
    "objectID": "setup.html#sec-setup-tools",
    "href": "setup.html#sec-setup-tools",
    "title": "2  Configuración del sistema",
    "section": "\n2.3 Cadena de herramientas de construcción de R",
    "text": "2.3 Cadena de herramientas de construcción de R\nPara ser totalmente capaz de crear paquetes R desde el código fuente, también necesitará un compilador y algunas otras herramientas de línea de comandos. Es posible que esto no sea estrictamente necesario hasta que desee crear paquetes que contengan código C o C++. Especialmente si estás usando RStudio, puedes dejar esto a un lado por ahora. El IDE le alertará y le brindará soporte una vez que intente hacer algo que requiera que configure su entorno de desarrollo. Siga leyendo para obtener consejos sobre cómo hacerlo usted mismo.\n\n2.3.1 Windows\nEn Windows, la colección de herramientas necesarias para crear paquetes desde el código fuente se llama Rtools.\nRtools NO es un paquete R. NO se instala con install.packages(). En su lugar, descárguelo desde https://cran.r-project.org/bin/windows/Rtools/ y ejecute el instalador.\nDurante la instalación de Rtools, es posible que vea una ventana que le pide que “Seleccione tareas adicionales”.\n\n\nNo seleccione la casilla “Edit the system PATH”. devtools y RStudio deberían colocar Rtools en el PATH automáticamente cuando sea necesario.\nSeleccione la casilla “Save version information to registry”. Debe estar seleccionado de forma predeterminada.\n\n2.3.2 macOS\nDebe instalar las herramientas de línea de comandos de Xcode, lo que requiere que se registre como desarrollador de Apple. No se preocupe, esto es gratuito para una persona que sólo desea instalar aplicaciones, como las herramientas de línea de comandos de Xcode. La inscripción en el programa de desarrollador pago solo es necesaria para aquellos que desean distribuir aplicaciones, acceder a software beta e integrarse con capacidades como Siri, Apple Pay e iCloud.\nLuego, en el shell, haz:\nxcode-select --install\nAlternativamente, puede instalar la versión actual completa de Xcode desde Mac App Store. Esto incluye muchas cosas que no necesita, pero ofrece la ventaja de la comodidad de la App Store.\n\n2.3.3 Linux\nAsegúrese de haber instalado no solo R, sino también las herramientas de desarrollo de R. Por ejemplo, en Ubuntu (y Debian) necesitas instalar el paquete r-base-dev con:\nsudo apt install r-base-dev\nEn Fedora y RedHat, las herramientas de desarrollo (llamadas R-core-devel) se instalarán automáticamente cuando instales con R con sudo dnf install R.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuración del sistema</span>"
    ]
  },
  {
    "objectID": "setup.html#verificar-la-preparación-del-sistema",
    "href": "setup.html#verificar-la-preparación-del-sistema",
    "title": "2  Configuración del sistema",
    "section": "\n2.4 Verificar la preparación del sistema",
    "text": "2.4 Verificar la preparación del sistema\nPuede solicitar un “informe de situación de desarrollo (paquete)” con devtools::dev_sitrep():\n\ndevtools::dev_sitrep()\n#&gt; ── R ───────────────────────────────────────────────────────────────────────\n#&gt; • version: 4.1.2\n#&gt; • path: '/Library/Frameworks/R.framework/Versions/4.1/Resources/'\n#&gt; ── RStudio ─────────────────────────────────────────────────────────────────\n#&gt; • version: 2022.2.0.443\n#&gt; ── devtools ────────────────────────────────────────────────────────────────\n#&gt; • version: 2.4.3.9000\n#&gt; • devtools or its dependencies out of date:\n#&gt;   'gitcreds', 'gh'\n#&gt;   Update them with `devtools::update_packages(\"devtools\")`\n#&gt; ── dev package ─────────────────────────────────────────────────────────────\n#&gt; • package: 'rpkgs'\n#&gt; • path: '/Users/jenny/rrr/r-pkgs/'\n#&gt; • rpkgs dependencies out of date:\n#&gt;   'gitcreds', 'generics', 'tidyselect', 'dplyr', 'tidyr', 'broom', 'gh'\n#&gt;  Update them with `devtools::install_dev_deps()`\n\nSi esto revela que ciertas herramientas o paquetes faltan o están desactualizados, le recomendamos que los actualice.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuración del sistema</span>"
    ]
  },
  {
    "objectID": "setup.html#footnotes",
    "href": "setup.html#footnotes",
    "title": "2  Configuración del sistema",
    "section": "",
    "text": "Al momento en el que se escribió este libro, devtools expone la funcionalidad de remotes, pkgbuild, pkgload, rcmdcheck, revdepcheck, sessioninfo, usethis, testthat, y roxygen2↩︎\nEste es uno de los pocos casos en los que recomendamos usar require() en lugar de library(). library() fallará con un error si no puede adjuntar el paquete y, por lo tanto, abortará la ejecución de su .Rprofile. Si require() no puede adjuntar el paquete, emitirá una advertencia pero permitirá que se ejecute el resto de su .Rprofile. Esto se analiza más a fondo en Sección 10.4.↩︎",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Configuración del sistema</span>"
    ]
  },
  {
    "objectID": "structure.html",
    "href": "structure.html",
    "title": "3  Estructura y estado del paquete",
    "section": "",
    "text": "3.1 Estados del paquete\nEste capítulo lo iniciará en el camino hacia el desarrollo de paquetes al convertir el conocimiento implícito que ha obtenido al usar paquetes R en el conocimiento explícito necesario para crearlos y modificarlos. Aprenderá sobre los distintos estados en los que puede encontrarse un paquete y la diferencia entre un paquete y una biblioteca (y por qué debería importarle).\nCuando crea o modifica un paquete, trabaja en su “código fuente” o “archivos fuente”. Interactúa con el paquete en desarrollo en su formato fuente. Este NO es el formato de paquete con el que está más familiarizado con el uso diario. Los flujos de trabajo de desarrollo de paquetes tienen mucho más sentido si comprende los cinco estados en los que puede encontrarse un paquete R:\nYa conoces algunas de las funciones que ponen paquetes en estos estados. Por ejemplo, install.packages() puede mover un paquete desde el estado fuente, empaquetado o binario al estado instalado. devtools::install_github() toma un paquete fuente en GitHub y lo mueve al estado instalado. La función library() carga un paquete instalado en la memoria, haciéndolo disponible para uso inmediato y directo.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-package-states",
    "href": "structure.html#sec-package-states",
    "title": "3  Estructura y estado del paquete",
    "section": "",
    "text": "fuente\nempaquetado\nbinario\ninstalado\nen memoria",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-source-package",
    "href": "structure.html#sec-source-package",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.2 Paquete fuente",
    "text": "3.2 Paquete fuente\nUn paquete fuente es solo un directorio de archivos con una estructura específica. Incluye componentes particulares, como un archivo DESCRIPTION, un directorio R/ que contiene archivos .R, etc. La mayoría de los capítulos restantes de este libro están dedicados a detallar estos componentes.\nSi es nuevo en el desarrollo de paquetes, es posible que nunca haya visto un paquete en formato fuente. Es posible que ni siquiera tengas ningún paquete fuente en tu computadora. La forma más sencilla de ver un paquete en su formato fuente de inmediato es explorar su código en la web.\nMuchos paquetes de R se desarrollan abiertamente en GitHub (o GitLab o similar). El mejor de los casos es que visite la página de inicio de CRAN del paquete, por ejemplo:\n\nforcats: https://cran.r-project.org/package=forcats\n\nreadxl: https://cran.r-project.org/package=readxl\n\n\ny una de sus URL enlaza a un repositorio en un servicio de alojamiento público, por ejemplo:\n\nforcats: https://github.com/tidyverse/forcats\n\nreadxl: https://github.com/tidyverse/readxl\n\n\nAlgunos mantenedores olvidan incluir esta URL, aunque el paquete se desarrolle en un repositorio público, pero aún así es posible que puedas descubrirlo mediante la búsqueda.\nIncluso si un paquete no está desarrollado en una plataforma pública, puede visitar su fuente en el Espejo no oficial de solo lectura mantenido por R-hub. Ejemplos:\n\nMASS: https://github.com/cran/MASS\n\ncar: https://github.com/cran/car\n\n\nTenga en cuenta que explorar la fuente y el historial de un paquete dentro de la organización GitHub cran no es lo mismo que explorar el verdadero lugar de desarrollo del paquete, porque esta fuente y su evolución simplemente son ingeniería inversa de las versiones CRAN del paquete. Esto presenta una vista redactada del paquete y su historia, pero, por definición, incluye todo lo que es esencial.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-bundled-package",
    "href": "structure.html#sec-bundled-package",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.3 Paquete empaquetado",
    "text": "3.3 Paquete empaquetado\nUn paquete empaquetado es un paquete que se ha comprimido en un solo archivo. Por convención (de Linux), los paquetes de paquetes en R usan la extensión .tar.gz y, a veces, se denominan “tarballs de origen”. Esto significa que varios archivos se han reducido a un solo archivo (.tar) y luego se han comprimido usando gzip (.gz). Si bien un paquete empaquetado no es tan útil por sí solo, es un intermediario independiente de la plataforma y fácil de transportar entre un paquete fuente y un paquete instalado.\nEn el raro caso de que necesites crear un paquete empaquetado a partir de un paquete que estás desarrollando localmente, usa devtools::build(). En el fondo, esto llama a pkgbuild::build() y, en última instancia, a R CMD build, que se describe con más detalle en la sección Creación de paquetes empaquetados de Escribir extensiones de R.\nEsto debería indicarle que un paquete de paquetes o “tarball fuente” no es simplemente el resultado de crear un archivo tar de los archivos fuente y luego comprimirlos con gzip. Por convención, en el mundo R, se llevan a cabo algunas operaciones más al crear el archivo .tar.gz y es por eso que hemos elegido referirnos a esta forma como un paquete empaquetado, en este libro.\nCada paquete CRAN está disponible en forma de empaquetada, a través del campo “Fuente del paquete” de su página de inicio. Continuando con nuestros ejemplos anteriores, puede descargar los empaquetados forcats_0.4.0.tar.gz y readxl_1.3.1.tar.gz (o cualesquiera que sean las versiones actuales). Podrías descomprimir dicho empaquetado en el shell (no en la consola R) de esta manera:\ntar xvf forcats_0.4.0.tar.gz\nSi descomprimes un empaquetado, verás que se ve casi igual que un paquete fuente. Figura 3.1 muestra los archivos presentes en las formas fuente, empaquetada y binaria de un paquete ficticio llamado zzzpackage. Hemos elaborado deliberadamente este ejemplo para incluir la mayoría de las partes del paquete que se tratan en este libro. No todos los paquetes incluirán todos los archivos que se ven aquí, ni este diagrama incluye todos los archivos posibles que puedan aparecer en un paquete.\n\n\n\n\n\n\n\nFigura 3.1: Formas de paquete: fuente versus empaquetado versus binario.\n\n\n\n\nLas principales diferencias entre un paquete fuente y un paquete sin comprimir son:\n\nSe han creado viñetas, por lo que los resultados renderizados, como HTML, aparecen debajo de inst/doc/ y aparece un índice de viñetas en el directorio build/.\nUn paquete fuente local puede contener archivos temporales utilizados para ahorrar tiempo durante el desarrollo, como artefactos de compilación en src/. Estos nunca se encuentran en un empaquetado.\nTodos los archivos enumerados en .Rbuildignore no están incluidos en el empaquetado. Suelen ser archivos que facilitan el proceso de desarrollo, pero que deben excluirse del producto distribuido.\n\n\n3.3.1 .Rbuildignore\n\nNo necesitará contemplar la estructura exacta de los archivos del paquete .tar.gz con mucha frecuencia, pero sí necesitará comprender el archivo .Rbuildignore. Controla qué archivos del paquete fuente llegan a las formas posteriores.\nCada línea de .Rbuildignore es una expresión regular compatible con Perl que coincide, sin importar mayúsculas y minúsculas, con la ruta a cada archivo en el paquete fuente1. Si la expresión regular coincide, ese archivo o directorio se excluye. Tenga en cuenta que existen algunas exclusiones predeterminadas implementadas por el propio R, en su mayoría relacionadas con editores y sistemas de control de versiones clásicos, como SVN, Git y Emacs.\nGeneralmente modificamos .Rbuildignore con la función usethis::use_build_ignore(), que se encarga de detalles fáciles de olvidar, como el anclaje y el escape de expresiones regulares. Para excluir un archivo o directorio específico (el caso de uso más común), DEBE anclar la expresión regular. Por ejemplo, para excluir un directorio llamado “notas”, la entrada .Rbuildignore debe ser ^notas$, mientras que la expresión regular no anclada notas coincidirá con cualquier nombre de archivo que contenga “notas”, p. R/notas.R, man/important-notas.R, data/notasfinales.Rdata, etc. Descubrimos que use_build_ignore() nos ayuda a obtener más entradas de .Rbuildignore correctamente la primera vez.\n.Rbuildignore es una forma de resolver parte de la tensión entre las prácticas que respaldan su proceso de desarrollo y los requisitos de CRAN para el envío y la distribución (Capítulo 22). Incluso si no planea publicar en CRAN, seguir estas convenciones le permitirá hacer el mejor uso de las herramientas integradas de R para la verificación e instalación de paquetes. Los archivos que debe .Rbuildignore se dividen en dos clases amplias y semisuperpuestas:\n\nArchivos que le ayudan a generar contenidos de paquetes mediante programación. Ejemplos:\n\nUsando README.Rmd para generar un archivo informativo y actual README.md (Sección 18.1).\nAlmacenamiento de scripts .R para crear y actualizar datos internos o exportados (Sección 7.1.1).\n\n\nArchivos que impulsan el desarrollo, la verificación y la documentación de paquetes, fuera del ámbito de CRAN. Ejemplos:\n\nArchivos relacionados con el IDE de RStudio (Sección 4.2).\nUsar el paquete pkgdown para generar un sitio web (Capítulo 19).\nArchivos de configuración relacionados con la integración/implementación continua (Sección 20.2).\n\n\n\nAquí hay una lista no exhaustiva de entradas típicas en el archivo .Rbuildignore para un paquete en tidyverse.:\n^.*\\.Rproj$         # Designa el directorio como un proyecto RStudio\n^\\.Rproj\\.user$     # Utilizado por RStudio para archivos temporales\n^README\\.Rmd$       # Un archivo Rmd utilizado para generar README.md\n^LICENSE\\.md$       # Texto completo de la licencia.\n^cran-comments\\.md$ # Comentarios para el envío de CRAN\n^data-raw$          # Código utilizado para crear datos incluidos en el paquete.\n^pkgdown$           # Recursos utilizados para el sitio web del paquete.\n^_pkgdown\\.yml$     # Información de configuración para el sitio web del paquete.\n^\\.github$          # Flujos de trabajo de acciones de GitHub\nTenga en cuenta que los comentarios anteriores no deben aparecer en un archivo .Rbuildignore real; se incluyen aquí sólo para exposición.\nMencionaremos cuándo necesita agregar archivos a .Rbuildignore siempre que sea importante. Recuerde que usethis::use_build_ignore() es una forma atractiva de administrar este archivo. Además, muchas funciones de usethis que agregan un archivo que debería aparecer en .Rbuildignore se encargan de esto automáticamente. Por ejemplo, use_readme_rmd() añade “^README\\.Rmd$” a .Rbuildignore.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-structure-binary",
    "href": "structure.html#sec-structure-binary",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.4 Paquete binario",
    "text": "3.4 Paquete binario\nSi desea distribuir su paquete a un usuario de R que no tiene herramientas de desarrollo de paquetes, deberá proporcionar un paquete binario. El principal fabricante y distribuidor de paquetes binarios es CRAN, no los mantenedores individuales. Pero incluso si delega la responsabilidad de distribuir su paquete a CRAN, sigue siendo importante que el mantenedor comprenda la naturaleza de un paquete binario.\nAl igual que un paquete empaquetado, un paquete binario es un único archivo. A diferencia de un paquete empaquetado, un paquete binario es específico de la plataforma y hay dos versiones básicas: Windows y macOS. (Los usuarios de Linux generalmente deben tener las herramientas necesarias para instalar desde archivos .tar.gz, aunque la aparición de recursos como Posit Public Package Manager está brindando a los usuarios de Linux el mismo acceso a paquetes binarios que sus colegas en Windows y macOS).\nLos paquetes binarios para macOS se almacenan como .tgz, mientras que los paquetes binarios de Windows terminan en .zip. Si necesita crear un paquete binario, utilice devtools::build(binary = TRUE) en el sistema operativo correspondiente. En el fondo, esto llama a pkgbuild::build(binary = TRUE) y, en última instancia, a R CMD INSTALL --build, que se describe con más detalle en Creación de paquetes binarios sección de [Escribir extensiones de R] (https://cran.r-project.org/doc/manuals/R-exts.html) . Si elige publicar su paquete en CRAN (Capítulo 22), envía su paquete en forma de paquete, luego CRAN crea y distribuye los archivos binarios del paquete.\nLos paquetes CRAN suelen estar disponibles en formato binario, tanto para macOS como para Windows, para las versiones actual, anterior y (posiblemente) de desarrollo de R. Continuando con nuestros ejemplos anteriores, puede descargar paquetes binarios como:\n\nforcats para macOS: forcats_0.4.0.tgz\n\nreadxl para Windows: readxl_1.3.1.zip\n\n\ny esto es, de hecho, parte de lo que normalmente sucede detrás de escena cuando llamas install.packages().\nSi descomprime un paquete binario, verá que la estructura interna es bastante diferente de la de un paquete fuente o empaquetado. Figura 3.1 incluye esta comparación, por lo que es un buen momento para revisar ese diagrama. Estas son algunas de las diferencias más notables:\n\nNo hay archivos .R en el directorio R/; en su lugar, hay tres archivos que almacenan las funciones analizadas en un formato de archivo eficiente. Este es básicamente el resultado de cargar todo el código R y luego guardar las funciones con save(). (En el proceso, esto agrega algunos metadatos adicionales para hacer las cosas lo más rápido posible).\nUn directorio Meta/ contiene varios archivos .rds. Estos archivos contienen metadatos almacenados en caché sobre el paquete, como los temas que cubren los archivos de ayuda y una versión analizada del archivo DESCRIPTION. (Puede usar readRDS() para ver exactamente qué hay en esos archivos). Estos archivos aceleran la carga de paquetes al almacenar en caché cálculos costosos.\nEl contenido de la ayuda real aparece en help/ y html/ (ya no en man/).\nSi tenía algún código en el directorio src/, ahora habrá un directorio libs/ que contiene los resultados de la compilación del código.\nSi tenía algún objeto en data/, ahora se ha convertido a una forma más eficiente.\nEl contenido de inst/ se mueve al directorio de nivel superior. Por ejemplo, los archivos de viñeta ahora están en doc/.\nAlgunos archivos y carpetas se han eliminado, como README.md, build/, tests/, y vignettes/.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-installed-package",
    "href": "structure.html#sec-installed-package",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.5 Paquete instalado",
    "text": "3.5 Paquete instalado\nUn paquete instalado es un paquete binario que se ha descomprimido en una biblioteca de paquetes (descrita en Sección 3.7). Figura 3.2 ilustra las muchas formas en que se puede instalar un paquete, junto con algunas otras funciones para convertir un paquete de un estado a otro. ¡Este diagrama es complicado! En un mundo ideal, instalar un paquete implicaría encadenar un conjunto de pasos simples: fuente -&gt; empaquetado, empaquetado -&gt; binario, binario -&gt; instalado. En el mundo real, no es tan simple porque a menudo hay atajos (más rápidos) disponibles.\n\n\n\n\n\n\n\nFigura 3.2: Muchos métodos para convertir entre estados de paquetes.\n\n\n\n\nLa herramienta de línea de comando incorporada R CMD INSTALL impulsa la instalación de todos los paquetes. Puede instalar un paquete a partir de archivos fuente, un paquete (también conocido como tarball fuente) o un paquete binario. Los detalles están disponibles en la sección Instalación de paquetes de Instalación y administración de R. Al igual que con devtools::build(), devtools proporciona una función contenedora, devtools::install(), que hace que esta herramienta esté disponible desde una sesión de R.\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio también puede ayudarle a instalar su paquete en desarrollo a través de los menús desplegables Install y More en el panel Build y con Install Package en el menú Build.\n\n\nEs comprensible que a la mayoría de los usuarios les guste instalar paquetes desde la comodidad de una sesión de R y directamente desde CRAN. La función incorporada install.packages() satisface esta necesidad. Puede descargar el paquete, en varias formas, instalarlo y, opcionalmente, atender la instalación de dependencias.\nSin embargo, la conveniencia de instalar paquetes R desde una sesión R tiene un precio. Como es de esperar, puede resultar un poco complicado reinstalar un paquete que ya está en uso en la sesión actual. En realidad, esto funciona la mayor parte del tiempo, pero a veces no, especialmente cuando se instala un paquete R con código compilado en Windows. Debido a la forma en que los identificadores de archivos están bloqueados en Windows, un intento de instalar una nueva versión de un paquete que está en uso puede resultar en una instalación corrupta donde el código R del paquete se actualizó, pero su código compilado no. Al solucionar problemas, los usuarios de Windows deben esforzarse por instalar los paquetes en una sesión R limpia, con la menor cantidad de paquetes cargados posible.\nEl paquete pak (https://pak.r-lib.org/) es relativamente nuevo (en el momento de escribir este capítulo) y proporciona una alternativa prometedora a install.packages(), así como a otras funciones más especializadas como devtools::install_github(). Es demasiado pronto para hacer una recomendación general sobre el uso de pak para todas sus necesidades de instalación de paquetes, pero ciertamente lo estamos usando cada vez más en nuestros flujos de trabajo personales. Una de las características emblemáticas de pak es que resuelve muy bien el problema de la “DLL bloqueada” descrito anteriormente, es decir, actualizar un paquete con código compilado en Windows. A medida que profundice en el desarrollo de paquetes, se encontrará realizando un conjunto completamente nuevo de tareas, como instalar una dependencia desde una rama en desarrollo o examinar los árboles de dependencia de paquetes. pak proporciona un completo conjunto de herramientas para esta y muchas otras tareas relacionadas. Predecimos que pak pronto se convertirá en nuestra recomendación oficial sobre cómo instalar paquetes (y más).\nSin embargo, mientras tanto, describimos el status quo. devtools ha ofrecido durante mucho tiempo una familia de funciones install_*() para abordar algunas necesidades más allá del alcance de install.packages() o para facilitar el acceso a las capacidades existentes. En realidad, estas funciones se mantienen en el [paquete de controles remotos] (https://remotes.r-lib.org) y devtools las reexporta. (Teniendo en cuenta lo que dijimos anteriormente, es probable que los controles remotos sean esencialmente reemplazados a favor del pak, pero aún no hemos llegado a ese punto).\n\nlibrary(remotes)\n\nfuns &lt;- as.character(lsf.str(\"package:remotes\"))\ngrep(\"^install_.+\", funs, value = TRUE)\n#&gt;  [1] \"install_bioc\"      \"install_bitbucket\" \"install_cran\"     \n#&gt;  [4] \"install_deps\"      \"install_dev\"       \"install_git\"      \n#&gt;  [7] \"install_github\"    \"install_gitlab\"    \"install_local\"    \n#&gt; [10] \"install_remote\"    \"install_svn\"       \"install_url\"      \n#&gt; [13] \"install_version\"\n\ninstall_github() es la más útil de estas funciones y también aparece en Figura 3.2. Es el ejemplo emblemático de una familia de funciones que pueden descargar un paquete desde una ubicación remota que no sea CRAN y hacer lo que sea necesario para instalarlo y sus dependencias. El resto de las funciones de devtools/remotes install_*() están destinadas a hacer que las cosas que son técnicamente posibles con herramientas básicas sean un poco más fáciles o explícitas, como install_version() que instala una versión específica de un paquete CRAN.\nDe manera análoga a .Rbuildignore, descrito en la sección Sección 3.3.1, .Rinstignore le permite mantener los archivos presentes en un paquete fuera del paquete instalado. Sin embargo, a diferencia de .Rbuildignore, esto es bastante oscuro y rara vez es necesario.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#paquete-en-memoria",
    "href": "structure.html#paquete-en-memoria",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.6 Paquete en memoria",
    "text": "3.6 Paquete en memoria\nFinalmente llegamos a un comando familiar para todos los que usan R:\n\nlibrary(usethis)\n\nSuponiendo que usethis esté instalado, esta llamada hace que sus funciones estén disponibles para su uso, es decir, ahora podemos hacer:\n\ncreate_package(\"/path/to/my/coolpackage\")\n\nEl paquete usethis se ha cargado en la memoria y, de hecho, también se ha adjuntado a la ruta de búsqueda. La distinción entre cargar y adjuntar paquetes no es importante cuando escribes scripts, pero es muy importante cuando escribes paquetes. Aprenderá más sobre la diferencia y por qué es importante en Sección 10.4.\nlibrary() no es una buena manera de modificar y probar iterativamente un paquete que está desarrollando, porque solo funciona para un paquete instalado. En Sección 4.4, aprenderá cómo devtools::load_all() acelera el desarrollo al permitirle cargar un paquete fuente directamente en la memoria.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#sec-library",
    "href": "structure.html#sec-library",
    "title": "3  Estructura y estado del paquete",
    "section": "\n3.7 Bibliotecas de paquetes",
    "text": "3.7 Bibliotecas de paquetes\nAcabamos de hablar de la función library(), cuyo nombre está inspirado en lo que hace. Cuando llamas a library(algúnpaquete), R busca en las bibliotecas actuales un paquete instalado llamado “algún paquete” y, si tiene éxito, hace que algún paquete esté disponible para su uso.\nEn R, una biblioteca es un directorio que contiene paquetes instalados, algo así como una biblioteca de libros. Desafortunadamente, en el mundo R, frecuentemente encontrará un uso confuso de las palabras “biblioteca” y “paquete”. Es común que alguien se refiera a dplyr, por ejemplo, como una biblioteca cuando en realidad es un paquete. Hay algunas razones para la confusión. Primero, podría decirse que la terminología de R va en contra de convenciones de programación más amplias, donde el significado habitual de “biblioteca” se acerca más a lo que queremos decir con “paquete”. El nombre de la función library() probablemente refuerza las asociaciones incorrectas. Finalmente, este error de vocabulario suele ser inofensivo, por lo que es fácil que los usuarios de R caigan en el hábito equivocado y que las personas que señalan este error parezcan pedantes insoportables. Pero aquí está la conclusión:\n\nNosotros usamos la función library() para cargar 2 un paquete.\n\nLa distinción entre los dos es importante y útil a medida que participa en el desarrollo de paquetes.\nPuede tener varias bibliotecas en su computadora. De hecho, muchos de ustedes ya lo hacen, especialmente si están en Windows. Puede usar .libPaths() para ver qué bibliotecas están actualmente activas. Así es como podría verse esto en Windows:\n\n# en Windows\n.libPaths()\n#&gt; [1] \"C:/Users/jenny/AppData/Local/R/win-library/4.2\"\n#&gt; [2] \"C:/Program Files/R/R-4.2.2/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#&gt; [[1]]\n#&gt;   [1] \"abc\"           \"anytime\"       \"askpass\"       \"assertthat\"   \n#&gt;  ...\n#&gt; [145] \"zeallot\"      \n#&gt; \n#&gt; [[2]]\n#&gt;  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#&gt;  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#&gt;  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#&gt; [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#&gt; [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#&gt; [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#&gt; [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#&gt; [29] \"translations\" \"utils\"\n\nAquí hay un aspecto similar en macOS (pero los resultados pueden variar):\n\n# en macOS\n.libPaths()\n#&gt; [1] \"/Users/jenny/Library/R/arm64/4.2/library\"\n#&gt; [2] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\"\n\nlapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)\n#&gt; [[1]]\n#&gt;    [1] \"abc\"                  \"abc.data\"             \"abind\"                \n#&gt;  ...\n#&gt; [1033] \"Zelig\"                \"zip\"                  \"zoo\"                 \n#&gt; \n#&gt; [[2]]\n#&gt;  [1] \"base\"         \"boot\"         \"class\"        \"cluster\"     \n#&gt;  [5] \"codetools\"    \"compiler\"     \"datasets\"     \"foreign\"     \n#&gt;  [9] \"graphics\"     \"grDevices\"    \"grid\"         \"KernSmooth\"  \n#&gt; [13] \"lattice\"      \"MASS\"         \"Matrix\"       \"methods\"     \n#&gt; [17] \"mgcv\"         \"nlme\"         \"nnet\"         \"parallel\"    \n#&gt; [21] \"rpart\"        \"spatial\"      \"splines\"      \"stats\"       \n#&gt; [25] \"stats4\"       \"survival\"     \"tcltk\"        \"tools\"       \n#&gt; [29] \"translations\" \"utils\"\n\nEn ambos casos vemos dos bibliotecas activas, consultadas en este orden:\n\nUna biblioteca de usuario\nUna biblioteca global o a nivel de sistema\n\nEsta configuración es típica en Windows, pero normalmente es necesario habilitarla en macOS y Linux3. Con esta configuración, los paquetes complementarios instalados desde CRAN (o desde otro lugar) o en desarrollo local se mantienen en la biblioteca del usuario. Arriba, el sistema macOS se usa como máquina de desarrollo principal y tiene muchos paquetes aquí (~1000), mientras que el sistema Windows solo se usa ocasionalmente y es mucho más espartano. El conjunto principal de paquetes básicos y recomendados que se incluyen con R se encuentran en la biblioteca a nivel de sistema y son los mismos en todos los sistemas operativos. Esta separación atrae a muchos desarrolladores y facilita, por ejemplo, limpiar los paquetes complementarios sin alterar la instalación básica de R.\nSi estás en macOS o Linux y solo ves una biblioteca, no hay necesidad urgente de cambiar nada. Pero la próxima vez que actualice R, considere crear una biblioteca a nivel de usuario. De forma predeterminada, R busca una biblioteca de usuario que se encuentra en la ruta almacenada en la variable de entorno R_LIBS_USER, que por defecto es ~/Library/R/m/x.y/library en macOS y ~/R/m -library/x.y en Linux (donde m es una descripción concisa de la arquitectura de su CPU y x.y es la versión R). Puede ver esta ruta con Sys.getenv(\"R_LIBS_USER\"). Estos directorios no existen de forma predeterminada y su uso debe habilitarse creando el directorio. Cuando instale una nueva versión de R, y antes de instalar cualquier paquete complementario, use dir.create(Sys.getenv(\"R_LIBS_USER\"), recursive = TRUE) para crear una biblioteca de usuario en la ubicación predeterminada. Ahora tendrá la configuración de la biblioteca que se ve arriba. Alternativamente, puede configurar una biblioteca de usuario en otro lugar e informarle a R al respecto configurando la variable de entorno R_LIBS_USER en .Renviron. La forma más sencilla de editar su archivo .Renviron es con usethis::edit_r_environ(), que creará el archivo si no existe y lo abrirá para editarlo.\nLas rutas de archivo de estas bibliotecas también dejan en claro que están asociadas con una versión específica de R (4.2.x en el momento de escribir este capítulo), lo cual también es típico. Esto refleja y refuerza el hecho de que necesita reinstalar sus paquetes complementarios cuando actualiza R de, digamos, 4.1 a 4.2, lo cual es un cambio en la versión menor. Por lo general, no es necesario volver a instalar los paquetes complementarios para una versión de parche, por ejemplo, al pasar de R 4.2.1 a 4.2.2.\nA medida que el uso de R se vuelve más sofisticado, es común comenzar a administrar bibliotecas de paquetes con más intención. Por ejemplo, herramientas como renv (y su predecesor packrat) automatizan el proceso de gestión de bibliotecas específicas del proyecto. Esto puede ser importante para hacer que los productos de datos sean reproducibles, portátiles y aislados unos de otros. Un desarrollador de paquetes podría anteponer la ruta de búsqueda de la biblioteca con una biblioteca temporal que contenga un conjunto de paquetes en versiones específicas, para explorar problemas de compatibilidad hacia atrás y hacia adelante, sin afectar el resto del trabajo diario. Las comprobaciones de dependencia inversa son otro ejemplo en el que gestionamos explícitamente la ruta de búsqueda de la biblioteca.\nEstas son las principales palancas que controlan qué bibliotecas están activas, en orden de alcance y persistencia:\n\nVariables de entorno, como R_LIBS y R_LIBS_USER, que se consultan al inicio.\nLlamar a .libPaths() con una o más rutas de archivo.\nEjecutar pequeños fragmentos de código con una ruta de búsqueda de biblioteca temporalmente alterada a través de withr::with_libpaths().\nArgumentos para funciones individuales, como install.packages(lib =) y library(lib.loc =).\n\nFinalmente, es importante tener en cuenta que library() NUNCA debe usarse dentro de un paquete. Los paquetes y scripts se basan en diferentes mecanismos para declarar sus dependencias y este es uno de los ajustes más importantes que debe realizar en su modelo mental y sus hábitos. Exploramos este tema a fondo en Sección 9.6 y Capítulo 11.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "structure.html#footnotes",
    "href": "structure.html#footnotes",
    "title": "3  Estructura y estado del paquete",
    "section": "",
    "text": "Para ver el conjunto de rutas de archivos que deberían estar en su radar, ejecute dir(full.names = TRUE, recursive = TRUE, include.dirs = TRUE, all.files = TRUE) en el directorio de nivel superior del paquete.↩︎\nBueno, en realidad, library() carga y adjunta un paquete, pero ese es un tema para Sección 10.4.↩︎\nPara obtener más detalles, consulte la sección Mantenimiento de R en Lo que olvidaron enseñarte sobre R, Gestión de bibliotecas en Instalación y administración de R y los archivos de ayuda de R para ?Startup y ?.libPaths.↩︎",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructura y estado del paquete</span>"
    ]
  },
  {
    "objectID": "workflow101.html",
    "href": "workflow101.html",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "",
    "text": "4.1 Crear un paquete\nHabiendo echado un vistazo bajo el capó de los paquetes y bibliotecas de R en Capítulo 3, aquí proporcionamos los flujos de trabajo básicos para crear un paquete y moverlo a través de los diferentes estados que surgen durante el desarrollo.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-create-package",
    "href": "workflow101.html#sec-workflow101-create-package",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "",
    "text": "4.1.1 Examinar el paisaje existente\nMuchos paquetes nacen de la frustración de una persona por alguna tarea común que debería ser más fácil. ¿Cómo se debe decidir si algo es digno de ser empaquetado? No hay una respuesta definitiva, pero es útil apreciar al menos dos tipos de recompensa:\n\nProducto: tu vida será mejor cuando esta funcionalidad se implemente formalmente, en un paquete.\nProceso: un mayor dominio de R te hará más eficaz en tu trabajo.\n\nSi lo único que le importa es la existencia de un producto, entonces su objetivo principal es navegar por el espacio de los paquetes existentes. Silge, Nash y Graves organizaron una encuesta y sesiones sobre este tema en useR! 2017 y su artículo para el R Journal (Silge, Nash, y Graves 2018) proporciona un resumen completo de recursos.\nSi está buscando formas de aumentar su dominio de R, aún debe informarse sobre el panorama. Pero hay muchas buenas razones para crear su propio paquete, incluso si existe un trabajo previo relevante. La forma en que los expertos llegaron a ese camino es construyendo cosas, a menudo cosas muy básicas, y usted merece la misma oportunidad de aprender haciendo retoques. Si sólo se le permite trabajar en cosas que nunca se han tocado, es probable que esté enfrentando problemas que son muy oscuros o muy difíciles.\nTambién es válido evaluar la idoneidad de las herramientas existentes en función de la interfaz de usuario, los valores predeterminados y el comportamiento de los casos extremos. Técnicamente, un paquete puede hacer lo que necesita, pero quizás sea muy poco ergonómico para su caso de uso. En este caso, puede tener sentido que usted desarrolle su propia implementación o escriba funciones contenedoras que suavicen los bordes afilados.\nSi su trabajo pertenece a un dominio bien definido, infórmese sobre los paquetes R existentes, incluso si ha decidido crear su propio paquete. ¿Siguen patrones de diseño específicos? ¿Existen estructuras de datos específicas que sean comunes como entrada y salida principal? Por ejemplo, existe una comunidad R muy activa en torno al análisis de datos espaciales (r-spatial.org) que se ha autoorganizado con éxito para promover una mayor coherencia entre paquetes con diferentes mantenedores. En el modelado, el paquete de hardhat proporciona una base para crear un paquete de modelado que funciona bien con el ecosistema tidymodels. Su paquete se utilizará más y necesitará menos documentación si encaja bien en el entorno.\n\n4.1.2 Nombra tu paquete\n\n“Sólo hay dos cosas difíciles en Ciencias de la Computación: invalidación de caché y nombrar cosas.”\n— Phil Karlton\n\nAntes de poder crear su paquete, debe darle un nombre. ¡Esta puede ser la parte más difícil de crear un paquete! (Sobre todo porque nadie puede automatizarlo por usted).\n\n4.1.2.1 Requisitos formales\nHay tres requisitos formales.:\n\nEl nombre sólo puede constar de letras, números y puntos, es decir, “.”.\nDebe comenzar con una letra.\nNo puede terminar con un punto.\n\nDesafortunadamente, esto significa que no puede usar guiones ni guiones bajos, es decir, - o _, en el nombre de su paquete. Recomendamos no utilizar puntos en los nombres de los paquetes, debido a asociaciones confusas con extensiones de archivos y métodos S3.\n\n4.1.2.2 Cosas para considerar\nSi planeas compartir tu paquete con otras personas, es importante encontrar un buen nombre. A continuación se ofrecen algunos consejos:\n\nElija un nombre único que sea fácil de buscar en Google. Esto facilita que los usuarios potenciales encuentren su paquete (y los recursos asociados) y que usted vea quién lo está usando.\n\nNo elija un nombre que ya esté en uso en CRAN o Bioconductor. Es posible que también desees considerar otros tipos de colisión de nombres.:\n\n¿Hay algún paquete en desarrollo que esté madurando en, digamos, GitHub que ya tenga algo de historia y parezca estar encaminado hacia su lanzamiento?\n¿Este nombre ya se utiliza para otra pieza de software o para una biblioteca o marco en, por ejemplo, el ecosistema Python o JavaScript?\n\n\nEvite el uso de letras mayúsculas y minúsculas: hacerlo hace que el nombre del paquete sea difícil de escribir y aún más difícil de recordar. Por ejemplo, es difícil recordar si es Rgtk2, RGTK2 o RGtk2.\nDé preferencia a nombres que sean pronunciables, para que las personas se sientan cómodas hablando de su paquete y tengan una manera de escucharlo dentro de su cabeza.\n\nEncuentre una palabra que evoque el problema y modifíquela para que sea única. Aquí hay unos ejemplos:\n\nlubridate hace el trabajo con fechas y horas más fácil.\nrvest “cosecha” (“harvests”, en inglés) el contenido de las páginas web.\nr2d3 proporciona utilidades para trabajar con visualizaciones D3.\nforcats es un anagrama de factores, que utilizamos para datos categóricos.\n\n\n\nUtilice abreviaturas, como las siguientes:\n\nRcpp = R + C++ (más más)\nbrms = Bayesian Regression Models using Stan (Modelos de regresión bayesiana usando Stan)\n\n\n\nAgregue una R adicional, por ejemplo:\n\nstringr proporciona herramientas de cadenas de caracteres (string en inglés).\nbeepr reproduce sonidos de notificación.\ncallr llama R, desde R.\n\n\n\nNo hagas que te demanden.\n\nSi está creando un paquete que se dirige a un servicio comercial, consulte las pautas de marca. Por ejemplo, rDrop no se llama rDropbox porque Dropbox prohíbe que cualquier aplicación utilice el nombre completo de la marca registrada..\n\n\n\nNick Tierney presenta una tipología divertida de nombres de paquetes en su publicación de blog Naming Things, que también incluye ejemplos más inspiradores. También tiene algo de experiencia cambiando el nombre de paquetes; la publicación Entonces, has decidido cambiar el nombre de tu paquete r es un buen recurso si no lo hace bien la primera vez.\n\n4.1.2.3 Utilice el paquete available\nEs imposible cumplir con todas las sugerencias anteriores simultáneamente, por lo que deberá hacer algunas concesiones. El paquete available tiene una función llamada available() que le ayuda a evaluar el nombre de un paquete potencial desde muchos ángulos:\n\nlibrary(available)\n\navailable(\"doofus\")\n#&gt; Urban Dictionary can contain potentially offensive results,\n#&gt;   should they be included? [Y]es / [N]o:\n#&gt; 1: 1\n#&gt; ── doofus ──────────────────────────────────────────────────────────────────\n#&gt; Name valid: ✔\n#&gt; Available on CRAN: ✔ \n#&gt; Available on Bioconductor: ✔\n#&gt; Available on GitHub:  ✔ \n#&gt; Abbreviations: http://www.abbreviations.com/doofus\n#&gt; Wikipedia: https://en.wikipedia.org/wiki/doofus\n#&gt; Wiktionary: https://en.wiktionary.org/wiki/doofus\n#&gt; Sentiment:???\n\navailable::available() hace lo siguiente:\n\nComprobaciones de validez.\nVerifica la disponibilidad en CRAN, Bioconductor y más.\nBusca en varios sitios web para ayudarle a descubrir significados no deseados. En una sesión interactiva, las URL que ve arriba se abren en las pestañas del navegador.\nIntenta informar si el nombre tiene un sentimiento positivo o negativo..\n\npak::pkg_name_check() es una función alternativa con un propósito similar. Dado que el paquete pak se encuentra en desarrollo más activo que el available, puede surgir como la mejor opción en el futuro.\n\n4.1.3 Creación de paquetes\nUna vez que haya creado un nombre, hay dos formas de crear el paquete..\n\nLlamar usethis::create_package().\nEn RStudio, haz File &gt; New Project &gt; New Directory &gt; R Package. Esto en última instancia llama usethis::create_package(), así que realmente solo hay una manera.\n\nEsto produce el paquete funcional más pequeño posible, con tres componentes:\n\nUn directorio R/, sobre el cual aprenderá en Capítulo 6.\nUn archivo básico DESCRIPTION, sobre el cual aprenderá en Capítulo 9.\nUn archivo NAMESPACE básico, sobre el que aprenderá en Sección 10.2.2.\n\nTambién puede incluir un archivo de proyecto de RStudio, pkgname.Rproj, que hace que su paquete sea fácil de usar con RStudio, como se describe a continuación. Los archivos básicos .Rbuildignore y .gitignore también quedan atrás.\n\n\n\n\n\n\nAdvertencia\n\n\n\nNo utilice package.skeleton() para crear un paquete. Debido a que esta función viene con R, es posible que tenga la tentación de usarla, pero crea un paquete que inmediatamente arroja errores con R CMD build. Anticipa un proceso de desarrollo diferente al que usamos aquí, por lo que reparar este estado inicial roto simplemente hace que el trabajo sea innecesario para las personas que usan devtools (y, especialmente, roxygen2). Use create_package().\n\n\n\n4.1.4 ¿Dónde deberías crear el paquete, create_package()?\nEl argumento principal y único requerido para create_package() es la ruta, path donde vivirá su nuevo paquete:\n\ncreate_package(\"ruta/al/paquete/nombrepqt\")\n\nRecuerde que aquí es donde reside su paquete en su forma fuente (Sección 3.2), no en su forma instalada (Sección 3.5). Los paquetes instalados se encuentran en una biblioteca y analizamos las configuraciones convencionales para bibliotecas en Sección 3.7.\n¿Dónde debería guardar los paquetes fuente? El principio fundamental es que esta ubicación debe ser distinta de donde se encuentran los paquetes instalados. En ausencia de consideraciones externas, un usuario típico debería designar un directorio dentro de su directorio de inicio para los paquetes R (fuente). Discutimos esto con colegas y la fuente de muchos paquetes de tidyverse se encuentra dentro de directorios como ~/rrr/, ~/documents/tidyverse/, ~/r/packages/ o ~/pkg/. Algunos de nosotros usamos un directorio para esto, otros dividen los paquetes fuente entre unos pocos directorios según su función de desarrollo (colaborador o no), organización de GitHub (tidyverse o r-lib), etapa de desarrollo (activa o no), etc.\nLo anterior probablemente refleja que somos principalmente constructores de herramientas. Un investigador académico podría organizar sus archivos en torno a publicaciones individuales, mientras que un científico de datos podría organizarlos en torno a productos e informes de datos. No existe ninguna razón técnica o tradicional particular para un enfoque específico. Siempre que mantenga una distinción clara entre los paquetes fuente e instalados, simplemente elija una estrategia que funcione dentro de su sistema general para la organización de archivos y úsela de manera consistente.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-rstudio-projects",
    "href": "workflow101.html#sec-workflow101-rstudio-projects",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "\n4.2 Proyectos de RStudio",
    "text": "4.2 Proyectos de RStudio\ndevtools trabaja mano a mano con RStudio, que creemos que es el mejor entorno de desarrollo para la mayoría de los usuarios de R. Para ser claros, puedes usar devtools sin usar RStudio y puedes desarrollar paquetes en RStudio sin usar devtools. Pero existe una relación especial bidireccional que hace que sea muy gratificante utilizar devtools y RStudio juntos.\n\n\n\n\n\n\nRStudio\n\n\n\nUn Proyecto de RStudio, con una “P” mayúscula, es un directorio normal en su computadora que incluye alguna infraestructura de RStudio (en su mayoría oculta) para facilitar su trabajo en uno o más proyectos, con una “p” minúscula. “. Un proyecto puede ser un paquete R, un análisis de datos, una aplicación Shiny, un libro, un blog, etc.\n\n\n\n4.2.1 Beneficios de los proyectos de RStudio\nDesde Sección 3.2, ya sabes que un paquete fuente se encuentra en un directorio de tu computadora. Recomendamos encarecidamente que cada paquete fuente sea también un proyecto RStudio. Éstos son algunas de las ventajas:\n\nLos proyectos son muy “lanzables”. Es fácil iniciar una nueva instancia de RStudio en un proyecto, con el explorador de archivos y el directorio de trabajo configurados exactamente de la manera que necesita, listos para trabajar..\n\nCada Proyecto está aislado; El código ejecutado en un proyecto no afecta a ningún otro proyecto.\n\nPuede tener varios proyectos de RStudio abiertos a la vez y el código ejecutado en el proyecto A no tiene ningún efecto en la sesión de R ni en el espacio de trabajo del proyecto B.\n\n\nObtendrá útiles herramientas de navegación de código como F2 para saltar a la definición de una función y Ctrl +. para buscar funciones o archivos por nombre.\n\nObtiene útiles atajos de teclado y una interfaz en la que se puede hacer clic para tareas comunes de desarrollo de paquetes, como generar documentación, ejecutar pruebas o verificar el paquete completo.\n\n\n\n\n\n\n\nFigura 4.1: Referencia rápida de métodos abreviados de teclado en RStudio.\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nPara ver los atajos de teclado más útiles, presione Alt + Shift + K o use Help &gt; Keyboard Shortcuts Help. Deberías ver algo como Figura 4.1.\nRStudio también proporciona la Paleta de comandos que brinda acceso rápido y con capacidad de búsqueda a todos los comandos del IDE – especialmente útil cuando no recuerdas un atajo de teclado en particular. Se invoca mediante Ctrl + Shift + P (Windows & Linux) o Cmd + Shift + P (macOS).\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nSiga @rstudiotips en Twitter para obtener una dosis regular de consejos y trucos de RStudio.\n\n\n\n4.2.2 Cómo conseguir un proyecto RStudio\nSi sigue nuestra recomendación de crear nuevos paquetes con create_package(), cada paquete nuevo también será un proyecto RStudio, si está trabajando desde RStudio.\nSi necesita designar el directorio de un paquete fuente preexistente como un proyecto RStudio, elija una de estas opciones:\n\nEn RStudio, haz File &gt; New Project &gt; Existing Directory.\nLlame a create_package() con la ruta al paquete fuente R preexistente.\nLlame a usethis::use_rstudio(), con el proyecto usethis activo establecido en un paquete R existente. En la práctica, esto probablemente signifique que solo necesita asegurarse de que su directorio de trabajo esté dentro del directorio del paquete preexistente.\n\n4.2.3 ¿Qué caracteriza a un proyecto RStudio?\nUn directorio que sea un proyecto RStudio contendrá un archivo .Rproj. Normalmente, si el directorio se llama “foo”, el archivo del proyecto es foo.Rproj. Y si ese directorio también es un paquete R, entonces el nombre del paquete suele ser también “foo”. El camino de menor resistencia es hacer que todos estos nombres coincidan y NO anidar su paquete dentro de un subdirectorio dentro del Proyecto. Si opta por un flujo de trabajo diferente, sepa que puede sentir que está luchando con las herramientas.\nUn archivo .Rproj es solo un archivo de texto. Aquí hay un archivo de proyecto representativo que puede ver en un proyecto iniciado mediante usethis:\nVersion: 1.0\n\nRestoreWorkspace: No\nSaveWorkspace: No\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nEncoding: UTF-8\n\nAutoAppendNewline: Yes\nStripTrailingWhitespace: Yes\nLineEndingConversion: Posix\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nNo es necesario modificar este archivo manualmente. En su lugar, utilice la interfaz disponible a través de Tools &gt; Project Options (Figura 4.2) o Project Options en el menú Proyectos en la esquina superior derecha (Figura 4.3).\n\n\n\n\n\n\n\nFigura 4.2: Opciones de proyecto en RStudio.\n\n\n\n\n\n\n\n\n\n\n\nFigura 4.3: Menú de proyectos en RStudio.\n\n\n\n\n\n4.2.4 Cómo lanzar un proyecto RStudio\nHaga doble clic en el archivo foo.Rproj en el Finder de macOS o en el Explorador de Windows para iniciar el proyecto foo en RStudio.\nTambién puede iniciar proyectos desde RStudio a través de File &gt; Open Project (in New Session) o el menú Proyectos en la esquina superior derecha.\nSi utiliza una aplicación de productividad o de inicio, probablemente pueda configurarla para que haga algo agradable con los archivos .Rproj. Ambos usamos a Alfred para esto. 1, que es solo macOS, pero existen herramientas similares para Windows. De hecho, esta es una muy buena razón para utilizar una aplicación de productividad en primer lugar.\nEs muy normal – ¡y productivo! – tener varios proyectos abiertos a la vez.\n\n4.2.5 Proyecto RStudio versus uso activo de este proyecto\nNotarás que la mayoría de las funciones de usethis no toman una ruta: operan en los archivos en el “proyecto de usethis activo”. El uso de este paquete supone que el 95% de las veces todos estos coinciden:\n\nEl proyecto RStudio actual, si se utiliza RStudio.\nEl uso activo de este proyecto.\nDirectorio de trabajo actual para el proceso R.\n\nSi las cosas parecen raras, llame a proj_sitrep() para obtener un “informe de situación”. Éste identificará situaciones peculiares y propondrá formas de volver a un estado más feliz.\n\n# Por lo general, estos deberían ser los mismos (o no estar configurados).\nproj_sitrep()\n#&gt; *   directorio de trabajo: '/Users/jenny/rrr/readxl'\n#&gt; * active_usethis_proj: '/Users/jenny/rrr/readxl'\n#&gt; * active_rstudio_proj: '/Users/jenny/rrr/readxl'",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#directorio-de-trabajo-y-disciplina-de-ruta-de-archivo",
    "href": "workflow101.html#directorio-de-trabajo-y-disciplina-de-ruta-de-archivo",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "\n4.3 Directorio de trabajo y disciplina de ruta de archivo",
    "text": "4.3 Directorio de trabajo y disciplina de ruta de archivo\nA medida que desarrolle su paquete, ejecutará código R. Esta será una combinación de llamadas de flujo de trabajo (por ejemplo, document() o test()) y llamadas ad hoc que le ayudarán a escribir sus funciones, ejemplos y pruebas. Recomendamos encarecidamente que mantenga el nivel superior de su paquete fuente como directorio de trabajo de su proceso R. Esto generalmente sucederá de forma predeterminada, por lo que esta es realmente una recomendación para evitar flujos de trabajo de desarrollo que requieran que juegue con el directorio de trabajo.\nSi es totalmente nuevo en el desarrollo de paquetes, no tiene muchas bases para apoyar o resistirse a esta propuesta. Pero aquellos con cierta experiencia pueden encontrar esta recomendación algo molesta. Quizás se pregunte cómo se supone que debe expresar las rutas cuando trabaja en subdirectorios, como tests/. A medida que sea relevante, le mostraremos cómo explotar los asistentes de creación de rutas, como testthat::test_path(), que determinan las rutas en el momento de la ejecución.\nLa idea básica es que al dejar el directorio de trabajo solo, se le recomienda escribir rutas que transmitan la intención explícitamente (“leer foo.csv del directorio de prueba”) en lugar de implícitamente (“leer foo.csv del directorio de trabajo actual , que creo será el directorio de prueba”). Una señal segura de dependencia de rutas implícitas es el jugueteo incesante con su directorio de trabajo, porque está utilizando setwd() para cumplir manualmente las suposiciones que están implícitas en sus rutas.\nEl uso de rutas explícitas puede eliminar toda una clase de dolores de cabeza en las rutas y también hace que el desarrollo diario sea más placentero. Hay dos razones por las que es difícil acertar con los caminos implícitos:\n\nRecuerde las diferentes formas que puede adoptar un paquete durante el ciclo de desarrollo (Capítulo 3). Estos estados difieren entre sí en términos de qué archivos y carpetas existen y sus posiciones relativas dentro de la jerarquía. Es complicado escribir rutas relativas que funcionen en todos los estados del paquete.\nCon el tiempo, usted y potencialmente CRAN procesarán su paquete con herramientas integradas como R CMD build, R CMD check y R CMD INSTALL. Es difícil realizar un seguimiento de cuál será el directorio de trabajo en cada etapa de estos procesos.\n\nLos asistentes de ruta como testthat::test_path(), fs::path_package() y el paquete rprojroot son extremadamente útiles para crear rutas resistentes que resistan en toda la gama de situaciones que surgen durante el desarrollo y el uso. Otra forma de eliminar rutas frágiles es ser riguroso en el uso de métodos adecuados para almacenar datos dentro de su paquete (Capítulo 7) y apuntar al directorio temporal de la sesión cuando sea apropiado, como para artefactos de prueba efímeros. (Capítulo 13).",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-load-all",
    "href": "workflow101.html#sec-workflow101-load-all",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "\n4.4 Prueba de manejo con load_all()\n",
    "text": "4.4 Prueba de manejo con load_all()\n\nLa función load_all() es posiblemente la parte más importante del flujo de trabajo de devtools.\n\n# con devtools adjuntado y\n# el directorio de trabajo configurado en el nivel superior de su paquete fuente ...\n\nload_all()\n\n# ... ahora experimenta con las funciones de tu paquete.\n\nload_all() es el paso clave en este ciclo de desarrollo de paquetes de “hacer espuma, enjuagar y repetir”:\n\nModificar la definición de una función.\nload_all()\nPruebe el cambio ejecutando un pequeño ejemplo o algunas pruebas.\n\nCuando eres nuevo en el desarrollo de paquetes o en devtools, es fácil pasar por alto la importancia de load_all() y caer en algunos hábitos incómodos en un flujo de trabajo de análisis de datos.\n\n4.4.1 Beneficios de load_all()\n\nCuando comienza a utilizar un entorno de desarrollo, como RStudio o VS Code, la mayor ventaja es la capacidad de enviar líneas de código desde un script .R para su ejecución en la consola R. La fluidez de esto es lo que hace que sea tolerable seguir la mejor práctica de considerar el código fuente como real 2 (en lugar de objetos en el espacio de trabajo) y guardar archivos .R (en lugar de guardar y volver a cargar .Rdata).\nload_all() tiene el mismo significado para el desarrollo de paquetes e, irónicamente, requiere que NO pruebe el código del paquete de la misma manera que el código de script. load_all() simula el proceso completo para ver el efecto de un cambio en el código fuente, lo cual es bastante complicado 3 que no querrás hacerlo muy a menudo. Figura 4.4 refuerza que la función library() solo puede cargar un paquete que ha sido instalado, mientras que load_all() ofrece una simulación de alta fidelidad de esto, basada en la fuente del paquete actual.\n\n\n\n\n\n\n\nFigura 4.4: devtools::load_all() vs. library().\n\n\n\n\nLos principales beneficios de load_all() incluyen:\n\nPuede iterar rápidamente, lo que fomenta la exploración y el progreso incremental.\n\nEsta aceleración iterativa es especialmente notable en paquetes con código compilado.\n\n\nPuedes desarrollar de forma interactiva bajo un régimen de espacio de nombres que imita con precisión cómo son las cosas cuando alguien usa tu paquete instalado, con las siguientes ventajas adicionales:\n\nPuede llamar a sus propias funciones internas directamente, sin usar ::: y sin caer en la tentación de definir temporalmente sus funciones en el espacio de trabajo global.\nTambién puede llamar funciones de otros paquetes que haya importado a su NAMESPACE, sin caer en la tentación de adjuntar estas dependencias a través de library().\n\n\n\nload_all() elimina la fricción del flujo de trabajo de desarrollo y elimina la tentación de utilizar soluciones alternativas que a menudo conducen a errores en torno a la gestión de espacios de nombres y dependencias.\n\n4.4.2 Otras formas de llamar load_all()\n\nCuando se trabaja en un proyecto que es un paquete, RStudio ofrece varias formas de llamar load_all():\n\nAtajo de teclado: Cmd+Shift+L (macOS), Ctrl+Shift+L (Windows, Linux)\nPaneles de construcción menú More …\n\nBuild &gt; Load All\n\ndevtools::load_all() es una envoltura delgada alrededor de pkgload::load_all() que agrega un poco de facilidad de uso. Es poco probable que uses load_all() programáticamente o dentro de otro paquete, pero si lo haces, probablemente deberías usar pkgload::load_all() directamente.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#sec-workflow101-r-cmd-check",
    "href": "workflow101.html#sec-workflow101-r-cmd-check",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "\n4.5 check() y R CMD check\n",
    "text": "4.5 check() y R CMD check\n\nBase R proporciona varias herramientas de línea de comandos y “R CMD check” es el método oficial para comprobar que un paquete R es válido. Es esencial pasar la verificación R CMD check si planea enviar su paquete a CRAN, pero recomendamos encarecidamente cumplir con este estándar incluso si no tiene intención de publicar su paquete en CRAN. R CMD check detecta muchos problemas comunes que de otro modo descubrirías por las malas.\nNuestra forma recomendada de ejecutar R CMD check es en la consola R a través de devtools:\n\ndevtools::check()\n\nRecomendamos esto porque le permite ejecutar R CMD check desde R, lo que reduce drásticamente la fricción y aumenta la probabilidad de que check() sea temprano y con frecuencia. Este énfasis en la fluidez y la retroalimentación rápida es exactamente la misma motivación que se da para load_all(). En el caso de check(), realmente está ejecutando R CMD check por usted. No se trata sólo de una simulación de alta fidelidad, como es el caso de load_all().\n\n\n\n\n\n\nRStudio\n\n\n\nRStudio expone check() en el menú Build, en el panel Build a través de Check y en los atajos de teclado Ctrl + Shift + E (Windows & Linux) o Cmd + Shift + E (macOS).\n\n\nUn error de novato que vemos a menudo en los desarrolladores de nuevos paquetes es trabajar demasiado en su paquete antes de ejecutar “R CMD check”. Luego, cuando finalmente lo ejecutan, es típico descubrir muchos problemas, lo que puede resultar muy desmoralizador. Es contrario a la intuición, pero la clave para minimizar este dolor es ejecutar R CMD check con más frecuencia: cuanto antes encuentre un problema, más fácil será solucionarlo.4. Modelamos este comportamiento muy intencionalmente en Capítulo 1.\nEl límite superior de este enfoque es ejecutar R CMD check cada vez que realiza un cambio. No ejecutamos check() manualmente con tanta frecuencia, pero cuando estamos trabajando activamente en un paquete, es típico ejecutar check() varias veces al día. No juegue con su paquete durante días, semanas o meses, esperando algún hito especial para finalmente ejecutar R CMD check. Si usas GitHub (Sección 20.1), Le mostraremos cómo configurar las cosas para que R CMD check se ejecute automáticamente cada vez que realice un push (Sección 20.2.1).\n\n4.5.1 Flujo de trabajo\nEsto es lo que sucede dentro devtools::check():\n\nGarantiza que la documentación esté actualizada ejecutando devtools::document().\nEmpaqueta el paquete antes de revisarlo (Sección 3.3). Esta es la mejor práctica para verificar paquetes porque garantiza que la verificación comience desde cero: porque un paquete de paquetes no contiene ninguno de los archivos temporales que pueden acumularse en su paquete fuente, por ejemplo. artefactos como los archivos .so y .o que acompañan al código compilado, puede evitar las advertencias falsas que generarán dichos archivos.\nEstablece la variable de entorno NOT_CRAN en \"true\". Esto le permite omitir selectivamente pruebas en CRAN. Consulte ?testthat::skip_on_cran y Sección 15.4.1 para obtener más detalles.\n\nEl flujo de trabajo para comprobar un paquete es sencillo, pero tedioso:\n\nEjecute devtools::check(), o presione Ctrl/Cmd + Shift + E.\nArregle el primer problema.\nRepita hasta que no haya más problemas.\n\nR CMD check devuelve tres tipos de mensajes:\n\nERROR (errores): Problemas graves que debes solucionar independientemente de si envías o no a CRAN.\nWARNING (advertencias): Problemas probables que debes solucionar si planeas enviar a CRAN (y es una buena idea investigar incluso si no lo estás haciendo).\nNOTE (notas): Problemas leves o, en algunos casos, simplemente una observación. Si realiza un envío a CRAN, debe esforzarse por eliminar todas las NOTAS, incluso si son falsos positivos. Si no tiene NOTAS, no se requiere intervención humana y el proceso de envío del paquete será más sencillo. Si no es posible eliminar una “NOTA”, deberá describir por qué está bien en los comentarios de envío, como se describe en Sección 22.7. Si no realiza el envío a CRAN, lea atentamente cada NOTA. Si es fácil eliminar las NOTAS, vale la pena, para que puedas seguir esforzándote por conseguir un resultado totalmente limpio. Pero si eliminar una NOTA tendrá un impacto negativo neto en su paquete, es razonable simplemente tolerarlo. Asegúrese de que eso no le lleve a ignorar otras cuestiones que realmente deberían abordarse.\n\nR CMD check consta de docenas de controles individuales y sería abrumador enumerarlos aquí. Consulte nuestra guía solo en línea para verificar `R CMD check para más detalles.\n\n4.5.2 Antecedentes sobre R CMD check\n\nA medida que acumula experiencia en el desarrollo de paquetes, es posible que desee acceder R CMD check directamente en algún momento. Recuerde que R CMD check es algo que debe ejecutar en la terminal, no en la consola R. Puedes ver su documentación así:\nR CMD check --help\nR CMD check se puede ejecutar en un directorio que contiene un paquete R en formato fuente (Sección 3.2) o, preferiblemente, en un empaquetado (Sección 3.3):\nR CMD build somepackage\nR CMD check somepackage_0.0.0.9000.tar.gz  \nPara obtener más información, consulte la sección Comprobación de paquetes de Escribir extensiones R.\n\n\n\n\nSilge, Julia, John C. Nash, y Spencer Graves. 2018. «Navigating the R Package Universe». The R Journal 10 (2): 558-63. https://doi.org/10.32614/RJ-2018-058.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "workflow101.html#footnotes",
    "href": "workflow101.html#footnotes",
    "title": "4  Flujos de trabajo de desarrollo fundamentales",
    "section": "",
    "text": "Específicamente, configuramos Alfred para favorecer los archivos .Rproj en sus resultados de búsqueda cuando propone aplicaciones o archivos para abrir. Para registrar el tipo de archivo .Rproj con Alfred, vaya a Preferences &gt; Features &gt; Default Results &gt; Advanced. Arrastre cualquier archivo .Rproj a este espacio y luego ciérrelo.↩︎\nCitando la filosofía de uso favorecida por Emacs Speaks Statistics (ESS).↩︎\nEl método de línea de comando es salir de R, ir al shell, hacer R CMD build foo en el directorio principal del paquete, luego R CMD INSTALL foo_x.y.x.tar.gz, reiniciar R y llamar library(foo).↩︎\nUna excelente publicación de blog que aboga por “si duele, hazlo más a menudo” es FrequencyReducesDifficulty de Martin Fowler.↩︎",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Flujos de trabajo de desarrollo fundamentales</span>"
    ]
  },
  {
    "objectID": "package-within.html",
    "href": "package-within.html",
    "title": "5  El paquete en el interior de su código",
    "section": "",
    "text": "5.1 Alfa: un código que funciona\nEsta parte del libro termina de la misma manera que comenzó, con el desarrollo de un pequeño paquete de juguete. Capítulo 1 estableció la mecánica básica, el flujo de trabajo y las herramientas para el desarrollo de paquetes, pero no dijo prácticamente nada sobre el código R dentro del paquete. Este capítulo se centra principalmente en el código R del paquete y en qué se diferencia del código R en un script.\nA partir de un script de análisis de datos, aprenderá cómo encontrar el paquete que se esconde en su interior. Aislará y luego extraerá datos y lógica reutilizables del script, los colocará en un paquete R y luego usará ese paquete en un script mucho más simplificado. Hemos incluido algunos errores de novato a lo largo del camino para resaltar consideraciones especiales para el código R dentro de un paquete.\nTenga en cuenta que los encabezados de las secciones incorporan el alfabeto fonético de la OTAN (alfa, bravo, etc.) y no tienen un significado específico. Son simplemente una manera conveniente de marcar nuestro progreso hacia un paquete de trabajo. Está bien seguirlo simplemente leyendo y este capítulo es completamente autónomo, es decir, no es un requisito previo para el material posterior en el libro. Pero si desea ver el estado de archivos específicos a lo largo del camino, puede encontrarlos en archivos fuente del libro.\nConsideremos data-cleaning.R, un script de análisis de datos ficticio para un grupo que recopila informes de personas que fueron a nadar:\nSus datos generalmente vienen como un archivo CSV, como swim.csv:\nname,where,temp\nAdam,beach,95\nBess,coast,91\nCora,seashore,28\nDale,beach,85\nEvan,seaside,31\ndata-cleaning.R comienza leyendo swim.csv en un data frame o marco de datos:\ninfile &lt;- \"swim.csv\"\n(dat &lt;- read.csv(infile))\n#&gt;   name    where temp\n#&gt; 1 Adam    beach   95\n#&gt; 2 Bess    coast   91\n#&gt; 3 Cora seashore   28\n#&gt; 4 Dale    beach   85\n#&gt; 5 Evan  seaside   31\nLuego clasifican cada observación en inglés americano (“EE.UU.”) o británico (“Reino Unido”), según la palabra elegida para describir el lugar arenoso donde se unen el océano y la tierra. La columna where se utiliza para construir la nueva columna english.\ndat$english[dat$where == \"beach\"] &lt;- \"US\"\ndat$english[dat$where == \"coast\"] &lt;- \"US\"\ndat$english[dat$where == \"seashore\"] &lt;- \"UK\"\ndat$english[dat$where == \"seaside\"] &lt;- \"UK\"\nLamentablemente, las temperaturas a menudo se informan en una combinación de grados Fahrenheit y Celsius. A falta de mejor información, suponen que los estadounidenses informan las temperaturas en grados Fahrenheit y, por lo tanto, esas observaciones se convierten a grados Celsius.\ndat$temp[dat$english == \"US\"] &lt;- (dat$temp[dat$english == \"US\"] - 32) * 5/9\ndat\n#&gt;   name    where temp english\n#&gt; 1 Adam    beach 35.0      US\n#&gt; 2 Bess    coast 32.8      US\n#&gt; 3 Cora seashore 28.0      UK\n#&gt; 4 Dale    beach 29.4      US\n#&gt; 5 Evan  seaside 31.0      UK\nFinalmente, estos datos limpios (¿más limpios?) se vuelven a escribir en un archivo CSV. Les gusta capturar una marca de tiempo en el nombre del archivo cuando hacen esto.1.\nnow &lt;- Sys.time()\ntimestamp &lt;- format(now, \"%Y-%B-%d_%H-%M-%S\")\n(outfile &lt;- paste0(timestamp, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile)))\n#&gt; [1] \"2025-August-23_05-59-49_swim_clean.csv\"\nwrite.csv(dat, file = outfile, quote = FALSE, row.names = FALSE)\nAquí está data-cleaning.R en su totalidad:\ninfile &lt;- \"swim.csv\"\n(dat &lt;- read.csv(infile))\n\ndat$english[dat$where == \"beach\"] &lt;- \"US\"\ndat$english[dat$where == \"coast\"] &lt;- \"US\"\ndat$english[dat$where == \"seashore\"] &lt;- \"UK\"\ndat$english[dat$where == \"seaside\"] &lt;- \"UK\"\n\ndat$temp[dat$english == \"US\"] &lt;- (dat$temp[dat$english == \"US\"] - 32) * 5/9\ndat\n\nnow &lt;- Sys.time()\ntimestamp &lt;- format(now, \"%Y-%B-%d_%H-%M-%S\")\n(outfile &lt;- paste0(timestamp, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile)))\nwrite.csv(dat, file = outfile, quote = FALSE, row.names = FALSE)\nIncluso si sus tareas analíticas típicas son bastante diferentes, es de esperar que vea algunos patrones familiares aquí. Es fácil imaginar que este grupo realiza un preprocesamiento muy similar de muchos archivos de datos similares a lo largo del tiempo. Sus análisis pueden ser más eficientes y consistentes si ponen a su disposición estas maniobras de datos estándar como funciones en un paquete, en lugar de incorporar los mismos datos y lógica en docenas o cientos de scripts de ingesta de datos.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#alfa-un-código-que-funciona",
    "href": "package-within.html#alfa-un-código-que-funciona",
    "title": "5  El paquete en el interior de su código",
    "section": "",
    "text": "¿Dónde nadaste y qué calor hacía afuera?",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#bravo-un-mejor-código-que-funciona",
    "href": "package-within.html#bravo-un-mejor-código-que-funciona",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.2 Bravo: un mejor código que funciona",
    "text": "5.2 Bravo: un mejor código que funciona\n¡El paquete que se esconde dentro del código original es bastante difícil de ver! Está oscurecido por algunas prácticas de codificación subóptimas, como el uso de código repetitivo estilo copiar/pegar y la mezcla de código y datos. Por lo tanto, un buen primer paso es refactorizar este código, aislando la mayor cantidad de datos y lógica posible en objetos y funciones adecuados, respectivamente.\nEste también es un buen momento para introducir el uso de algunos paquetes complementarios, por varias razones. En primer lugar, utilizaríamos el tidyverse para este tipo de manipulación de datos. En segundo lugar, muchas personas utilizan paquetes complementarios en sus scripts, por lo que es bueno ver cómo se manejan los paquetes complementarios dentro de un paquete.\nAquí está la versión nueva y mejorada del script.\n\nlibrary(tidyverse)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\nlookup_table &lt;- tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\ndat &lt;- dat %&gt;% \n  left_join(lookup_table)\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\ndat &lt;- dat %&gt;% \n  mutate(temp = if_else(english == \"US\", f_to_c(temp), temp))\ndat\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\nwrite_csv(dat, outfile_path(infile))\n\nLos cambios clave a tener en cuenta son:\n\nEstamos usando funciones de los paquetes tidyverse (específicamente de readr y dplyr) y las ponemos a disposición con library(tidyverse).\nEl mapa entre diferentes palabras de playa y si se consideran inglés de EE. UU. o Reino Unido ahora está aislado en una tabla de búsqueda, lo que nos permite crear la columna english de una sola vez con left_join(). Esta tabla de búsqueda hace que el mapeo sea más fácil de comprender y sería mucho más fácil ampliarlo en el futuro con nuevas palabras playa.\n\nf_to_c(), timestamp(), y outfile_path() son nuevas funciones auxiliares que mantienen la lógica para convertir temperaturas y formar el nombre del archivo de salida con marca de tiempo.\n\nCada vez es más fácil reconocer los bits reutilizables de este script, es decir, los bits que no tienen nada que ver con un archivo de entrada específico, como swim.csv. Este tipo de refactorización a menudo ocurre naturalmente en el camino hacia la creación de su propio paquete, pero si no es así, es una buena idea hacerlo intencionalmente.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#charlie-un-archivo-separado-para-funciones-auxiliares",
    "href": "package-within.html#charlie-un-archivo-separado-para-funciones-auxiliares",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.3 Charlie: un archivo separado para funciones auxiliares",
    "text": "5.3 Charlie: un archivo separado para funciones auxiliares\nUn siguiente paso típico es mover los datos y la lógica reutilizables del script de análisis a uno o más archivos separados. Este es un movimiento de apertura convencional, si desea utilizar estos mismos archivos auxiliares en múltiples análisis.\nAquí está el contenido de beach-lookup-table.csv:\n\nwhere,english\nbeach,US\ncoast,US\nseashore,UK\nseaside,UK\n\nAquí está el contenido de cleaning-helpers.R:\n\nlibrary(tidyverse)\n\nlocalize_beach &lt;- function(dat) {\n  lookup_table &lt;- read_csv(\n    \"beach-lookup-table.csv\",\n    col_types = cols(where = \"c\", english = \"c\")\n  )\n  left_join(dat, lookup_table)\n}\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\ncelsify_temp &lt;- function(dat) {\n  mutate(dat, temp = if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nHemos agregado algunas funciones auxiliares de alto nivel, localize_beach() y celsify_temp(), A los ayudantes preexistentes (f_to_c(), timestamp(), y outfile_path()).\nAquí está la próxima versión del script de limpieza de datos, ahora que hemos eliminado las funciones auxiliares (y la tabla de búsqueda).\n\nlibrary(tidyverse)\nsource(\"cleaning-helpers.R\")\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\n(dat &lt;- dat %&gt;% \n    localize_beach() %&gt;% \n    celsify_temp())\n\nwrite_csv(dat, outfile_path(infile))\n\nObserve que el código es cada vez más corto y, con suerte, más fácil de leer y modificar, porque el desorden repetitivo y complicado se ha eliminado de la vista. Si es realmente más fácil trabajar con el código es subjetivo y depende de qué tan natural se sienta la “interfaz” para las personas que realmente preprocesan los datos de natación. Este tipo de decisiones de diseño son objeto de un proyecto separado: design.tidyverse.org.\nSupongamos que el grupo está de acuerdo en que nuestras decisiones de diseño son prometedoras, es decir, parece que estamos mejorando las cosas, no empeorando. Claro, el código existente no es perfecto, pero esta es una etapa de desarrollo típica en la que intentas descubrir cuáles deberían ser las funciones auxiliares y cómo deberían funcionar.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#delta-un-intento-fallido-de-hacer-un-paquete",
    "href": "package-within.html#delta-un-intento-fallido-de-hacer-un-paquete",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.4 Delta: un intento fallido de hacer un paquete",
    "text": "5.4 Delta: un intento fallido de hacer un paquete\nSi bien este primer intento de crear un paquete terminará en un fracaso, sigue siendo útil analizar algunos errores comunes para iluminar lo que sucede detrás de escena.\nEstos son los pasos más simples que puede seguir en un intento de convertir cleaning-helpers.R en un paquete en condiciones:\n\nUtilice usethis::create_package(\"ruta/a/delta\") para crear un scaffolding de un nuevo paquete R, con el nombre “delta”.\n\n¡Este es un buen primer paso!\n\n\nCopie cleaning-helpers.R en el nuevo paquete, específicamente, para R/cleaning-helpers.R.\n\nEsto es moralmente correcto, pero mecánicamente incorrecto en varios sentidos, como veremos pronto.\n\n\nCopie beach-lookup-table.csv en el nuevo paquete. ¿Pero donde? Probemos el nivel superior del paquete fuente.\n\nEsto no va a terminar bien. Los archivos de datos de envío en un paquete es un tema especial, que se trata en Capítulo 7.\n\n\nInstale este paquete, quizás usando devtools::install() o mediante Ctrl + Shift + B (Windows y Linux) o Cmd + Shift + B en RStudio.\n\nA pesar de todos los problemas identificados anteriormente, ¡esto realmente funciona! Lo cual es interesante, porque podemos (intentar) usarlo y ver qué sucede.\n\n\n\nAquí está la próxima versión del script de limpieza de datos que espera que se ejecute después de instalar exitosamente este paquete (al que llamamos “delta”).\n\nlibrary(tidyverse)\nlibrary(delta)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n\nwrite_csv(dat, outfile_path(infile))\n\nEl único cambio con respecto a nuestro código anterior es que\n\nsource(\"cleaning-helpers.R\")\n\nha sido reemplazado por\n\nlibrary(delta)\n\nEsto es lo que realmente sucede si instala el paquete delta e intenta ejecutar el script de limpieza de datos:\n\nlibrary(tidyverse)\nlibrary(delta)\n\ninfile &lt;- \"swim.csv\"\ndat &lt;- read_csv(infile, col_types = cols(name = \"c\", where = \"c\", temp = \"d\"))\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n#&gt; Error in localize_beach(.) : could not find function \"localize_beach\"\n\nwrite_csv(dat, outfile_path(infile))\n#&gt; Error in outfile_path(infile) : could not find function \"outfile_path\"\n\n¡Ninguna de las funciones auxiliares está realmente disponible para su uso, aunque llame a library(delta)! A diferencia de source(), al enviar un archivo de funciones auxiliares, adjuntar un paquete no volca sus funciones en el espacio de trabajo global. De forma predeterminada, las funciones de un paquete son sólo para uso interno. Necesita exportar localize_beach(), celsify_temp() y outfile_path() para que sus usuarios puedan llamarlos. En el flujo de trabajo de devtools, logramos esto poniendo @export en el comentario especial de roxygen encima de cada función (la administración del espacio de nombres se trata en Sección 11.3), así:\n\n#' @export\ncelsify_temp &lt;- function(dat) {\n  mutate(dat, temp = if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nDespués de agregar la etiqueta @export a localize_beach(), celsify_temp() y outfile_path(), ejecuta devtools::document() para (re)generar el archivo NAMESPACE, y reinstale el paquete delta. Ahora, cuando vuelves a ejecutar el script de limpieza de datos, ¡funciona!\nCorrección: más o menos funciona a veces. Específicamente, funciona si y sólo si el directorio de trabajo está configurado en el nivel superior del paquete fuente. Desde cualquier otro directorio de trabajo, sigue apareciendo un error:\n\ndat &lt;- dat %&gt;% \n  localize_beach() %&gt;% \n  celsify_temp()\n#&gt; Error: 'beach-lookup-table.csv' does not exist in current working directory ('/Users/jenny/tmp').\n\nNo se puede encontrar la tabla de búsqueda consultada dentro de localize_beach(). Uno no simplemente volca archivos CSV en el código fuente de un paquete R y espera que las cosas “simplemente funcionen”. Arreglaremos esto en nuestra próxima versión del paquete (Capítulo 7 tiene una cobertura completa sobre cómo incluir datos en un paquete).\nAntes de abandonar este experimento inicial, maravillémonos también del hecho de que haya podido instalar, adjuntar y, hasta cierto punto, utilizar un paquete fundamentalmente roto. ¡devtools::load_all() también funciona bien! Este es un recordatorio aleccionador de que debería ejecutar R CMD check, probablemente a través de devtools::check(), muy a menudo durante el desarrollo. Esto le alertará rápidamente sobre muchos problemas que la simple instalación y uso no revelan.\nDe hecho, check() falla para este paquete y ves esto:\n * installing *source* package ‘delta’ ...\n ** using staged installation\n ** R\n ** byte-compile and prepare package for lazy loading\n Error in library(tidyverse) : there is no package called ‘tidyverse’\n Error: unable to load R code in package ‘delta’\n Execution halted\n ERROR: lazy loading failed for package ‘delta’\n * removing ‘/Users/jenny/rrr/delta.Rcheck/delta’\n¿¡¿Qué quieres decir con “no hay ningún paquete llamado ‘tidyverse’”?!? ¡Lo estamos usando, sin problemas, en nuestro script principal! Además, ya hemos instalado y utilizado este paquete, ¿por qué R CMD check no puede encontrarlo?\nEste error es lo que sucede cuando el rigor de “R CMD check” cumple con la primera línea de R/cleaning-helpers.R:\n\nlibrary(tidyverse)\n\nNo es así como declaras que tu paquete depende de otro paquete (el tidyverse, en este caso). Así tampoco es cómo haces que las funciones de otro paquete estén disponibles para usar en el tuyo. Las dependencias deben declararse en DESCRIPTION (y eso no es todo). Como no declaramos dependencias, R CMD check nos toma la palabra e intenta instalar nuestro paquete solo con los paquetes base disponibles, lo que significa que esta llamada a library(tidyverse) falla. Una instalación “normal” tiene éxito, simplemente porque tidyverse está disponible en su biblioteca habitual, lo que oculta este error en particular.\nPara revisar, copiar cleaning-helpers.R a R/cleaning-helpers.R, sin modificaciones adicionales, fue problemático en (al menos) las siguientes maneras:\n\nNo tiene en cuenta las funciones exportadas y no exportadas.\nEl archivo CSV que contiene nuestra tabla de búsqueda no se puede encontrar en el paquete instalado.\nNo declara adecuadamente nuestra dependencia de otros paquetes complementarios.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#echo-un-paquete-que-funciona",
    "href": "package-within.html#echo-un-paquete-que-funciona",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.5 Echo: un paquete que funciona",
    "text": "5.5 Echo: un paquete que funciona\nEstamos listos para crear la versión mínima de este paquete que realmente funcione.\nAquí está la nueva versión de R/cleaning-helpers.R2:\n\nlookup_table &lt;- dplyr::tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\n#' @export\nlocalize_beach &lt;- function(dat) {\n  dplyr::left_join(dat, lookup_table)\n}\n\nf_to_c &lt;- function(x) (x - 32) * 5/9\n\n#' @export\ncelsify_temp &lt;- function(dat) {\n  dplyr::mutate(dat, temp = dplyr::if_else(english == \"US\", f_to_c(temp), temp))\n}\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\n\n#' @export\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nHemos vuelto a definir lookup_table con código R, ya que el intento inicial de leerlo desde CSV creó algún tipo de error en la ruta del archivo. Esto está bien para datos pequeños, internos y estáticos, pero recuerde consultar Capítulo 7 para conocer técnicas más generales para almacenar datos en un paquete.\nTodas las llamadas a funciones de tidyverse ahora se han calificado con el nombre del paquete específico que realmente proporciona la función, por ejemplo. dplyr::mutate(). Hay otras formas de acceder a funciones en otro paquete, explicadas en Sección 11.4, pero esta es la opción predeterminada que recomendamos. También es nuestra fuerte recomendación que nadie dependa del metapaquete tidyverse en un paquete3. En cambio, es mejor identificar los paquetes específicos que realmente utiliza. En este caso, el paquete sólo utiliza dplyr.\nLa llamada library(tidyverse) desapareció y en su lugar declaramos el uso de dplyr en el campo Imports de DESCRIPTION:\nPackage: echo\n(... other lines omitted ...)\nImports: \n    dplyr\nEsto, junto con el uso de llamadas calificadas para espacios de nombres, como dplyr::left_join(), constituye una forma válida de utilizar otro paquete dentro del suyo. Los metadatos transmitidos a través de DESCRIPTION están cubiertos en Capítulo 9.\nTodas las funciones orientadas al usuario tienen una etiqueta @export en su comentario de roxygen, lo que significa que devtools::document() las agrega correctamente al archivo NAMESPACE. Tenga en cuenta que f_to_c() actualmente solo se usa internamente, dentro de celsify_temp(), por lo que no se exporta (lo mismo ocurre con timestamp()).\nEsta versión del paquete se puede instalar, usar y técnicamente pasa la verificación R CMD check, aunque con 1 advertencia y 1 nota.\n* checking for missing documentation entries ... WARNING\nUndocumented code objects:\n  ‘celsify_temp’ ‘localize_beach’ ‘outfile_path’\nAll user-level objects in a package should have documentation entries.\nSee chapter ‘Writing R documentation files’ in the ‘Writing R\nExtensions’ manual.\n\n* checking R code for possible problems ... NOTE\ncelsify_temp: no visible binding for global variable ‘english’\ncelsify_temp: no visible binding for global variable ‘temp’\nUndefined global functions or variables:\n  english temp\nLa nota “sin enlace visible” es una peculiaridad del uso de dplyr y nombres de variables sin comillas dentro de un paquete, donde el uso de nombres de variables simples (english y temp) parece sospechoso. Puede agregar cualquiera de estas líneas a cualquier archivo debajo de R/ para eliminar esta nota (como el archivo de documentación a nivel de paquete descrito en Sección 16.7):\n\n# opción 1 (entonces también deberías poner utilidades en Importaciones)\nutils::globalVariables(c(\"english\", \"temp\"))\n\n# opción 2\nenglish &lt;- temp &lt;- NULL\n\nEstamos viendo que puede resultar complicado programar en torno a un paquete como dplyr, que hace un uso intensivo de evaluación no estándar. Detrás de escena, esa es la técnica que permite a los usuarios finales de dplyr usar nombres de variables simples (sin comillas). Paquetes como dplyr priorizan la experiencia del usuario final típico, a costa de hacer que sea más difícil depender de ellos. Las dos opciones que se muestran arriba para suprimir la nota “sin enlace visible” representan soluciones de nivel básico. Para un tratamiento más sofisticado de estos temas, ver vignette(\"in-packages\", package = \"dplyr\") y vignette(\"programming\", package = \"dplyr\").\nLa advertencia sobre la documentación faltante se debe a que las funciones exportadas no se han documentado adecuadamente. Esta es una preocupación válida y algo que absolutamente debes abordar en un paquete real. Ya has visto cómo crear archivos de ayuda con comentarios de roxygen en Sección 1.12 y cubrimos este tema a fondo en Capítulo 16.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#sec-package-within-build-time-run-time",
    "href": "package-within.html#sec-package-within-build-time-run-time",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.6 Foxtrot: tiempo de construcción versus tiempo de ejecución",
    "text": "5.6 Foxtrot: tiempo de construcción versus tiempo de ejecución\nEl paquete echo funciona, lo cual es fantástico, pero los miembros del grupo notan algo extraño en las marcas de tiempo:\n\nSys.time()\n#&gt; [1] \"2023-03-26 22:48:48 PDT\"\n\noutfile_path(\"INFILE.csv\")\n#&gt; [1] \"2020-September-03_11-06-33_INFILE_clean.csv\"\n\nLa fecha y hora en el nombre del archivo con marca de tiempo no refleja la hora informada por el sistema. De hecho, los usuarios afirman que la marca de tiempo nunca parece cambiar en absoluto. ¿Por qué es esto?\nRecuerde cómo formamos la ruta del archivo para los archivos de salida:\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nEl hecho de que capturemos now &lt;- Sys.time() fuera de la definición de outfile_path() probablemente ha estado molestando a algunos lectores por un tiempo. now refleja el instante en el tiempo en el que ejecutamos now &lt;- Sys.time(). En el enfoque inicial, se asignó now cuando source()d cleaning-helpers.R. Eso no es ideal, pero probablemente fue un error bastante inofensivo, porque el archivo auxiliar sería source()d poco antes de que escribiéramos el archivo de salida.\nPero este enfoque es bastante devastador en el contexto de un paquete. now &lt;- Sys.time() es ejecutado cuando se construye el paquete4. Y nunca más. Es muy fácil asumir que el código de su paquete se vuelve a evaluar cuando se adjunta o utiliza el paquete. Pero no lo es. Sí, el código dentro de sus funciones se ejecuta absolutamente cada vez que se llaman. Pero sus funciones, y cualquier otro objeto creado en el código de nivel superior debajo de R/, se definen exactamente una vez, en el momento de la compilación.\nAl definir now con el código de nivel superior debajo de R/, hemos condenado a nuestro paquete a marcar la hora de todos sus archivos de salida con la misma hora (incorrecta). La solución es asegurarse de que la llamada Sys.time() se realice en tiempo de ejecución.\nVeamos nuevamente partes de R/cleaning-helpers.R:\n\nlookup_table &lt;- dplyr::tribble(\n      ~where, ~english,\n     \"beach\",     \"US\",\n     \"coast\",     \"US\",\n  \"seashore\",     \"UK\",\n   \"seaside\",     \"UK\"\n)\n\nnow &lt;- Sys.time()\ntimestamp &lt;- function(time) format(time, \"%Y-%B-%d_%H-%M-%S\")\noutfile_path &lt;- function(infile) {\n  paste0(timestamp(now), \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nHay cuatro asignaciones &lt;- de nivel superior en este extracto. Las definiciones de nivel superior del marco de datos lookup_table y las funciones timestamp() y outfile_path() son correctas. Es apropiado que se definan exactamente una vez, en el momento de la construcción. La definición de nivel superior de now, que luego se usa dentro de outfile_path(), es lamentable.\nAquí hay mejores versiones de outfile_path():\n\n# siempre marca de tiempo como \"now\"\noutfile_path &lt;- function(infile) {\n  ts &lt;- timestamp(Sys.time())\n  paste0(ts, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\n# permitir al usuario proporcionar una hora, pero de forma predeterminada \"now\"\noutfile_path &lt;- function(infile, time = Sys.time()) {\n  ts &lt;- timestamp(time)\n  paste0(ts, \"_\", sub(\"(.*)([.]csv$)\", \"\\\\1_clean\\\\2\", infile))\n}\n\nEsto ilustra que es necesario tener una mentalidad diferente al definir objetos dentro de un paquete. La gran mayoría de esos objetos deberían ser funciones y estas funciones generalmente solo deberían usar datos que crean o que se pasan a través de un argumento. Hay algunos tipos de descuido que son bastante inofensivos cuando una función se define inmediatamente antes de su uso, pero que pueden ser más costosos para funciones distribuidas como un paquete.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#sec-package-within-side-effects",
    "href": "package-within.html#sec-package-within-side-effects",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.7 Golf: efectos secundarios",
    "text": "5.7 Golf: efectos secundarios\nLas marcas de tiempo ahora reflejan la hora actual, pero el grupo plantea una nueva preocupación. Tal como están las cosas, las marcas de tiempo reflejan quién ha realizado la limpieza de datos y en qué parte del mundo se encuentran. El corazón de la estrategia de marca de tiempo es esta cadena de formato5:\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n#&gt; [1] \"2025-August-23_05-59-50\"\n\nEsto formatea Sys.time() de tal manera que incluya el nombre del mes (no el número) y la hora local.6.\nTabla 5.1 muestra lo que sucede cuando varios colegas hipotéticos producen una marca de tiempo de este tipo limpiando algunos datos exactamente en el mismo instante.\n\n\n\nTabla 5.1: La marca de tiempo varía según la ubicación y la zona horaria.\n\n\n\n\n\n\n\n\n\n\nlocation\ntimestamp\nLC_TIME\ntz\n\n\n\nRome, Italy\n2020-September-05_00-30-00\nit_IT.UTF-8\nEurope/Rome\n\n\nWarsaw, Poland\n2020-September-05_00-30-00\npl_PL.UTF-8\nEurope/Warsaw\n\n\nSao Paulo, Brazil\n2020-September-04_19-30-00\npt_BR.UTF-8\nAmerica/Sao_Paulo\n\n\nGreenwich, England\n2020-September-04_23-30-00\nen_GB.UTF-8\nEurope/London\n\n\n“Computer World!”\n2020-September-04_22-30-00\nC\nUTC\n\n\n\n\n\n\n\n\nTenga en cuenta que los nombres de los meses varían, al igual que la hora e incluso la fecha. La opción más segura es formar marcas de tiempo con respecto a una ubicación y zona horaria fijas (presumiblemente las opciones no geográficas representadas por “Computer World!” arriba).\nInvestiga un poco y descubre que puede forzar una determinada configuración regional a través de Sys.setlocale() y forzar una determinada zona horaria configurando la variable de entorno TZ. Específicamente, configuramos el componente LC_TIME de la configuración regional en “C” y la zona horaria en “UTC” (Tiempo universal coordinado). Aquí está tu primer intento de mejorar. timestamp():\n\ntimestamp &lt;- function(time = Sys.time()) {\n  Sys.setlocale(\"LC_TIME\", \"C\")\n  Sys.setenv(TZ = \"UTC\")\n  format(time, \"%Y-%B-%d_%H-%M-%S\")\n}\n\nPero su colega brasileña nota que las fechas y horas se imprimen de manera diferente, antes y después de usar outfile_path() de su paquete:\nAntes:\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n\n\n#&gt; Warning in (function (category = \"LC_ALL\", locale = \"\") : OS\n#&gt; reports request to set locale to \"pt_BR.UTF-8\" cannot be honored\n#&gt; [1] \"2025-August-23_02-59-50\"\n\nDespués:\n\noutfile_path(\"INFILE.csv\")\n#&gt; [1] \"2025-August-23_05-59-50_INFILE_clean.csv\"\n\nformat(Sys.time(), \"%Y-%B-%d_%H-%M-%S\")\n#&gt; [1] \"2025-August-23_05-59-50\"\n\nObserve que el nombre de su mes cambió de portugués a inglés y que la hora claramente se informa en una zona horaria diferente. Las llamadas a Sys.setlocale() y Sys.setenv() dentro de timestamp() han realizado cambios persistentes (y muy sorprendentes) en su sesión de R. Este tipo de efecto secundario es muy indeseable y extremadamente difícil de rastrear y depurar, especialmente en entornos más complicados.\nAquí hay mejores versiones de timestamp():\n\n# use las funciones withr::local_*() para mantener los cambios locales en timestamp()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::local_locale(c(\"LC_TIME\" = \"C\"))\n  withr::local_timezone(\"UTC\")\n  format(time, \"%Y-%B-%d_%H-%M-%S\")\n}\n\n# utilizar el argumento tz para format.POSIXct()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::local_locale(c(\"LC_TIME\" = \"C\"))\n  format(time, \"%Y-%B-%d_%H-%M-%S\", tz = \"UTC\")\n}\n\n# poner la llamada format() dentro withr::with_*()\ntimestamp &lt;- function(time = Sys.time()) {\n  withr::with_locale(\n    c(\"LC_TIME\" = \"C\"),\n    format(time, \"%Y-%B-%d_%H-%M-%S\", tz = \"UTC\")\n  )\n}\n\nEstos muestran varios métodos para limitar el alcance de nuestros cambios a LC_TIME y la zona horaria. Una buena regla general es hacer que el alcance de dichos cambios sea lo más limitado y práctico posible. El argumento tz de format() es la forma más quirúrgica de tratar con la zona horaria, pero no existe nada similar para LC_TIME. Realizamos la modificación local temporal usando el paquete withr, que proporciona un conjunto de herramientas muy flexible para cambios de estado temporales. Esto (y base::on.exit()) se analizan con más detalle en Sección 6.5. Tenga en cuenta que si usa withr como lo hacemos arriba, deberá incluirlo en DESCRIPTION en Imports (Capítulo 11, Sección 10.1.3).\nEsto subraya un punto de la sección anterior: es necesario adoptar una mentalidad diferente al definir funciones dentro de un paquete. Intente evitar realizar cambios en el estado general del usuario. Si dichos cambios son inevitables, asegúrese de revertirlos (si es posible) o documentarlos explícitamente (si están relacionados con el propósito principal de la función).",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#pensamientos-concluyentes",
    "href": "package-within.html#pensamientos-concluyentes",
    "title": "5  El paquete en el interior de su código",
    "section": "\n5.8 Pensamientos concluyentes",
    "text": "5.8 Pensamientos concluyentes\nFinalmente, después de varias iteraciones, extrajimos con éxito el código de limpieza de datos repetitivos para la encuesta de natación en un paquete R. Este ejemplo concluye la primera parte del libro y marca la transición a material de referencia más detallado sobre componentes de paquetes específicos. Antes de continuar, repasemos las lecciones aprendidas en este capítulo.\n\n5.8.1 Script versus paquete\nCuando escuche por primera vez que los usuarios expertos de R suelen poner su código en paquetes, es posible que se pregunte qué significa eso exactamente. Específicamente, ¿qué sucede con sus scripts R existentes, informes R Markdown y aplicaciones Shiny? ¿Todo ese código de alguna manera se coloca en un paquete? La respuesta es “no”, en la mayoría de los contextos.\nNormalmente, identifica ciertas operaciones recurrentes que ocurren en múltiples proyectos y esto es lo que extrae en un paquete R. Seguirá teniendo scripts R, informes R Markdown y aplicaciones Shiny, pero al mover fragmentos de código específicos a un paquete formal, sus productos de datos tienden a volverse más concisos y más fáciles de mantener.\n\n5.8.2 Encontrar el paquete dentro\nAunque el ejemplo de este capítulo es bastante simple, aún captura el proceso típico de desarrollo de un paquete R para uso personal u organizacional. Normalmente se comienza con una colección de scripts R idiosincrásicos y relacionados, repartidos en diferentes proyectos. Con el tiempo, empiezas a notar que ciertas necesidades surgen una y otra vez.\nCada vez que revises un análisis similar, puedes intentar mejorar un poco tu juego, en comparación con la iteración anterior. Refactoriza código de estilo copiar/pegar usando patrones más robustos y comienza a encapsular “movimientos” clave en funciones auxiliares, que eventualmente podrían migrar a su propio archivo. Una vez que llegue a esta etapa, estará en una excelente posición para dar el siguiente paso y crear un paquete.\n\n5.8.3 El código del paquete es diferente.\nEscribir código de paquete es un poco diferente a escribir scripts en R y es natural sentir cierta incomodidad al realizar este ajuste. Estos son los errores más comunes que nos hacen tropezar a muchos de nosotros al principio:\n\nEl código del paquete requiere nuevas formas de trabajar con funciones en otros paquetes. El archivo DESCRIPCIÓN es la forma principal de declarar dependencias; no hacemos esto a través library(somepackage).\nSi desea que los datos o archivos estén disponibles de forma persistente, existen métodos de almacenamiento y recuperación específicos del paquete. No puedes simplemente poner archivos en el paquete y esperar lo mejor.\nEs necesario ser explícito sobre qué funciones están orientadas al usuario y cuáles son ayudas internas. De forma predeterminada, las funciones no se exportan para que otras personas las utilicen.\nSe requiere un nuevo nivel de disciplina para garantizar que el código se ejecute en el momento previsto (tiempo de compilación versus tiempo de ejecución) y que no haya efectos secundarios no deseados.",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "package-within.html#footnotes",
    "href": "package-within.html#footnotes",
    "title": "5  El paquete en el interior de su código",
    "section": "",
    "text": "Sys.time() devuelve un objeto de clase POSIXct, por lo tanto, cuando llamamos a format(), en realidad estamos usando format.POSIXct(). Lea la ayuda de ?format.POSIXct si no esta familiarizado con este formato de caracteres.↩︎\nPoner todo en un solo archivo, con este nombre, no es lo ideal, pero técnicamente está permitido. Discutimos cómo organizar y nombrar los archivos debajo de R/ en Sección 6.1.↩︎\nLa publicación del blog El tidyverse es para EDA, no para paquetes detalla esto.↩︎\nAquí nos referimos a cuándo se compila el código del paquete, que podría ser cuando se crea el binario (para macOS o Windows; Sección 3.4) o cuando el paquete se instala desde la fuente (Sección 3.5).↩︎\nSys.time() devuelve un objeto de clase POSIXct, por lo tanto, cuando llamamos a format(), en realidad estamos usando format.POSIXct(). Lea la ayuda para ?format.POSIXct si no está familiarizado con dichas cadenas de formato.↩︎\nClaramente sería mejor formatear de acuerdo con ISO 8601, que codifica el mes por número, pero por favor, hazme el favor para que este ejemplo sea más obvio.↩︎",
    "crumbs": [
      "Empezando",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>El paquete en el interior de su código</span>"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "6  Código R",
    "section": "",
    "text": "6.1 Organizar funciones en archivos\nEl primer principio al crear un paquete es que todo el código R va al directorio R/. En este capítulo, aprenderá a organizar sus funciones en archivos, mantener un estilo consistente y reconocer los requisitos más estrictos para las funciones en un paquete (en comparación con un script). También le recordaremos los flujos de trabajo fundamentales para realizar pruebas de manejo y verificar formalmente un paquete en desarrollo: load_all(), test(), y check().\nLa única regla estricta es que su paquete debe almacenar sus definiciones de funciones en scripts R, es decir, archivos con extensión .R, que se encuentran en el directorio R/1. Sin embargo, algunas convenciones más pueden hacer que el código fuente de su paquete sea más fácil de navegar y evitarle tener que volver a responder “¿Cómo debería nombrar esto?” cada vez que crea un nuevo archivo. La Guía de estilo de Tidyverse ofrece algunos consejos generales sobre nombres de archivos y también consejos que se aplican específicamente a archivos en un paquete. Nosotros ampliamos esto aquí.\nEl nombre del archivo debe ser significativo y transmitir qué funciones están definidas en él. Si bien eres libre de organizar funciones en archivos como desees, los dos extremos son malos: no coloques todas las funciones en un archivo y no coloques cada función en su propio archivo separado. Este consejo debe informar su política general, pero hay excepciones a cada regla. Si una función específica es muy grande o tiene mucha documentación, puede tener sentido darle su propio archivo, con el nombre de la función. Más a menudo, un único archivo .R contendrá múltiples definiciones de funciones: como una función principal y sus ayudas de apoyo, una familia de funciones relacionadas o alguna combinación de las dos.\nTabla 6.1 presenta algunos ejemplos de la fuente real del paquete tidyr en la versión 1.1.2. Hay algunas desviaciones de las reglas estrictas dadas anteriormente, lo que ilustra que hay mucho margen para juzgar aquí.\nTabla 6.1: Different ways to organize functions in files.\n\n\n\n\nOrganising principle\nSource file\nComments\n\n\n\nUna función\ntidyr/R/uncount.R\nDefine exactamente una función, uncount(), que no es particularmente grande, pero no encaja naturalmente en ningún otro archivo .R\n\n\n\nFunción principal más ayudantes\ntidyr/R/separate.R\nDefine el separate() orientado al usuario (un genérico de S3), un método data.frame y ayudantes privados\n\n\nFamilia de funciones\ntidyr/R/rectangle.R\nDefine una familia de funciones para “rectangular” listas anidadas (funciones hoist() y unnest()), todas documentadas juntas en un gran tema de ayuda, además de ayudas privadas.\nSi es muy difícil predecir en qué archivo se encuentra una función, eso sugiere que es hora de separar sus funciones en más archivos o reconsiderar cómo nombra sus funciones y/o archivos.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#sec-code-organising",
    "href": "code.html#sec-code-organising",
    "title": "6  Código R",
    "section": "",
    "text": "Tip\n\n\n\nOtro archivo que ve a menudo en estado salvaje es R/utils.R. Este es un lugar común para definir pequeñas utilidades que se utilizan dentro de múltiples funciones de paquetes. Dado que sirven como ayuda para múltiples funciones, colocarlos en R/utils.R hace que sea más fácil redescubrirlos cuando regrese a su paquete después de un largo descanso.\nBob Rudis reunió una colección de dichos archivos e hizo algunos análisis en la publicación Dissecting R Package “Utility Belts”.\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nLa organización de funciones dentro de archivos es menos importante en RStudio, que ofrece dos formas de saltar a la definición de una función:\n\n\nPresione Ctrl + . (el punto) para abrir la herramienta Ir a archivo/función, como se muestra en Figura 6.1, luego comience a escribir el nombre. Siga escribiendo para limitar la lista y, finalmente, elija una función (o archivo) para visitar. Esto funciona tanto para funciones como para archivos de su proyecto.\n\n\n\n\n\n\n\nFigura 6.1: Vaya a Archivo/Función en RStudio.\n\n\n\n\n\nCon el cursor en el nombre de una función o con un nombre de función seleccionado, presione F2. Esto funciona para funciones definidas en su paquete o en otro paquete.\n\nDespués de navegar a una función con uno de estos métodos, regrese al punto de partida haciendo clic en la flecha hacia atrás en la parte superior izquierda del editor. () o presionando Ctrl + F9 (Windows & Linux) o Cmd + F9 (macOS).",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#sec-code-load-all",
    "href": "code.html#sec-code-load-all",
    "title": "6  Código R",
    "section": "\n6.2 Comentarios rápidos a través de load_all()\n",
    "text": "6.2 Comentarios rápidos a través de load_all()\n\nA medida que agrega o modifica funciones definidas en archivos debajo de R/, naturalmente querrá probarlas. Queremos reiterar nuestra firme recomendación de utilizar devtools::load_all() para que estén disponibles para la exploración interactiva en lugar de, por ejemplo, archivos source() a continuación R/. La cobertura principal de load_all() está en Sección 4.4 y load_all() también aparece como una de las tareas de desarrollo naturales en Sección 1.8. La importancia de load_all() en el flujo de trabajo de prueba se explica en Sección 14.2.5. En comparación con las alternativas, load_all() le ayuda a iterar más rápidamente y proporciona una excelente aproximación al régimen de espacio de nombres de un paquete instalado.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#code-style",
    "href": "code.html#code-style",
    "title": "6  Código R",
    "section": "\n6.3 Code style",
    "text": "6.3 Code style\nRecomendamos seguir la guía de estilo de tidyverse (https://style.tidyverse.org), que detalla muchos más detalles que los que podemos encontrar aquí. Su formato también le permite ser un documento más dinámico que este libro.\nAunque la guía de estilo explica el “qué” y el “por qué”, otra decisión importante es cómo imponer un estilo de código específico. Para ello recomendamos el paquete styler (https://styler.r-lib.org); su comportamiento predeterminado aplica la guía de estilo tidyverse. Hay muchas formas de aplicar Styler a su código, según el contexto:\n\n\nstyler::style_pkg() rediseña un paquete R completo.\n\nstyler::style_dir() Cambia el estilo de todos los archivos en un directorio.\n\nusethis::use_tidy_style() es un contenedor que aplica una de las funciones anteriores dependiendo de si el proyecto actual es un paquete R o no.\n\nstyler::style_file() Cambia el estilo de un solo archivo.\n\nstyler::style_text() Cambia el estilo de un vector de caracteres.\n\n\n\n\n\n\n\nRStudio\n\n\n\nCuando se instala styler, el menú de complementos de RStudio ofrecerá varias formas adicionales de aplicar estilo al código:\n\nla selección activa\nel archivo activo\nel paquete activo\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi no usas Git u otro sistema de control de versiones, aplicar una función como styler::style_pkg() es estresante y algo peligroso, porque no tienes una forma de ver exactamente qué cambió y aceptar/rechazar dichos cambios. de forma granular.\n\n\nEl paquete styler también se puede integrar con varias plataformas para alojar el código fuente y realizar una integración continua. Por ejemplo, los paquetes tidyverse usan una acción de GitHub que cambia el estilo de un paquete cuando se activa mediante un comentario especial (/style) en una solicitud de extracción. Esto permite a los mantenedores concentrarse en revisar el contenido de la solicitud de extracción, sin tener que preocuparse por pequeños problemas de espacios en blanco o sangrías.2 3 .",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#sec-code-when-executed",
    "href": "code.html#sec-code-when-executed",
    "title": "6  Código R",
    "section": "\n6.4 Comprender cuándo se ejecuta el código",
    "text": "6.4 Comprender cuándo se ejecuta el código\nHasta ahora, probablemente hayas estado escribiendo scripts, código R guardado en un archivo que ejecutas interactivamente, tal vez usando un IDE y/o source(), o de forma no interactiva a través de Rscript. Hay dos diferencias principales entre el código en scripts y paquetes:\n\nEn un script, el código se ejecuta… ¡cuando lo ejecutas! La incomodidad de esta afirmación refleja que es difícil siquiera pensar en este tema con un guión. Sin embargo, debemos hacerlo para poder apreciar que el código de un paquete se ejecuta cuando se compila el paquete. Esto tiene grandes implicaciones sobre cómo escribe el código debajo de R/: el código del paquete solo debe crear objetos, la gran mayoría de los cuales serán funciones.\nLas funciones de tu paquete se utilizarán en situaciones que no imaginabas. Esto significa que sus funciones deben ser cuidadosas en la forma en que interactúan con el mundo exterior.\n\nAmpliamos el primer punto aquí y el segundo en la siguiente sección. Estos temas también se ilustran concretamente en Sección 5.6.\nCuando llamas source() a un script, cada línea de código se ejecuta y los resultados están disponibles inmediatamente. Las cosas son diferentes con el código del paquete, porque se carga en dos pasos. Cuando se compila el paquete binario (a menudo, mediante CRAN), se ejecuta todo el código en R/ y se guardan los resultados. Cuando adjunta un paquete con library(), estos resultados almacenados en caché se recargan y ciertos objetos (principalmente funciones) quedan disponibles para su uso. Los detalles completos sobre lo que significa que un paquete esté en formato binario se proporcionan en Sección 3.4. Nos referimos a la creación del paquete binario como “tiempo de compilación” (binario) y, específicamente, nos referimos a cuando se ejecuta R CMD INSTALL --build. (Se podría pensar que esto es lo que hace R CMD build, pero eso en realidad crea un paquete empaquetado, también conocido como un “tarball fuente”.) Para los usuarios de paquetes CRAN de macOS y Windows, el tiempo de compilación es cuando CRAN creó el paquete binario para su sistema operativo. Para aquellos que instalan paquetes desde el código fuente, el tiempo de compilación es esencialmente cuando (construyeron e) instalaron el paquete.\nConsidere la asignación x &lt;- Sys.time(). Si pones esto en un script, x te dice cuándo el script fue source()d. Pero si coloca ese mismo código en el nivel superior de un paquete, x le indica cuándo se construyó el binario del paquete. En Sección 5.6, mostramos un ejemplo completo de esto en el contexto de la formación de marcas de tiempo dentro de un paquete.\nLa conclusión principal es esta:\n\nCualquier código R fuera de una función es sospechoso y debe revisarse cuidadosamente.\n\nA continuación, exploramos algunos ejemplos del mundo real que muestran lo fácil que es quedar quemado por este problema de “tiempo de construcción versus tiempo de carga”. Afortunadamente, una vez que se diagnostica este problema, generalmente no es difícil solucionarlo.\n\n6.4.1 Ejemplo: Un camino devuelto por system.file()\n\nEl paquete shinybootstrap2 alguna vez tuvo este código a continuación R/:\n\ndataTableDependency &lt;- list(\n  htmlDependency(\n    \"datatables\", \"1.10.2\",\n    c(file = system.file(\"www/datatables\", package = \"shinybootstrap2\")),\n    script = \"js/jquery.dataTables.min.js\"\n  ),\n  htmlDependency(\n    \"datatables-bootstrap\", \"1.10.2\",\n    c(file = system.file(\"www/datatables\", package = \"shinybootstrap2\")),\n    stylesheet = c(\"css/dataTables.bootstrap.css\", \"css/dataTables.extra.css\"),\n    script = \"js/dataTables.bootstrap.js\"\n  )\n)\n\nEntonces, dataTableDependency era un objeto de lista definido en el código del paquete de nivel superior y su valor se construyó a partir de rutas obtenidas a través de system.file(). Como se describe en un problema de GitHub,\n\nEsto funciona bien cuando el paquete se crea y se prueba en la misma máquina. Sin embargo, si el paquete se construye en una máquina y luego se usa en otra (como es el caso con los paquetes binarios CRAN), esto fallará: la dependencia apuntará al directorio incorrecto en el host.\n\nEl corazón de la solución es asegurarse de que system.file() se llame desde una función, en tiempo de ejecución. De hecho, esta solución se realizó aquí (en commit 138db47) y en algunos otros paquetes que tenían código similar y se agregó una verificación relacionada en el propio htmlDependency(). Este problema en particular ahora sería detectado por “R CMD check”, debido a los cambios que vinieron con instalación por etapas a partir de R 3.6.0.\n\n6.4.2 Ejemplo: Colores disponibles\nEl paquete crayon tiene una función, crayon::show_ansi_colors(), que muestra una tabla de colores ANSI en la pantalla, básicamente para mostrar qué tipo de estilo es posible. En una versión anterior, la función se parecía a esta:\n\nshow_ansi_colors &lt;- function(colors = num_colors()) {\n  if (colors &lt; 8) {\n    cat(\"Los colores no son compatibles\")\n  } else if (colors &lt; 256) {\n    cat(ansi_colors_8, sep = \"\")\n    invisible(ansi_colors_8)\n  } else {\n    cat(ansi_colors_256, sep = \"\")\n    invisible(ansi_colors_256)\n  }\n}\n\nansi_colors_8 &lt;- # código para generar un vector que cubre los colores básicos del terminal\n  \nansi_colors_256 &lt;- # código para generar un vector que cubre 256 colores\n\ndonde ansi_colors_8 y ansi_colors_256 eran vectores de caracteres que exploraban un determinado conjunto de colores, presumiblemente diseñados mediante escapes ANSI.\nEl problema era que esos objetos se formaban y almacenaban en caché cuando se compilaba el paquete binario. Dado que esto sucede a menudo en un servidor sin cabeza, es probable que esto suceda en condiciones en las que los colores del terminal podrían no estar habilitados o incluso disponibles. Los usuarios del paquete instalado aún podrían llamar a show_ansi_colors() y num_colors() detectaría la cantidad de colores admitidos por su sistema (256 en la mayoría de las computadoras modernas). Pero entonces un objeto sin color se imprimiría en la pantalla (el problema original de GitHub es r-lib/crayon#37).\nLa solución fue calcular los objetos de visualización con una función en tiempo de ejecución (en confirmación e2b368a:\n\nshow_ansi_colors &lt;- function(colors = num_colors()) {\n  if (colors &lt; 8) {\n    cat(\"Colors are not supported\")\n  } else if (colors &lt; 256) {\n    cat(ansi_colors_8(), sep = \"\")\n    invisible(ansi_colors_8())\n  } else {\n    cat(ansi_colors_256(), sep = \"\")\n    invisible(ansi_colors_256())\n  }\n}\n\nansi_colors_8 &lt;- function() {\n  # código para generar un vector que cubre los colores básicos del terminal\n}\n  \nansi_colors_256 &lt;- function() {\n  # código para generar un vector que cubre 256 colores\n}\n\nLiteralmente, se usa el mismo código, simplemente se inserta en el cuerpo de una función sin argumentos (similar al ejemplo de shinybootstrap2). Cada referencia a, por ejemplo, el objeto ansi_colors_8 se reemplaza por una llamada a la función ansi_colors_8().\nLa conclusión principal es que las funciones que evalúan o exponen las capacidades de su paquete en el sistema de un usuario deben ejecutarse completamente en el sistema de su usuario. Es bastante fácil confiar accidentalmente en resultados que se almacenaron en caché en el momento de la compilación, muy posiblemente en una máquina diferente.\n\n6.4.3 Ejemplo: asignar un alias a una función\nUn último ejemplo muestra que, incluso si tiene cuidado de definir solo funciones debajo de R/, todavía hay algunas sutilezas a considerar. Imagine que desea que la función foo() en su paquete sea básicamente un alias para la función blah() de algún otro paquete, p.e. paqueteB. Quizás tengas la tentación de hacer esto:\n\nfoo &lt;- pkgB::blah\n\nSin embargo, esto hará que foo() en su paquete refleje la definición de pkgB::blah() en la versión presente en la máquina donde se compila el paquete binario (a menudo CRAN), en ese momento. Si se descubre un error en pkgB::blah() y posteriormente se corrige, su paquete seguirá usando la versión anterior con errores, hasta que su paquete sea reconstruido (a menudo mediante CRAN) y sus usuarios actualicen, lo cual está completamente fuera de su alcance. Este enfoque alternativo lo protege de esto:\n\nfoo &lt;- function(...) pkgB::blah(...)\n\nAhora, cuando su usuario llama a foo(), efectivamente está llamando a pkgB::blah(), en la versión instalada en su máquina en ese mismo momento.\nUn ejemplo real de esto afectó a una versión anterior de knitr, relacionado con cómo el gancho “evaluar” predeterminado se estaba configurando en evaluate::evaluate() (el problema original es yihui/knitr#1441, resuelto en commit d6b53e0).",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#sec-code-r-landscape",
    "href": "code.html#sec-code-r-landscape",
    "title": "6  Código R",
    "section": "\n6.5 Respeta el paisaje de R",
    "text": "6.5 Respeta el paisaje de R\nOtra gran diferencia entre un script y un paquete es que otras personas usarán tu paquete y lo usarán en situaciones que nunca imaginaste. Esto significa que debe prestar atención al panorama de R, que incluye no sólo las funciones y objetos disponibles, sino también todas las configuraciones globales.\nHa cambiado el panorama de R si ha cargado un paquete con library(), o ha cambiado una opción global con options(), o ha modificado el directorio de trabajo con setwd(). Si el comportamiento de otras funciones difiere antes y después de ejecutar su función, ha modificado el panorama. Sección 5.7 tiene un ejemplo concreto de esto que involucra zonas horarias y la impresión de fechas y horas específicas de la localidad. Cambiar el panorama es malo porque hace que el código sea mucho más difícil de entender.\nHay algunas funciones que modifican la configuración global que nunca debes usar porque existen mejores alternativas:\n\nNo use library() o require(). Estos modifican la ruta de búsqueda, afectando las funciones que están disponibles en el entorno global. En su lugar, debe utilizar la DESCRIPTION para especificar los requisitos de su paquete, como se describe en Capítulo 9. Esto también garantiza que esos paquetes se instalen cuando se instala su paquete.\nNunca use source() para cargar código desde un archivo. source() modifica el entorno actual, insertando los resultados de la ejecución del código. No hay ninguna razón para usar source() dentro de su paquete, es decir, en un archivo debajo de R/. A veces la gente usa archivos source() debajo de R/ durante el desarrollo del paquete, pero como hemos explicado en Sección 4.4 and Sección 6.2, load_all() es una manera mucho mejor de cargar su código actual para explorarlo. Si está utilizando source() para crear un conjunto de datos, es mejor usar los métodos en Capítulo 7 para incluir datos en un paquete.\n\nA continuación se incluye una lista no exhaustiva de otras funciones que se deben utilizar con precaución:\n\noptions()\npar()\nsetwd()\nSys.setenv()\nSys.setlocale()\n\nset.seed() (o cualquier cosa que cambie el estado del generador de números aleatorios)\n\nSi debe usarlos, asegúrese de limpiarlo usted mismo. A continuación mostramos cómo hacer esto usando funciones del paquete withr y en base R.\nLa otra cara de esta moneda es que debes evitar confiar en el panorama del usuario, que podría ser diferente al tuyo. Por ejemplo, las funciones que dependen de la clasificación de cadenas son peligrosas, porque el orden de clasificación depende de la configuración regional del sistema. A continuación vemos que las configuraciones regionales que uno puede encontrar en la práctica (C, inglés, francés, etc.) difieren en la forma en que clasifican las cadenas que no son ASCII o las letras mayúsculas versus minúsculas.\n\nx &lt;- c(\"bernard\", \"bérénice\", \"béatrice\", \"boris\")\n\nwithr::with_locale(c(LC_COLLATE = \"fr_FR\"), sort(x))\n#&gt; Warning in (function (category = \"LC_ALL\", locale = \"\") : OS\n#&gt; reports request to set locale to \"fr_FR\" cannot be honored\n#&gt; [1] \"béatrice\" \"bérénice\" \"bernard\"  \"boris\"\nwithr::with_locale(c(LC_COLLATE = \"C\"), sort(x))\n#&gt; [1] \"bernard\"  \"boris\"    \"béatrice\" \"bérénice\"\n\nx &lt;- c(\"a\", \"A\", \"B\", \"b\", \"A\", \"b\")\n\nwithr::with_locale(c(LC_COLLATE = \"en_CA\"), sort(x))\n#&gt; Warning in (function (category = \"LC_ALL\", locale = \"\") : OS\n#&gt; reports request to set locale to \"en_CA\" cannot be honored\n#&gt; [1] \"a\" \"A\" \"A\" \"b\" \"b\" \"B\"\nwithr::with_locale(c(LC_COLLATE = \"C\"), sort(x))\n#&gt; [1] \"A\" \"A\" \"B\" \"a\" \"b\" \"b\"\n\nSi escribe sus funciones como si todos los usuarios tuvieran la misma configuración regional del sistema que usted, su código podría fallar.\n\n6.5.1 Administrar estado con withr\nSi necesita modificar el paisaje de R dentro de una función, entonces es importante asegurarse de que el cambio se revierta al salir de esa función. Esto es exactamente para lo que está diseñado base::on.exit(). Utiliza on.exit() dentro de una función para registrar el código para ejecutarlo más tarde, lo que restaura el paisaje a su estado original. Es importante tener en cuenta que las herramientas adecuadas, como on.exit(), funcionan incluso si salimos de la función de forma anormal, es decir, debido a un error. Es por eso que vale la pena utilizar los métodos oficiales descritos aquí en lugar de cualquier solución que pueda hacer usted mismo.\nGeneralmente administramos el estado usando el paquete withr, que proporciona un kit de herramientas flexible similar a on.exit() (on.exit() en sí está cubierto en la siguiente sección). withr::defer() se puede utilizar como reemplazo directo de on.exit(). ¿Por qué nos gusta tanto? En primer lugar, ofrece muchas funciones de conveniencia prediseñadas para cambios de estado que surgen con frecuencia. También apreciamos el comportamiento de pila predeterminado de withr (LIFO = último en entrar, primero en salir), su usabilidad en sesiones interactivas y su argumento envir (en uso más avanzado).\nEl patrón general es capturar el estado original, programar su eventual restauración “al salir” y luego realizar el cambio de estado. Algunos definidores, como options() o par(), devuelven el valor anterior cuando proporcionas un valor nuevo, lo que lleva a un uso similar al siguiente:\n\nf &lt;- function(x, y, z) {\n  ...                        # width option \"as found\"\n  old &lt;- options(width = 20) # width option is 20\n  defer(options(old))        # width option is 20\n  ...                        # width option is 20\n}                            # original width option restored\n\nCiertos cambios de estado, como la modificación de las opciones de sesión, surgen con tanta frecuencia que ofrece ayudas prediseñadas. Tabla 6.2 muestra algunos de los asistentes de cambio de estado que probablemente le resulten útiles:\n\n\nTabla 6.2: Establecer un parámetro de gráficos withr.\n\n\n\n\n\n\n\nHacer/deshacer esto\nwithr funciones\n\n\n\nEstablecer una opción R\n\nwith_options(), local_options()\n\n\n\nEstablecer una variable de entorno\n\nwith_envvar(), local_envvar()\n\n\n\nCambiar directorio de trabajo\n\nwith_dir(), local_dir()\n\n\n\nEstablecer un parámetro de gráficos\n\nwith_par(), local_par()\n\n\n\n\n\n\n\nNotarás que cada ayuda viene en dos formas que son útiles en diferentes situaciones:\n\n\nwith_*() Las funciones son mejores para ejecutar pequeños fragmentos de código con un estado modificado temporalmente. (Estas funciones están inspiradas en cómo funciona base::with()).\n\nf &lt;- function(x, sig_digits) {\n  # imagina mucho código aquí\n  withr::with_options(\n    list(digits = sig_digits),\n    print(x)\n  )\n  # ... y mucho más código aquí\n}\n\n\n\nlocal_*() Las funciones son mejores para modificar el estado “desde ahora hasta que la función salga”.\n\ng &lt;- function(x, sig_digits) {\n  withr::local_options(list(digits = sig_digits))\n  print(x)\n  # imagina mucho código aquí\n}\n\n\n\nDesarrollar código de forma interactiva con withr es agradable, porque se pueden programar acciones diferidas incluso en el entorno global. Esas acciones de limpieza pueden luego ejecutarse con withr::deferred_run() o borrarse sin ejecución con withr::deferred_clear(). Sin esta característica, puede ser complicado experimentar con código que necesita limpieza “al salir”, porque se comporta de manera muy diferente cuando se ejecuta en la consola que cuando se ejecuta con el brazo extendido dentro de una función.\nSe brinda una cobertura más detallada en la viñeta de withr [Cambiando y restaurando el estado] (https://withr.r-lib.org/articles/changing-and-restoring-state.html) y withr también resultará útil cuando hablar sobre pruebas en Capítulo 13.\n\n6.5.2 Restaurar el estado con base::on.exit()\n\nAsí es como se ve el patrón general “guardar, programar restauración, cambiar” cuando se usa base::on.exit().\n\nf &lt;- function(x, y, z) {\n  ...\n  old &lt;- options(mfrow = c(2, 2), pty = \"s\")\n  on.exit(options(old), add = TRUE)\n  ...\n}\n\nOtros cambios de estado no están disponibles con ese tipo de configurador y debe implementarlos usted mismo.\n\ng &lt;- function(a, b, c) {\n  ...\n  scratch_file &lt;- tempfile()\n  on.exit(unlink(scratch_file), add = TRUE)\n  file.create(scratch_file)\n  ...\n}\n\nTenga en cuenta que especificamos on.exit(..., add = TRUE), porque casi siempre desea este comportamiento, es decir, agregar a la lista de tareas de limpieza diferidas en lugar de reemplazarlas por completo. Esto (y el valor predeterminado de después) están relacionados con nuestra preferencia por withr::defer(), cuando estamos dispuestos a depender de withr. Estas cuestiones se exploran en una viñeta withr.\n\n6.5.3 Aislar los efectos secundarios\nCrear gráficos e imprimir resultados en la consola son otras dos formas de afectar el entorno global de R. A menudo no puedes evitarlos (¡porque son importantes!), pero es una buena práctica aislarlos en funciones que sólo producen resultados. Esto también facilita que otras personas reutilicen su trabajo para nuevos usos. Por ejemplo, si separa la preparación de datos y el trazado en dos funciones, otros pueden usar su trabajo de preparación de datos (¡que suele ser la parte más difícil!) para crear nuevas visualizaciones.\n\n6.5.4 Cuando sí necesitas efectos secundarios\nEn ocasiones, los paquetes necesitan efectos secundarios. Esto es más común si su paquete se comunica con un sistema externo; es posible que necesite realizar alguna configuración inicial cuando se carga el paquete. Para hacer eso, puede usar dos funciones especiales: .onLoad() y .onAttach(). Estos se llaman cuando el paquete se carga y adjunta. Aprenderá sobre la distinción entre los dos en Sección 10.4. Por ahora, siempre debes usar .onLoad() a menos que se indique explícitamente lo contrario.\nAlgunos usos comunes de .onLoad() y .onAttach() son:\n\n\nPara configurar opciones personalizadas para su paquete con opciones(). Para evitar conflictos con otros paquetes, asegúrese de anteponer los nombres de las opciones al nombre de su paquete. También tenga cuidado de no anular las opciones que el usuario ya haya configurado. Aquí hay una versión (altamente redactada) de la función .onLoad() de dplyr que establece una opción que controla los informes de progreso:\n\n.onLoad &lt;- function(libname, pkgname) {\n  op &lt;- options()\n  op.dplyr &lt;- list(\n    dplyr.show_progress = TRUE\n  )\n  toset &lt;- !(names(op.dplyr) %in% names(op))\n  if (any(toset)) options(op.dplyr[toset])\n\n  invisible()\n}\n\nEsto permite que las funciones en dplyr usen getOption(\"dplyr.show_progress\") para determinar si se muestran barras de progreso, basándose en el hecho de que ya se ha establecido un valor predeterminado sensato.\n\n\n\nPara mostrar un mensaje informativo cuando se adjunta el paquete. Esto podría aclarar las condiciones de uso o mostrar las capacidades del paquete según las condiciones actuales del sistema. Los mensajes de inicio son un lugar donde debes usar .onAttach() en lugar de .onLoad(). Para mostrar mensajes de inicio, utilice siempre packageStartupMessage(), y no message(). (Esto permite que suppressPackageStartupMessages() suprima selectivamente los mensajes de inicio del paquete).\n\n\n.onAttach &lt;- function(libname, pkgname) {\n  packageStartupMessage(\"Welcome to my package\")\n}\n\nComo puede ver en los ejemplos, .onLoad() y .onAttach() se llaman con dos argumentos: libname y pkgname. Rara vez se usan (son un vestigio de los días en que necesitabas usar library.dynam() para cargar código compilado). Proporcionan la ruta donde está instalado el paquete (la “biblioteca”) y el nombre del paquete.\nSi usa .onLoad(), considere usar .onUnload() para limpiar cualquier efecto secundario. Por convención, .onLoad() y sus amigos generalmente se guardan en un archivo llamado R/zzz.R. (Tenga en cuenta que .First.lib() y .Last.lib() son versiones antiguas de .onLoad() y .onUnload() y ya no deben usarse).\nUna cosa especialmente complicada de hacer en una función como .onLoad() o .onAttach() es cambiar el estado del generador de números aleatorios. Érase una vez, ggplot2 usaba sample() para decidir si mostrar un mensaje de inicio, pero solo en sesiones interactivas. Esto, a su vez, creó un rompecabezas de reproducibilidad para los usuarios que usaban set.seed() para sus propios fines, antes de adjuntar ggplot2 con library(ggplot2) y ejecutar el código tanto de forma interactiva como no interactiva. La solución elegida fue envolver el código de inicio ofensivo dentro de withr::with_preserve_seed(), lo que deja la semilla aleatoria del usuario tal como la encontró.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#controles-de-salud-constantes",
    "href": "code.html#controles-de-salud-constantes",
    "title": "6  Código R",
    "section": "\n6.6 Controles de salud constantes",
    "text": "6.6 Controles de salud constantes\nA continuación se muestra una secuencia típica de llamadas cuando se utilizan devtools para el desarrollo de paquetes:\n\nEdite uno o más archivos debajo de R/.\n\ndocument() (si ha realizado algún cambio que afecte los archivos de ayuda o NAMESPACE)\nload_all()\nEjecute algunos ejemplos de forma interactiva.\n\ntest() (o test_active_file())\ncheck()\n\nUna pregunta interesante es con qué frecuencia y rapidez se avanza en este ciclo de desarrollo. A menudo nos encontramos ejecutando la secuencia anterior varias veces en una hora o en un día mientras agregamos o modificamos una sola función.\nAquellos nuevos en el desarrollo de paquetes pueden sentirse más cómodos lanzando código R y mucho menos cómodos escribiendo y compilando documentación, simulando la construcción e instalación de paquetes, probando y ejecutando R CMD check. Y es parte de la naturaleza humana abrazar lo familiar y posponer lo desconocido. Esto a menudo conduce a un flujo de trabajo disfuncional en el que la secuencia completa anterior se desarrolla con poca frecuencia, tal vez una vez al mes o cada dos meses, muy lentamente y a menudo con mucho dolor:\n\nEdite uno o más archivos debajo de R/.\nCompile, instale y utilice el paquete. Iterar ocasionalmente con el paso anterior.\nEscriba la documentación (una vez que el código esté “listo”).\nEscriba pruebas (una vez que el código esté “listo”).\nEjecute R CMD check justo antes de enviarlo a CRAN o liberarlo de alguna otra manera.\n\nYa hemos hablado sobre el valor de la retroalimentación rápida, en el contexto de load_all(). Pero esto también se aplica a la ejecución de document(), test() y check(). Hay defectos que simplemente no puedes detectar al usar load_all() y ejecutar algunos ejemplos interactivos que se revelan inmediatamente mediante comprobaciones más formales. Encontrar y corregir 5 errores, uno a la vez, justo después de crear cada uno, es mucho más fácil que solucionar los 5 a la vez (posiblemente interactuando entre sí), semanas o meses después de la última vez que tocó el código.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nSi planea enviar su paquete a CRAN, debe usar solo caracteres ASCII en sus archivos .R. En la práctica, esto significa que está limitado a los dígitos del 0 al 9, las letras minúsculas de la “a” a la “z”, las letras mayúsculas de la “A” a la “Z” y la puntuación común.\nPero a veces es necesario insertar una pequeña cantidad de datos de caracteres que incluyen, por ejemplo, una letra griega (µ), un carácter acentuado (ü) o un símbolo (30°). Puede utilizar cualquier carácter Unicode siempre que lo especifique en el formato especial de escape Unicode \"\\u1234\". La forma más sencilla de encontrar el punto de código correcto es utilizar stringi::stri_escape_unicode():\n\nx &lt;- \"Esto es un punto •\"\ny &lt;- \"Esto es un punto \\u2022\"\nidentical(x, y)\n#&gt; [1] TRUE\ncat(stringi::stri_escape_unicode(x))\n#&gt; Esto es un punto \\u2022\n\nA veces tienes el problema opuesto. No tienes intencionalmente ningún carácter que no sea ASCII en tu código R, pero las comprobaciones automáticas revelan que sí los tienes.\nW  checking R files for non-ASCII characters ...\n   Found the following file with non-ASCII characters:\n     foo.R\n   Portable packages must use only ASCII characters in their R code,\n   except perhaps in comments.\n   Use \\uxxxx escapes for other characters.\nLos infractores más comunes son las comillas simples y dobles “rizadas” o “inteligentes” que se cuelan al copiar y pegar. Las funciones tools::showNonASCII() y tools::showNonASCIIfile(file) le ayudan a encontrar los archivos y líneas infractores.\n\ntools::showNonASCIIfile(\"R/foo.R\")\n#&gt; 666: #' If you&lt;e2&gt;&lt;80&gt;&lt;99&gt;ve copy/pasted quotes, watch out!",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "code.html#footnotes",
    "href": "code.html#footnotes",
    "title": "6  Código R",
    "section": "",
    "text": "Desafortunadamente no puedes usar subdirectorios dentro de R/. La mejor opción es utilizar un prefijo común, por ejemplo, abc-*.R, para indicar que un grupo de archivos está relacionado.↩︎\nConsulte el Flujo de trabajo de comandos en Acciones de GitHub para el lenguaje R repositorio.↩︎\nLa publicación del blog Robot Pedantry, Human Empathy de Mike McQuaid hace un excelente trabajo al resumir los beneficios de automatizar tareas como la recodificación de código. -peinado.↩︎",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Código R</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "7  Datos",
    "section": "",
    "text": "7.1 Datos exportados\nA menudo resulta útil incluir datos en un paquete. Si el objetivo principal de un paquete es distribuir funciones útiles, los conjuntos de datos de ejemplo facilitan la redacción de documentación excelente. Estos conjuntos de datos se pueden crear a mano para proporcionar casos de uso atractivos para las funciones del paquete. A continuación se muestran algunos ejemplos de este tipo de datos de paquete:\nEn el otro extremo, algunos paquetes existen únicamente con el fin de distribuir datos, junto con su documentación. A veces se les llama “paquetes de datos”. Un paquete de datos puede ser una buena forma de compartir datos de ejemplo entre varios paquetes. También es una técnica útil para obtener archivos estáticos relativamente grandes de un paquete más orientado a funciones, que podría requerir actualizaciones más frecuentes. A continuación se muestran algunos ejemplos de paquetes de datos:\nPor último, muchos paquetes se benefician de tener datos internos que se utilizan para fines internos, pero que no están expuestos directamente a los usuarios del paquete.\nEn este capítulo describimos mecanismos útiles para incluir datos en su paquete. Los detalles prácticos difieren según quién necesita acceso a los datos, con qué frecuencia cambian y qué harán con ellos:\nLa ubicación más común para los datos del paquete es (¡sorpresa!) data/. Recomendamos que cada archivo en este directorio sea un archivo .rda creado por save() que contenga un único objeto R, con el mismo nombre que el archivo. La forma más sencilla de lograrlo es utilizar usethis::use_data().\nmy_pkg_data &lt;- sample(1000)\nusethis::use_data(my_pkg_data)\nImaginemos que estamos trabajando en un paquete llamado “pkg”. El fragmento anterior crea data/my_pkg_data.rda dentro del código fuente del paquete pkg y agrega LazyData: true en su DESCRIPCIÓN. Esto hace que el objeto R my_pkg_data esté disponible para los usuarios de pkg a través de pkg::my_pkg_data o, después de adjuntar pkg con library(pkg), como my_pkg_data.\nEl fragmento anterior es algo que el mantenedor ejecuta una vez (o cada vez que necesita actualizar my_pkg_data). Este es el código de flujo de trabajo y no debería aparecer en el directorio R/ del paquete fuente. (Hablaremos sobre un lugar adecuado para guardar este código a continuación). Para conjuntos de datos más grandes, es posible que desees experimentar con la configuración de compresión, que está bajo el control del argumento “comprimir”. El valor predeterminado es “bzip2”, pero a veces “gzip” o “xz” pueden crear archivos más pequeños.\nEs posible utilizar otros tipos de archivos debajo de data/, pero no lo recomendamos porque los archivos .rda ya son rápidos, pequeños y explícitos. Las otras posibilidades se describen en la documentación de utils::data() y en Datos en paquetes de Escritura de extensiones R. En términos de consejos para los autores de paquetes, el tema de ayuda para data() parece hacer implícitamente las mismas recomendaciones que hacemos anteriormente:\nSi la DESCRIPTION contiene LazyData: true, los conjuntos de datos se cargarán de forma diferida. Esto significa que no ocuparán memoria hasta que los uses. El siguiente ejemplo muestra el uso de la memoria antes y después de cargar el paquete nycflights13. Puede ver que el uso de la memoria no cambia significativamente hasta que inspecciona el conjunto de datos de flights almacenados dentro del paquete.\nlobstr::mem_used()\n#&gt; 74.66 MB\nlibrary(nycflights13)\nlobstr::mem_used()\n#&gt; 76.39 MB\n\ninvisible(flights)\nlobstr::mem_used()\n#&gt; 117.09 MB\nLe recomendamos que incluya LazyData: true en su DESCRIPTION si envía archivos .rda debajo de data/. Si utiliza use_data() para crear dichos conjuntos de datos, automáticamente realizará esta modificación en DESCRIPTION por usted.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-data",
    "href": "data.html#sec-data-data",
    "title": "7  Datos",
    "section": "",
    "text": "Almacene un objeto R en cada archivo data/*.rda\n\nUtilice el mismo nombre para ese objeto y su archivo .rda\n\nUtilice carga diferida, de forma predeterminada\n\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEs importante tener en cuenta que los conjuntos de datos cargados de forma diferida no necesitan estar precargados con utils::data() y, de hecho, normalmente es mejor evitar hacerlo. Arriba, una vez que hicimos library(nycflights13), pudimos acceder inmediatamente a flights. No hay llamada a datos(flights), porque no es necesario.\nHay desventajas específicas de las llamadas data(some_pkg_data) que admiten una política de usar data() solo cuando es realmente necesario, es decir, para conjuntos de datos que de otro modo no estarían disponibles:\n\nDe forma predeterminada, data(some_pkg_data) crea uno o más objetos en el espacio de trabajo global del usuario. Existe la posibilidad de sobrescribir silenciosamente objetos preexistentes con nuevos valores.\nTampoco hay garantía de que data(foo) cree exactamente un objeto llamado “foo”. Podría crear más de un objeto y/u objetos con nombres totalmente diferentes.\n\nUn argumento a favor de llamadas como data(some_pkg_data, package = \"pkg\") que no son estrictamente necesarias es que aclara qué paquete proporciona some_pkg_data. Preferimos alternativas que no modifiquen el espacio de trabajo global, como un comentario de código o el acceso a través de pkg::some_pkg_data.\nEste extracto de la documentación de data() transmite que es en gran medida de importancia histórica:\n\ndata() Originalmente estaba destinado a permitir a los usuarios cargar conjuntos de datos desde paquetes para usarlos en sus ejemplos y, como tal, cargaba los conjuntos de datos en el espacio de trabajo. .GlobalEnv. Esto evitó tener grandes conjuntos de datos en la memoria cuando no estaban en uso: esa necesidad ha sido reemplazada casi por completo por la carga diferida de conjuntos de datos.\n\n\n\n\n7.1.1 Preservar la historia del origen de los datos del paquete\nA menudo, los datos que incluye en data/ son una versión limpia de datos sin procesar que ha recopilado de otro lugar. Recomendamos encarecidamente tomarse el tiempo para incluir el código utilizado para hacer esto en la versión fuente de su paquete. Esto le facilita actualizar o reproducir su versión de los datos. Este script de creación de datos también es un lugar natural para dejar comentarios sobre propiedades importantes de los datos, es decir, qué características son importantes para el uso posterior en la documentación del paquete.\nLe sugerimos que mantenga este código en uno o más archivos .R debajo de data-raw/. No lo desea en la versión incluida de su paquete, por lo que esta carpeta debe aparecer en .Rbuildignore. usethis tiene una función conveniente que se puede llamar cuando adopta por primera vez la práctica data-raw/ o cuando agrega un archivo .R adicional a la carpeta:\n\nusethis::use_data_raw()\n\nusethis::use_data_raw(\"my_pkg_data\")\n\nuse_data_raw() crea la carpeta data-raw/ y la enumera en .Rbuildignore. Un script típico en data-raw/ incluye código para preparar un conjunto de datos y termina con una llamada a use_data().\nTodos estos paquetes de datos utilizan el enfoque recomendado aquí para data-raw/:\n\nbabynames\nnycflights13\ngapminder\n\n\n\n\n\n\n\nggplot2: Un cuento con moraleja\n\n\n\nTenemos una confesión que hacer: los orígenes de muchos de los conjuntos de datos de ejemplo de ggplot2 se han perdido en las arenas del tiempo. En el gran esquema de las cosas, esto no es un gran problema, pero el mantenimiento es ciertamente más placentero cuando los activos de un paquete pueden reconstruirse de novo y actualizarse fácilmente según sea necesario.\n\n\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nGeneralmente, los datos del paquete deben ser más pequeños que un megabyte; si son más grandes, deberá solicitar una exención. Esto suele ser más fácil de hacer si los datos están en su propio paquete y no se actualizarán con frecuencia, es decir, si lo aborda como un “paquete de datos” dedicado. Como referencia, los paquetes babynames y nycflights se han lanzado una vez cada uno o dos años, desde que aparecieron por primera vez en CRAN.\nSi tiene problemas de tamaño, debe ser intencional con respecto al método de compresión de datos. El valor predeterminado para usethis::use_data(compress =) es “bzip2”, mientras que el valor predeterminado para save(compress =) es (efectivamente) “gzip”, y “xz” es otra opción válida.\nTendrás que experimentar con diferentes métodos de compresión y tomar esta decisión de forma empírica. tools::resaveRdaFiles(\"data/\") automatiza este proceso, pero no le informa qué método de compresión se eligió. Puede aprender esto después del hecho con tools::checkRdaFiles(). Suponiendo que está realizando un seguimiento del código para generar sus datos, sería prudente actualizar la llamada use_data(compress =) correspondiente debajo de data-raw/ y volver a generar el .rda limpiamente.\n\n\n\n7.1.2 Documentar conjuntos de datos\nLos objetos en data/ siempre se exportan efectivamente (utilizan un mecanismo ligeramente diferente al de NAMESPACE pero los detalles no son importantes). Esto significa que deben estar documentados. Documentar datos es como documentar una función con algunas diferencias menores. En lugar de documentar los datos directamente, documenta el nombre del conjunto de datos y lo guarda en R/. Por ejemplo, el bloque roxygen2 utilizado para documentar los datos quién(who) en tidyr se guarda en R/data.R y se parece a esto:\n\n#' Datos sobre tuberculosis de la Organización Mundial de la Salud\n#'\n#' Un subconjunto de datos de un Informe de la Tuberculosis Global de la \n#' Organización Mundial de la Salud ...\n#'\n#' @format ## `who`\n#' Un marco de datos con 7240 filas y 60 columnas:\n#' \\describe{\n#'   \\item{country}{Country name}\n#'   \\item{iso2, iso3}{2 & 3 letter ISO country codes}\n#'   \\item{year}{Year}\n#'   ...\n#' }\n#' @source &lt;https://www.who.int/teams/global-tuberculosis-programme/data&gt;\n\"who\"\n\nHay dos etiquetas roxygen que son especialmente importantes para documentar conjuntos de datos:\n\n@format ofrece una visión general del conjunto de datos. Para los marcos de datos, debe incluir una lista de definiciones que describa cada variable. Generalmente es una buena idea describir aquí las unidades de las variables.\n@source proporciona detalles de dónde obtuvo los datos, a menudo una URL.\n\nNunca @export un conjunto de datos.\n\n7.1.3 Caracteres no ASCII en datos\nLos objetos R que almacena en data/*.rda a menudo contienen cadenas, siendo el ejemplo más común las columnas de caracteres en un marco de datos. Si puede restringir estas cadenas para que utilicen únicamente caracteres ASCII, ciertamente simplificará las cosas. Pero, por supuesto, existen muchas razones legítimas por las que los datos del paquete pueden incluir caracteres que no son ASCII.\nEn ese caso, le recomendamos que adopte el manifiesto UTF-8 Everywhere y utilice la codificación UTF-8. El archivo DESCRIPCIÓN colocado por usethis::create_package() siempre incluye Encoding: UTF-8, por lo que, de forma predeterminada, un paquete producido por devtools ya anuncia que usará UTF-8.\nAsegurarse de que las cadenas incrustadas en los datos de su paquete tengan la codificación deseada es algo que debe lograr en su código de preparación de datos, es decir, en los scripts de R debajo de data-raw/. Puede usar Encoding() para conocer la codificación actual de los elementos en un vector de caracteres y funciones como enc2utf8() o iconv() para convertir entre codificaciones.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nSi tiene cadenas codificadas en UTF-8 en los datos de su paquete, puede ver esto desde R CMD check:\n-   checking data for non-ASCII characters ... NOTE\n    Note: found 352 marked UTF-8 strings\nEsta NOTA es verdaderamente informativa. No requiere ninguna acción por su parte. Siempre que realmente desee tener cadenas UTF-8 en los datos de su paquete, todo está bien.\nIrónicamente, esta NOTA en realidad es suprimida por R CMD check --as-cran, a pesar de que esta nota aparece en los resultados de la verificación una vez que un paquete está en CRAN (lo que implica que CRAN no necesariamente verifica con --as-cran). De forma predeterminada, devtools::check() establece el indicador --as-cran y por lo tanto no transmite esta NOTA. Pero puedes sacarlo a la superficie con check(cran = FALSE, env_vars = c(\"_R_CHECK_PACKAGE_DATASETS_SUPPRESS_NOTES_\" = \"false\")).",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-sysdata",
    "href": "data.html#sec-data-sysdata",
    "title": "7  Datos",
    "section": "\n7.2 Datos internos",
    "text": "7.2 Datos internos\nA veces, las funciones de su paquete necesitan acceso a datos precalculados. Si coloca estos objetos en data/, también estarán disponibles para los usuarios del paquete, lo cual no es apropiado. A veces, los objetos que necesitas son lo suficientemente pequeños y simples como para poder definirlos con c() o data.frame() en el código debajo de R/, tal vez en R/data.R. Los objetos más grandes o más complicados deben almacenarse en los datos internos de su paquete en R/sysdata.rda, para que se carguen de forma diferida según demanda.\nA continuación se muestran algunos ejemplos de datos de paquetes internos:\n\nDos paquetes relacionados con el color, munsell y dichromat, utilice R/sysdata.rda para almacenar grandes tablas de datos de color.\n\ngoogledrive y googlesheets4 envuelva las API de Google Drive y Google Sheets, respectivamente. Ambos usan R/sysdata.rda para almacenar datos derivados del llamado Documento de descubrimiento que “describe la superficie de la API, cómo acceder a la API y cómo se estructuran las solicitudes y respuestas de la API”.\n\nLa forma más sencilla de crear R/sysdata.rda es utilizar usethis::use_data(internal = TRUE):\n\ninternal_this &lt;- ...\ninternal_that &lt;- ...\n\nusethis::use_data(internal_this, internal_that, internal = TRUE)\n\nA diferencia de data/, donde se utiliza un archivo .rda por objeto de datos exportado, se almacenan todos los objetos de datos internos juntos en un único archivo. R/sysdata.rda.\nImaginemos que estamos trabajando en un paquete llamado “pkg”. El fragmento anterior crea R/sysdata.rda dentro del código fuente del paquete pkg. Esto hace que los objetos internal_this e internal_that estén disponibles para su uso dentro de las funciones definidas debajo de R/ y en las pruebas. Durante el desarrollo interactivo, internal_this e internal_that están disponibles después de una llamada a devtools::load_all(), como una función interna.\nGran parte de los consejos dados para los datos externos también se aplican a los datos internos:\n\nEs una buena idea almacenar el código que genera sus objetos de datos internos individuales, así como la llamada use_data() que los escribe todos en R/sysdata.rda. Este es el código de flujo de trabajo que pertenece debajo de data-raw/, no debajo de R/.\n\nusethis::use_data_raw() se puede utilizar para iniciar el uso de data-raw/ o para iniciar un nuevo script .R allí.\nSi su paquete es demasiado grande, experimente con diferentes valores de compress en use_data(internal = TRUE).\n\nTambién existen distinciones clave en las que difiere el manejo de datos internos y externos:\n\nLos objetos en R/sysdata.rda no se exportan (no deberían exportarse), por lo que no es necesario documentarlos.\nEl campo LazyData en el paquete DESCRIPTION no tiene ningún impacto en R/sysdata.rda pero se refiere estrictamente a los datos exportados debajo de data/. Los datos internos siempre se cargan de forma diferida.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-extdata",
    "href": "data.html#sec-data-extdata",
    "title": "7  Datos",
    "section": "\n7.3 Archivo de datos sin procesar",
    "text": "7.3 Archivo de datos sin procesar\nSi desea mostrar ejemplos de carga/análisis de datos sin procesar, coloque los archivos originales en inst/extdata/. Cuando se instala el paquete, todos los archivos (y carpetas) en inst/ se mueven hacia arriba un nivel hasta el directorio de nivel superior, por lo que no pueden tener nombres que entren en conflicto con las partes estándar de un paquete R, como R/ o DESCRIPTION . Los archivos debajo de inst/extdata/ en el paquete fuente se ubicarán debajo de extdata/ en el paquete instalado correspondiente. Es posible que desee volver a visitar Figura 3.1 para revisar la estructura de archivos para los diferentes estados del paquete.\nLa razón principal para incluir dichos archivos es cuando una parte clave de la funcionalidad de un paquete es actuar sobre un archivo externo. Ejemplos de dichos paquetes incluyen:\n\nreadr, que lee datos rectangulares de archivos delimitados\nreadxl, que lee datos rectangulares de hojas de cálculo de Excel\nxml2, que puede leer XML y HTML desde un archivo\narchive, que puede leer archivos comprimidos, como tar o ZIP\n\nTodos estos paquetes tienen uno o más archivos de ejemplo debajo de inst/extdata/, que son útiles para escribir documentación y pruebas.\nTambién es común que los paquetes de datos proporcionen, por ejemplo, una versión csv de los datos del paquete que también se proporciona como un objeto R. Ejemplos de dichos paquetes incluyen:\n\npalmerpenguins: penguins y penguins_raw también se representan como extdata/penguins.csv y extdata/penguins_raw.csv\n\ngapminder: gapminder, continent_colors, y country_colors también se representan como extdata/gapminder.tsv, extdata/continent-colors.tsv, y extdata/country-colors.tsv\n\n\nEsto tiene dos beneficios: en primer lugar, les da a los profesores y otros expositores más con qué trabajar una vez que deciden utilizar un conjunto de datos específico. Si has empezado a enseñar R con palmerpenguins::penguins o gapminder::gapminder y desea introducir la importación de datos, puede ser útil para los estudiantes si utilizan por primera vez un comando nuevo, como readr::read_csv() o read.csv(), se aplica a un conjunto de datos familiar. Tienen una intuición preexistente sobre el resultado esperado. Finalmente, si los datos del paquete evolucionan con el tiempo, tener un csv u otra representación de texto sin formato en el paquete fuente puede hacer que sea más fácil ver qué ha cambiado.\n\n7.3.1 Rutas de archivos\nLa ruta a un archivo de paquete que se encuentra debajo de extdata/ depende claramente del entorno local, es decir, depende de dónde se encuentran los paquetes instalados en esa máquina. La función base system.file() puede informar la ruta completa a los archivos distribuidos con un paquete R. También puede resultar útil enumerar los archivos distribuidos con un paquete R.\n\nsystem.file(\"extdata\", package = \"readxl\") |&gt; list.files()\n#&gt;  [1] \"clippy.xls\"    \"clippy.xlsx\"   \"datasets.xls\"  \"datasets.xlsx\"\n#&gt;  [5] \"deaths.xls\"    \"deaths.xlsx\"   \"geometry.xls\"  \"geometry.xlsx\"\n#&gt;  [9] \"type-me.xls\"   \"type-me.xlsx\"\n\nsystem.file(\"extdata\", \"clippy.xlsx\", package = \"readxl\")\n#&gt; [1] \"/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/readxl/extdata/clippy.xlsx\"\n\nEstas rutas de archivos presentan otro dilema en el flujo de trabajo: cuando estás desarrollando tu paquete, interactúas con él en su formato fuente, pero tus usuarios interactúan con él como un paquete instalado. Afortunadamente, devtools proporciona una corrección para base::system.file() que se activa mediante load_all(). Esto realiza llamadas interactivas a system.file() desde el entorno global y las llamadas desde dentro del espacio de nombres del paquete “simplemente funcionan”.\nTenga en cuenta que, de forma predeterminada, system.file() devuelve la cadena vacía, no un error, para un archivo que no existe.\n\nsystem.file(\"extdata\", \"I_do_not_exist.csv\", package = \"readr\")\n#&gt; [1] \"\"\n\nSi desea forzar un error en este caso, especifique mustWork = TRUE:\n\nsystem.file(\"extdata\", \"I_do_not_exist.csv\", package = \"readr\", mustWork = TRUE)\n#&gt; Error in system.file(\"extdata\", \"I_do_not_exist.csv\", package = \"readr\", : no file found\n\nEl paquete fs ofrece fs::path_package(). Esto es esencialmente base::system.file() con algunas características adicionales que consideramos ventajosas, siempre que sea razonable depender de fs:\n\nSe produce un error si la ruta del archivo no existe.\nGenera errores distintos cuando el paquete no existe versus cuando el archivo no existe dentro del paquete.\nDurante el desarrollo, funciona para llamadas interactivas, llamadas desde dentro del espacio de nombres del paquete cargado e incluso para llamadas que se originan en dependencias.\n\n\nfs::path_package(\"extdata\", package = \"idonotexist\")\n#&gt; Error: Can't find package `idonotexist` in library locations:\n#&gt;   - '/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu'\n#&gt;   - '/home/runner/.cache/R/renv/sandbox/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/3df92652'\n\nfs::path_package(\"extdata\", \"I_do_not_exist.csv\", package = \"readr\")\n#&gt; Error: File(s) '/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/readr/extdata/I_do_not_exist.csv' do not exist\n\nfs::path_package(\"extdata\", \"chickens.csv\", package = \"readr\")\n#&gt; /home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/readr/extdata/chickens.csv\n\n\n\n7.3.2 pkg_example() ayudantes de camino\nNos gusta ofrecer funciones convenientes que faciliten el acceso a los archivos de ejemplo. Estos son simplemente envoltorios fáciles de usar alrededor de system.file() o fs::path_package(), pero pueden tener características adicionales, como la capacidad de enumerar los archivos de ejemplo. Aquí está la definición y algunos usos de readxl::readxl_example():\n\nreadxl_example &lt;- function(path = NULL) {\n  if (is.null(path)) {\n    dir(system.file(\"extdata\", package = \"readxl\"))\n  } else {\n    system.file(\"extdata\", path, package = \"readxl\", mustWork = TRUE)\n  }\n}\n\n\nreadxl::readxl_example()\n#&gt;  [1] \"clippy.xls\"    \"clippy.xlsx\"   \"datasets.xls\"  \"datasets.xlsx\"\n#&gt;  [5] \"deaths.xls\"    \"deaths.xlsx\"   \"geometry.xls\"  \"geometry.xlsx\"\n#&gt;  [9] \"type-me.xls\"   \"type-me.xlsx\"\n\nreadxl::readxl_example(\"clippy.xlsx\")\n#&gt; [1] \"/home/runner/work/_temp/renv/cache/v5/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/readxl/1.4.3/8cf9c239b96df1bbb133b74aef77ad0a/readxl/extdata/clippy.xlsx\"",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-state",
    "href": "data.html#sec-data-state",
    "title": "7  Datos",
    "section": "\n7.4 Estado interno",
    "text": "7.4 Estado interno\nA veces hay información a la que varias funciones de su paquete necesitan acceder:\n\nDebe determinarse en el momento de la carga (o incluso más tarde), no en el momento de la compilación. Incluso podría ser dinámico.\nNo tiene sentido pasarlo mediante un argumento de función. A menudo se trata de algún detalle oscuro que el usuario ni siquiera debería conocer.\n\nUna excelente manera de administrar dichos datos es utilizar un entorno.1 Este entorno debe crearse en el momento de la compilación, pero puede completarlo con valores después de que se haya cargado el paquete y actualizar esos valores en el transcurso de una sesión de R. Esto funciona porque los entornos tienen una semántica de referencia (mientras que los objetos R más comunes, como vectores atómicos, listas o marcos de datos, tienen una semántica de valores).\nConsidere un paquete que pueda almacenar las letras o números favoritos del usuario. Podrías comenzar con un código como este en el archivo siguiente R/:\n\nfavorite_letters &lt;- letters[1:3]\n\n#' Reportar mis letras favoritas\n#' @export\nmfl &lt;- function() {\n  favorite_letters\n}\n\n#' Cambiar mis letras favoritas\n#' @export\nset_mfl &lt;- function(l = letters[24:26]) {\n  old &lt;- favorite_letters\n  favorite_letters &lt;&lt;- l\n  invisible(old)\n}\n\nfavorite_letters se inicializa en (“a”, “b”, “c”) cuando se crea el paquete. Luego, el usuario puede inspeccionar favorite_letters con mfl(), momento en el cual probablemente querrá registrar sus letras favoritas con set_mfl(). Tenga en cuenta que hemos utilizado el operador de superasignación &lt;&lt;- en set_mfl() con la esperanza de que llegue al entorno del paquete y modifique el objeto de datos interno favorite_letters. Pero una llamada a set_mfl() falla así:2\n\nmfl()\n#&gt; [1] \"a\" \"b\" \"c\"\n\nset_mfl(c(\"j\", \"f\", \"b\"))\n#&gt; Error in set_mfl() : \n#&gt;   cannot change value of locked binding for 'favorite_letters'\n\nDebido a que favorite_letters es un vector de caracteres normal, la modificación requiere hacer una copia y volver a vincular el nombre favorite_letters a este nuevo valor. Y eso es lo que no está permitido: no se puede cambiar el enlace de los objetos en el espacio de nombres del paquete (bueno, al menos no sin esforzarse más). Definir favorite_letters de esta manera solo funciona si nunca necesitarás modificarlo.\nSin embargo, si mantenemos el estado dentro de un entorno de paquete interno, podemos modificar los objetos contenidos en el entorno (e incluso agregar objetos completamente nuevos). Aquí hay una implementación alternativa que utiliza un entorno interno llamado “el”.\n\nthe &lt;- new.env(parent = emptyenv())\nthe$favorite_letters &lt;- letters[1:3]\n\n#' Reportar mis letras favoritas\n#' @export\nmfl2 &lt;- function() {\n  the$favorite_letters\n}\n\n#' Cambiar mis letras favoritas\n#' @export\nset_mfl2 &lt;- function(l = letters[24:26]) {\n  old &lt;- the$favorite_letters\n  the$favorite_letters &lt;- l\n  invisible(old)\n}\n\nAhora un usuario puede registrar sus letras favoritas:\n\nmfl2()\n#&gt; [1] \"a\" \"b\" \"c\"\n\nset_mfl2(c(\"j\", \"f\", \"b\"))\n\nmfl2()\n#&gt; [1] \"j\" \"f\" \"b\"\n\nTenga en cuenta que este nuevo valor para the$favorite_letters persiste solo durante el resto de la sesión actual de R (o hasta que el usuario llame a set_mfl2() nuevamente). Más precisamente, el estado alterado persiste sólo hasta la próxima vez que se carga el paquete (incluso a través de load_all()). En el momento de la carga, el entorno the se restablece a un entorno que contiene exactamente un objeto, llamado favorite_letters, con valor (“a”, “b”, “c”). Es como la película El día de la marmota. (Discutiremos datos más persistentes específicos de paquetes y usuarios en la siguiente sección).\nJim Hester presentó a nuestro grupo la ingeniosa idea de utilizar “el” como nombre de un entorno de paquete interno. Esto le permite referirse a los objetos internos de una manera muy natural, como the$token, que significa “the token”. También es importante especificar parent = vacíoenv() al definir un entorno interno, ya que generalmente no desea que el entorno herede de ningún otro entorno (no vacío).\nComo se ve en el ejemplo anterior, la definición del entorno debe realizarse como una asignación de nivel superior en un archivo debajo de R/. (En particular, esta es una razón legítima para definir una no función en el nivel superior de un paquete; consulte Sección 6.4 para saber por qué esto debería ser poco común). En cuanto a dónde colocar esta definición, hay dos consideraciones:\n\nDefínelo antes de usarlo. Si otras llamadas de nivel superior se refieren al entorno, la definición debe aparecer primero cuando el código del paquete se ejecuta en el momento de la compilación. Es por eso que R/aaa.R es una opción común y segura.\nFacilite su búsqueda más adelante cuando esté trabajando en funciones relacionadas. Si un entorno solo es utilizado por una familia de funciones, defínalo allí. Si el uso del entorno se distribuye alrededor del paquete, defínalo en un archivo con connotaciones para todo el paquete.\n\nA continuación se muestran algunos ejemplos de cómo los paquetes utilizan un entorno interno:\n\ngoogledrive: Varias funciones necesitan conocer el ID del archivo del directorio de inicio del usuario actual en Google Drive. Esto requiere una llamada API (una operación relativamente costosa y propensa a errores) que produce una cadena deslumbrante de ~40 caracteres aparentemente aleatorios que solo una computadora puede amar. Sería inhumano esperar que un usuario sepa esto o lo pase a cada función. También sería ineficiente redescubrir la identificación repetidamente. En cambio, Googledrive determina el ID cuando lo necesita por primera vez y luego lo almacena en caché para su uso posterior.\nusethis: La mayoría de las funciones necesitan conocer el proyecto activo, es decir, a qué directorio apuntar para modificar el archivo. Este suele ser el directorio de trabajo actual, pero no es un uso invariable en el que pueda confiar. Un diseño potencial es hacer posible especificar el proyecto de destino como argumento de cada función en uso. Pero esto crearía un desorden significativo en la interfaz de usuario, así como inquietud interna. En cambio, determinamos el proyecto activo en la primera necesidad, lo almacenamos en caché y proporcionamos métodos para (re)configurarlo.\n\nLa publicación del blog Variables de todo el paquete/Caché en paquetes R ofrece un desarrollo más detallado de esta técnica.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#sec-data-persistent",
    "href": "data.html#sec-data-persistent",
    "title": "7  Datos",
    "section": "\n7.5 Datos de usuario persistentes",
    "text": "7.5 Datos de usuario persistentes\nA veces hay datos que obtiene su paquete, en nombre de sí mismo o del usuario, que deberían persistir incluso entre sesiones de R. Esta es nuestra última forma y probablemente la menos común de almacenar datos de paquetes. Para que los datos persistan de esta manera, deben almacenarse en el disco y la gran pregunta es dónde escribir dicho archivo.\nEste problema no es exclusivo de R. Muchas aplicaciones necesitan dejar notas para sí mismas. Es mejor cumplir con convenciones externas, que en este caso significa la Especificación del directorio base XDG. Debe utilizar las ubicaciones oficiales para el almacenamiento persistente de archivos, porque es algo responsable y cortés y también para cumplir con las políticas de CRAN.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nNo se pueden simplemente escribir datos persistentes en el directorio de inicio del usuario. Aquí hay un extracto relevante de la política de CRAN al momento de escribir este artículo:\n\nLos paquetes no deben escribirse en el espacio de archivos de inicio del usuario (incluidos los portapapeles) ni en ningún otro lugar del sistema de archivos aparte del directorio temporal de la sesión de R. …\nPara R versión 4.0 o posterior (por lo tanto, se requiere una dependencia de versión o solo es posible un uso condicional), los paquetes pueden almacenar datos específicos del usuario, archivos de configuración y caché en sus respectivos directorios de usuario obtenidos de tools::R_user_dir(), siempre que que por [sic] los tamaños predeterminados se mantengan lo más pequeños posible y los contenidos se administren activamente (incluida la eliminación de material obsoleto).\n\n\n\nLa función principal que debe utilizar para derivar ubicaciones aceptables para los datos del usuario es tools::R_user_dir()3. Aquí hay algunos ejemplos de las rutas de archivos generadas.:\n\ntools::R_user_dir(\"pkg\", which = \"data\")\n#&gt; [1] \"/home/runner/.local/share/R/pkg\"\ntools::R_user_dir(\"pkg\", which = \"config\")\n#&gt; [1] \"/home/runner/.config/R/pkg\"\ntools::R_user_dir(\"pkg\", which = \"cache\")\n#&gt; [1] \"/home/runner/.cache/R/pkg\"\n\nUna última cosa que debe considerar con respecto a los datos persistentes es: ¿estos datos realmente necesitan persistir? ¿Realmente necesitas ser el responsable de almacenarlo?\nSi los datos son potencialmente confidenciales, como las credenciales del usuario, se recomienda obtener el consentimiento del usuario para almacenarlos, es decir, requerir consentimiento interactivo al iniciar el caché. Considere también que el sistema operativo del usuario o las herramientas de línea de comandos podrían proporcionar un medio de almacenamiento seguro superior a cualquier solución de bricolaje que pueda implementar. Los paquetes keyring, gitcreds, y credentials son ejemplos de paquetes que aprovechan herramientas proporcionadas externamente. Antes de embarcarse en cualquier solución creativa para almacenar secretos, considere que probablemente sea mejor invertir su esfuerzo en integrarlo con una herramienta establecida.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "7  Datos",
    "section": "",
    "text": "Si no sabe mucho sobre los entornos R y lo que los hace especiales, un gran recurso es el capítulo Entornos de R Avanzado.↩︎\nEste ejemplo se ejecutará sin errores si define favorite_letters, mfl() y set_mfl() en el espacio de trabajo global y llama a set_mfl() en la consola. Pero este código fallará una vez que favorite_letters, mfl() y set_mfl() estén definidos dentro de un paquete.↩︎\nTenga en cuenta que tools::R_user_dir() apareció por primera vez en R 4.0. Si necesita admitir versiones anteriores de R, debe usar el [paquete rapppdirs] (https://rappdirs.r-lib.org), que es una adaptación del módulo appdirs de Python y que sigue la política tidyverse con respecto al soporte de la versión R, lo que significa que la versión R mínima admitida está avanzando y eventualmente pasará de R 4.0. rappdirs produce rutas de archivo diferentes a las de tools::R_user_dir(). Sin embargo, ambas herramientas implementan algo que es consistente con la especificación XDG, solo que con diferentes opiniones sobre cómo crear rutas de archivos más allá de lo que dicta la especificación.↩︎",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datos</span>"
    ]
  },
  {
    "objectID": "misc.html",
    "href": "misc.html",
    "title": "8  Otros componentes",
    "section": "",
    "text": "8.1 Otros directorios\nLos dos primeros capítulos de esta parte del libro cubren las dos cosas más obvias que la gente distribuye a través de un paquete R: funciones (Capítulo 6) y datos (Capítulo 7). Pero eso no es todo lo que se necesita para crear un paquete R. Hay otros componentes del paquete que son necesarios, como un archivo DESCRIPTION, o altamente recomendados, como pruebas y documentación.\nLas siguientes partes del libro están organizadas en torno a conceptos importantes: dependencias, pruebas y documentación. Pero antes de profundizar en esos temas, este capítulo desmitifica algunas partes del paquete que no son necesarias en todos los paquetes, pero que es bueno tener en cuenta.\nA continuación se muestran algunos directorios de nivel superior que puede encontrar en un paquete fuente de R, en orden aproximado de importancia y frecuencia de uso:",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Otros componentes</span>"
    ]
  },
  {
    "objectID": "misc.html#otros-directorios",
    "href": "misc.html#otros-directorios",
    "title": "8  Otros componentes",
    "section": "",
    "text": "src/: Archivos fuente y de encabezado para código compilado, generalmente C y C++. Esta es una técnica importante que se utiliza para hacer que los paquetes de R tengan más rendimiento y desbloquear el poder de las bibliotecas externas para los usuarios de R. A partir de la segunda edición, el libro ya no cubre este tema, ya que un tratamiento verdaderamente útil del código compilado requiere más espacio del que podemos darle aquí. El tidyverse generalmente utiliza el paquete cpp11 para conectar C++ a R; la mayoría de los otros paquetes usan Rcpp, el paquete mejor establecido para integrar R y C++.\ninst/: para archivos adicionales arbitrarios que desee incluir en su paquete. Esto incluye algunos archivos especiales, como CITATION, que se describe a continuación en Sección 8.2. Otros ejemplos de archivos que pueden aparecer debajo de inst/ incluyen plantillas de R Markdown (consulte usethis::use_rmarkdown_template()) o RStudio add-ins.\ntools/: Archivos auxiliares necesarios durante la configuración, que generalmente se encuentran en compañía de un script configure. Discutimos esto más a continuación en Sección 8.3.\ndemo/: para demostraciones de paquetes. Consideramos las demostraciones como un fenómeno heredado, cuyos objetivos ahora se cumplen mejor con viñetas. (Capítulo 17). Para paquetes mantenidos activamente, probablemente tenga sentido reutilizar el contenido de cualquier demostración existente en algún lugar que sea más visible, por ejemplo. en README.Rmd (Sección 18.1) o en viñetas (Capítulo 17). Estas otras ubicaciones ofrecen otras ventajas, como garantizar que el código se ejerza con regularidad. Esto no es cierto para las demostraciones reales, lo que las deja vulnerables a la descomposición.\nexec/: para scripts ejecutables. A diferencia de los archivos ubicados en otros directorios, los archivos en exec/ se marcan automáticamente como ejecutables. Empíricamente, en la medida en que los paquetes R incluyen scripts para intérpretes externos, el directorio inst/ parece ser la ubicación preferida en estos días.\npo/: traducciones de mensajes. Esto es útil, pero está más allá del alcance de este libro. Consulte el capítulo Internacionalización de “Escribir extensiones de R” y el paquete potools para más detalles.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Otros componentes</span>"
    ]
  },
  {
    "objectID": "misc.html#sec-misc-inst",
    "href": "misc.html#sec-misc-inst",
    "title": "8  Otros componentes",
    "section": "\n8.2 Archivos instalados",
    "text": "8.2 Archivos instalados\nCuando se instala un paquete, todo lo que está en inst/ se copia en el directorio de nivel superior del paquete instalado (consulte Figura 3.1). En cierto sentido, inst/ es lo opuesto a .Rbuildignore: donde .Rbuildignore le permite eliminar archivos y directorios arbitrarios del paquete compilado, inst/ le permite agregarlos.\n\n\n\n\n\n\nAdvertencia\n\n\n\nEres libre de poner lo que quieras en inst/ con una precaución: debido a que inst/ se copia en el directorio de nivel superior, no crees un subdirectorio que colisione con cualquiera de los directorios que componen la estructura oficial. de un paquete R. Recomendamos evitar directorios con significado especial ya sea en la forma fuente o instalada de un paquete, como por ejemplo: inst/data, inst/help, inst/html, inst/libs, inst/man, inst/Meta, inst/R, inst/src, inst/tests, inst/tools, and inst/vignettes. En la mayoría de los casos, esto evita que tenga un paquete con formato incorrecto. Y aunque algunos de los directorios anteriores están técnicamente permitidos, pueden ser una fuente innecesaria de confusión.\n\n\nEstos son algunos de los archivos y carpetas más comunes que se encuentran en inst/:\n\ninst/CITATION: cómo citar el paquete, consulte a continuación para obtener más detalles.\ninst/extdata: datos externos adicionales para ejemplos y viñetas. Consulte la sección Sección 7.3 para obtener más detalles.\n\n¿Qué sucede si necesita una ruta al archivo en inst/foo para usarla, por ejemplo, en el código debajo de R/ o en su documentación? La solución predeterminada es utilizar system.file(\"foo\", package = \"tupaquete\"). Pero esto presenta un dilema en el flujo de trabajo: cuando estás desarrollando tu paquete, interactúas con él en su forma fuente (inst/foo), pero tus usuarios interactúan con su forma instalada (/foo). Afortunadamente, devtools proporciona una corrección para system.file() que se activa con load_all(). La sección Sección 7.3.1 cubre esto con más profundidad e incluye una alternativa interesante, fs::path_package() .\n\n8.2.1 Cita del paquete\nEl archivo CITATION vive en el directorio inst y está íntimamente conectado a la función citation() que le indica cómo citar paquetes R y R. Llamar a citation() sin ningún argumento le indica cómo citar la base R:\n\ncitation()\n#&gt; To cite R in publications use:\n#&gt; \n#&gt;   R Core Team (2024). _R: A Language and Environment for\n#&gt;   Statistical Computing_. R Foundation for Statistical\n#&gt;   Computing, Vienna, Austria. &lt;https://www.R-project.org/&gt;.\n#&gt; \n#&gt; A BibTeX entry for LaTeX users is\n#&gt; \n#&gt;   @Manual{,\n#&gt;     title = {R: A Language and Environment for Statistical Computing},\n#&gt;     author = {{R Core Team}},\n#&gt;     organization = {R Foundation for Statistical Computing},\n#&gt;     address = {Vienna, Austria},\n#&gt;     year = {2024},\n#&gt;     url = {https://www.R-project.org/},\n#&gt;   }\n#&gt; \n#&gt; We have invested a lot of time and effort in creating R,\n#&gt; please cite it when using it for data analysis. See also\n#&gt; 'citation(\"pkgname\")' for citing R packages.\n\nLlamarlo con un nombre de paquete le indica cómo citar ese paquete:\n\ncitation(\"tidyverse\")\n#&gt; To cite package 'tidyverse' in publications use:\n#&gt; \n#&gt;   Wickham H, Averick M, Bryan J, Chang W, McGowan LD,\n#&gt;   François R, Grolemund G, Hayes A, Henry L, Hester J, Kuhn\n#&gt;   M, Pedersen TL, Miller E, Bache SM, Müller K, Ooms J,\n#&gt;   Robinson D, Seidel DP, Spinu V, Takahashi K, Vaughan D,\n#&gt;   Wilke C, Woo K, Yutani H (2019). \"Welcome to the\n#&gt;   tidyverse.\" _Journal of Open Source Software_, *4*(43),\n#&gt;   1686. doi:10.21105/joss.01686\n#&gt;   &lt;https://doi.org/10.21105/joss.01686&gt;.\n#&gt; \n#&gt; A BibTeX entry for LaTeX users is\n#&gt; \n#&gt;   @Article{,\n#&gt;     title = {Welcome to the {tidyverse}},\n#&gt;     author = {Hadley Wickham and Mara Averick and Jennifer Bryan and Winston Chang and Lucy D'Agostino McGowan and Romain François and Garrett Grolemund and Alex Hayes and Lionel Henry and Jim Hester and Max Kuhn and Thomas Lin Pedersen and Evan Miller and Stephan Milton Bache and Kirill Müller and Jeroen Ooms and David Robinson and Dana Paige Seidel and Vitalie Spinu and Kohske Takahashi and Davis Vaughan and Claus Wilke and Kara Woo and Hiroaki Yutani},\n#&gt;     year = {2019},\n#&gt;     journal = {Journal of Open Source Software},\n#&gt;     volume = {4},\n#&gt;     number = {43},\n#&gt;     pages = {1686},\n#&gt;     doi = {10.21105/joss.01686},\n#&gt;   }\n\nEl archivo inst/CITATION asociado tiene este aspecto:\n\nbibentry(\n  \"Article\",\n  title = \"Welcome to the {tidyverse}\",\n  author = \"Hadley Wickham, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D'Agostino McGowan, Romain François, Garrett Grolemund, Alex Hayes, Lionel Henry, Jim Hester, Max Kuhn, Thomas Lin Pedersen, Evan Miller, Stephan Milton Bache, Kirill Müller, Jeroen Ooms, David Robinson, Dana Paige Seidel, Vitalie Spinu, Kohske Takahashi, Davis Vaughan, Claus Wilke, Kara Woo, Hiroaki Yutani\",\n  year = 2019,\n  journal = \"Journal of Open Source Software\",\n  volume = 4,\n  number = 43,\n  pages = 1686,\n  doi = \"10.21105/joss.01686\",\n)\n\nPuede llamar a usethis::use_citation() para iniciar este archivo y completar sus datos. Lea el tema de ayuda ?bibentry para obtener más detalles.",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Otros componentes</span>"
    ]
  },
  {
    "objectID": "misc.html#sec-misc-tools",
    "href": "misc.html#sec-misc-tools",
    "title": "8  Otros componentes",
    "section": "\n8.3 Herramientas de configuración",
    "text": "8.3 Herramientas de configuración\nSi un paquete tiene un script de configuración (configure en sistemas Unix, configure.win en Windows), se ejecuta como primer paso mediante R CMD INSTALL. Esto generalmente se asocia con un paquete que tiene un subdirectorio src/ que contiene código C/C++ y el script configure es necesario en el momento de la compilación. Si ese script necesita archivos auxiliares, estos deben ubicarse en el directorio tools/. Los scripts debajo de tools/ pueden tener un efecto en el paquete instalado, pero el contenido de tools/ finalmente no estará presente en el paquete instalado. En cualquier caso, esto es principalmente (pero no exclusivamente) relevante para paquetes con código compilado, lo cual está más allá del alcance de este libro.\nMencionamos esto porque, en la práctica, algunos paquetes usan el directorio tools/ para un propósito diferente pero relacionado. Algunos paquetes tienen tareas de mantenimiento periódicas para las cuales resulta útil registrar instrucciones detalladas. Por ejemplo, muchos paquetes incorporan algún tipo de recurso externo, p. código o datos:\n\nCódigo fuente y encabezados para una biblioteca C/C++ integrada de terceros.\nKits de herramientas web.\nCódigo R integrado (en lugar de importado).\nEspecificación para una API web.\nPaletas de colores, estilos y temas.\n\nEstos activos externos también suelen evolucionar con el tiempo, por lo que es necesario reingerirlos periódicamente. Esto hace que sea particularmente gratificante implementar dicha limpieza de manera programática.\nEste es el segundo uso no oficial del directorio tools/, caracterizado por dos grandes diferencias con respecto a su propósito oficial: los paquetes que hacen esto generalmente no tienen un script configure y enumeran tools/ en .Rbuildignore, lo que significa que estos scripts no están incluidos en el paquete. Estos scripts se mantienen en el paquete fuente para comodidad del desarrollador, pero nunca se envían con el paquete.\nEsta práctica está estrechamente relacionada con nuestra recomendación de almacenar las instrucciones para la creación de datos del paquete en data-raw/ (sección Sección 7.1.1) y registrar el método de construcción de cualquier dispositivo de prueba (sección Sección 15.1.3).",
    "crumbs": [
      "Componentes de un paquete",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Otros componentes</span>"
    ]
  },
  {
    "objectID": "description.html",
    "href": "description.html",
    "title": "9  DESCRIPTION",
    "section": "",
    "text": "9.1 El archivo DESCRIPTION\nDESCRIPTION y NAMESPACE Hay dos archivos importantes que proporcionan metadatos sobre su paquete. El archivo DESCRIPTION proporciona metadatos generales sobre el paquete, como el nombre del paquete y de qué otros paquetes depende. El archivo NAMESPACE especifica qué funciones su paquete pone a disposición de otros para que las utilicen y, opcionalmente, importa funciones de otros paquetes.\nEn este capítulo, aprenderá sobre los campos más importantes que se encuentran en DESCRIPTION. Los dos capítulos siguientes cubren el tema de las dependencias de paquetes, que es donde quedará clara la importancia del archivo NAMESPACE. Primero, en Capítulo 10, analizamos los costos y beneficios de las dependencias y también proporcionamos el contexto técnico relevante sobre cómo R encuentra objetos. En Capítulo 11, explicamos los movimientos prácticos necesarios para usar sus dependencias dentro de su paquete. La parte de metadatos del libro concluye con Capítulo 12, que cubre las licencias.\nEl trabajo del archivo DESCRIPTION es almacenar metadatos importantes sobre su paquete. Cuando comience a escribir paquetes por primera vez, utilizará principalmente estos metadatos para registrar qué paquetes se necesitan para ejecutar su paquete. Sin embargo, a medida que pasa el tiempo, otros aspectos del archivo de metadatos le resultarán útiles, como revelar qué hace su paquete (a través del Título(Title) y la Descripción,Description) y con quién contactar (¡usted!) si hay algún problema. .\nCada paquete debe tener una DESCRIPTION. De hecho, es la característica que define un paquete (RStudio y devtools consideran que cualquier directorio que contenga DESCRIPTION es un paquete)1. Para comenzar, usethis::create_package(\"mypackage\") agrega automáticamente un archivo básico DESCRIPTION. Esto le permitirá comenzar a escribir el paquete sin tener que preocuparse por los metadatos hasta que sea necesario. Esta descripción mínima variará un poco dependiendo de su configuración, pero debería verse así:\nPackage: mypackage\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n           comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.1\nSi crea muchos paquetes, puede personalizar el contenido predeterminado de los nuevos archivos DESCRIPTION configurando la opción global usethis.description en una lista con nombre. Puede preconfigurar su nombre preferido, correo electrónico, licencia, etc. Consulte el artículo sobre cómo usar esta configuración para obtener más detalles.\nDESCRIPTION utiliza un formato de archivo simple llamado DCF, el formato de control de Debian. Puede ver la mayor parte de la estructura en los ejemplos de este capítulo. Cada línea consta de un nombre de campo y un valor, separados por dos puntos. Cuando los valores abarcan varias líneas, es necesario sangrarlos:\nSi alguna vez necesita trabajar con un archivo DESCRIPTION mediante programación, eche un vistazo al [paquete desc] (https://desc.r-lib.org/), que utiliza este archivo en gran medida de forma oculta.\nEste capítulo le muestra cómo utilizar los campos más importantes de DESCRIPTION.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#el-archivo-description",
    "href": "description.html#el-archivo-description",
    "title": "9  DESCRIPTION",
    "section": "",
    "text": "Description: La descripción de un paquete suele abarcar varias líneas.\n    La segunda línea y las siguientes deben tener sangría, generalmente con cuatro\n    espacios.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#sec-description-title-and-description",
    "href": "description.html#sec-description-title-and-description",
    "title": "9  DESCRIPTION",
    "section": "\n9.2 Title y Description: ¿Qué hace tu paquete?",
    "text": "9.2 Title y Description: ¿Qué hace tu paquete?\nLos campos Title y Description describen lo que hace el paquete. Se diferencian sólo en longitud:\n\n\nTitle es una descripción de una línea del paquete y, a menudo, se muestra en una lista de paquetes. Debe ser texto sin formato (sin marcas), en mayúscula como un título y NO terminar en un punto. Sea breve: los listados a menudo truncarán el título a 65 caracteres.\n\nDescription Es más detallado que el título. Puede utilizar varias oraciones, pero está limitado a un párrafo. Si su descripción abarca varias líneas (¡y debería hacerlo!), cada línea no debe tener más de 80 caracteres de ancho. Sangra las líneas siguientes con 4 espacios.\n\nLos campos Title y Description para el paquete ggplot2 son:\nTitle: Create Elegant Data Visualisations Using the Grammar of Graphics\nDescription: A system for 'declaratively' creating graphics,\n    based on \"The Grammar of Graphics\". You provide the data, tell 'ggplot2'\n    how to map variables to aesthetics, what graphical primitives to use,\n    and it takes care of the details.\nUn buen título y descripción son importantes, especialmente si planea liberar su paquete a CRAN, porque aparecen en la página de inicio de CRAN del paquete como se muestra en Figura 9.1:\n\n\n\n\n\n\n\n\nFigura 9.1: Cómo aparecen el título y la descripción en la página CRAN de ggplot2.\n\n\n\n\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nTanto el “Título” como la “Descripción” son una fuente frecuente de rechazos por motivos no cubiertos por la “verificación R CMD” automatizada. Además de los conceptos básicos anteriores, aquí hay algunos consejos más:\n\nColoque los nombres de los paquetes, el software y las API de R entre comillas simples. Esto se aplica tanto al título como a la descripción. Vea el ejemplo de ggplot2 anterior.\nSi necesita utilizar un acrónimo, intente hacerlo en Description, no en Títle. En cualquier caso, explique el acrónimo en Description, es decir, expándalo por completo.\nNo incluya el nombre del paquete, especialmente en Títle, que a menudo tiene el prefijo del nombre del paquete.\nNo empiece con “Un paquete para…” o “Este paquete hace…”. Esta regla tiene sentido una vez que miras la lista de paquetes CRAN por nombre. La densidad de información de un listado de este tipo es mucho mayor sin un prefijo universal como “Un paquete para …”.\n\nSi estas limitaciones le provocan un bloqueo, a menudo resulta útil dedicar unos minutos a leer el título y la descripción de los paquetes que ya están en CRAN. Una vez que lea un par de docenas, generalmente podrá encontrar una manera de decir lo que quiere decir sobre su paquete que probablemente también pase las comprobaciones realizadas por humanos de CRAN.\n\n\nNotarás que Description solo te brinda una pequeña cantidad de espacio para describir lo que hace tu paquete. Por eso es tan importante incluir también un archivo README.md que profundiza mucho más y muestra algunos ejemplos. Aprenderás sobre eso en Sección 18.1.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#sec-description-authors-at-r",
    "href": "description.html#sec-description-authors-at-r",
    "title": "9  DESCRIPTION",
    "section": "\n9.3 Autor: ¿quién eres?",
    "text": "9.3 Autor: ¿quién eres?\nUtilice el campo Authors@R para identificar al autor del paquete y a quién contactar si algo sale mal. Este campo es inusual porque contiene código R ejecutable en lugar de texto sin formato. He aquí un ejemplo:\nAuthors@R: person(\"Hadley\", \"Wickham\", email = \"hadley@posit.co\",\n  role = c(\"aut\", \"cre\"))\n\nperson(\"Hadley\", \"Wickham\", email = \"hadley@posit.co\", \n  role = c(\"aut\", \"cre\"))\n#&gt; [1] \"Hadley Wickham &lt;hadley@posit.co&gt; [aut, cre]\"\n\nEste comando dice que Hadley Wickham es tanto el mantenedor (cre) como el autor (aut) y que su dirección de correo electrónico es hadley@posit.co. La función person() tiene cuatro entradas principales:\n\nEl nombre, especificado por los dos primeros argumentos, given y family (normalmente se proporcionan por posición, no por nombre). En las culturas inglesas, given (nombre) viene antes de family (apellido). En muchas culturas, esta convención no se cumple. Para una entidad que no sea una persona, como “R Core Team” o “Posit Software, PBC”, utilice el argumento given (y omita family).\nLa dirección de email, que es sólo un requisito absoluto para el mantenedor. Es importante tener en cuenta que esta es la dirección que CRAN utiliza para informarle si su paquete necesita ser reparado para permanecer en CRAN. Asegúrese de utilizar una dirección de correo electrónico que probablemente exista por un tiempo. La política de CRAN requiere que esto sea para una persona, a diferencia de, por ejemplo, una lista de correo.\n\nUno o más códigos de tres letras que especifican el “rol”. Estos son los roles más importantes que debes conocer:\n\ncre: el creador o mantenedor, la persona a la que debes molestar si tienes problemas. A pesar de ser la abreviatura de “creador”, este es el rol correcto que debe utilizar el mantenedor actual, incluso si no es el creador inicial del paquete.\naut: autores, aquellos que han hecho contribuciones significativas al paquete.\nctb: contribuyentes, aquellos que han hecho contribuciones menores, como parches.\ncph: titular de derechos de autor. Esto se utiliza para enumerar titulares de derechos de autor adicionales que no son autores, generalmente empresas, como un empleador de uno o más de los autores.\nfnd: financiador, las personas u organizaciones que han proporcionado apoyo financiero para el desarrollo del paquete.\n\n\n\nEl argumento opcional comment se ha vuelto más relevante, ya que person() y las páginas de inicio de CRAN han adquirido algunas características interesantes en torno al identificador ORCID. A continuación se muestra un ejemplo de dicho uso (tenga en cuenta el URI generado automáticamente):\n\nperson(\n  \"Jennifer\", \"Bryan\",\n  email = \"jenny@posit.co\",\n  role = c(\"aut\", \"cre\"),\n  comment = c(ORCID = \"0000-0002-6983-2759\")\n)\n#&gt; [1] \"Jennifer Bryan &lt;jenny@posit.co&gt; [aut, cre] (&lt;https://orcid.org/0000-0002-6983-2759&gt;)\"\n\n\n\nPuede enumerar varios autores con c():\nAuthors@R: c(\n    person(\"Hadley\", \"Wickham\", email = \"hadley@posit.co\", role = \"cre\"),\n    person(\"Jennifer\", \"Bryan\", email = \"jenny@posit.co\", role = \"aut\"),\n    person(\"Posit Software, PBC\", role = c(\"cph\", \"fnd\")))\nCada paquete debe tener al menos un autor (aut) y un mantenedor (cre) (pueden ser la misma persona). El mantenedor (cre) debe tener una dirección de correo electrónico. Estos campos se utilizan para generar la cita básica para el paquete (por ejemplo, citation(\"pkgname\")). Solo las personas que figuran como autores se incluirán en la cita generada automáticamente (Sección 8.2.1). Hay algunos detalles adicionales si incluye código que otras personas han escrito, sobre los cuales puede obtener información en Sección 12.4.\nUn enfoque más antiguo, aún válido, es tener campos separados Maintainer y Author en DESCRIPTION. Sin embargo, recomendamos encarecidamente el enfoque más moderno de Authors@R y la función person(), porque ofrece metadatos más ricos para diversos usos posteriores..",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#url-y-bugreports",
    "href": "description.html#url-y-bugreports",
    "title": "9  DESCRIPTION",
    "section": "\n9.4 URL y BugReports\n",
    "text": "9.4 URL y BugReports\n\nAdemás de la dirección de correo electrónico del mantenedor, es una buena idea enumerar otros lugares donde las personas pueden obtener más información sobre su paquete. El campo URL se usa comúnmente para anunciar el sitio web del paquete (Capítulo 19) y para vincular a un repositorio de código fuente público, donde se lleva a cabo el desarrollo. Varias URL están separadas por una coma. BugReports es la URL donde se deben enviar los informes de errores, por ejemplo, como problemas de GitHub. Por ejemplo, devtools tiene:\nURL: https://devtools.r-lib.org/, https://github.com/r-lib/devtools\nBugReports: https://github.com/r-lib/devtools/issues\nSi usa usethis::use_github() para conectar su paquete local a un repositorio remoto de GitHub, automáticamente completará URL y BugReports. Si un paquete ya está conectado a un repositorio remoto de GitHub, se puede llamar a usethis::use_github_links() para simplemente agregar los enlaces relevantes a DESCRIPTION.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#el-campo-license",
    "href": "description.html#el-campo-license",
    "title": "9  DESCRIPTION",
    "section": "\n9.5 El campo License\n",
    "text": "9.5 El campo License\n\nEl campo License es obligatorio y debe especificar la licencia de su paquete en un formulario estándar reconocido por R. Las herramientas oficiales tienen como objetivo identificar licencias estándar de código abierto, por lo que es importante tener en cuenta que License es básicamente un campo legible por máquina. Consulte Capítulo 12 para obtener una discusión completa.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#sec-description-imports-suggests",
    "href": "description.html#sec-description-imports-suggests",
    "title": "9  DESCRIPTION",
    "section": "\n9.6 Imports, Suggests, y amigos",
    "text": "9.6 Imports, Suggests, y amigos\nDos de los campos más importantes y comunmente usados de DESCRIPTION son Imports y Suggests, que enumera otros paquetes de los que depende su paquete. Los usuarios necesitan los paquetes enumerados en Imports en tiempo de ejecución y se instalarán (o potencialmente actualizarán) cuando los usuarios instalen su paquete a través de install.packages(). Las siguientes líneas indican que su paquete necesita absolutamente tanto dplyr como tidyr para funcionar.\nImports:\n    dplyr,\n    tidyr\nLos paquetes enumerados en Suggests son necesarios para tareas de desarrollo o pueden desbloquear funciones opcionales para sus usuarios. Las líneas siguientes indican que, si bien su paquete puede aprovechar ggplot2 y testthat, no son absolutamente necesarios:\nSuggests:\n    ggplot2,\n    testthat\nTanto Imports como Suggests toman una lista de nombres de paquetes separados por comas. Recomendamos poner un paquete en cada línea y mantenerlos en orden alfabético. Un orden no aleatorio facilita que los humanos analicen este campo y aprecien los cambios.\nLa forma más sencilla de agregar un paquete a Imports o Suggests es con usethis::use_package(). Si las dependencias ya están en orden alfabético, use_package() las mantendrá así. En general, puede ser bueno ejecutar usethis::use_tidy_description() regularmente, que ordena y formatea los campos DESCRIPTION de acuerdo con un estándar fijo.\nSi agrega paquetes a DESCRIPTION con usethis::use_package(), también le recordará la forma recomendada de llamarlos (explicada más en Capítulo 11).\n\nusethis::use_package(\"dplyr\") # El valor predeterminado es \"Imports\"\n#&gt; ✔ Adding 'dplyr' to Imports field in DESCRIPTION\n#&gt; • Refer to functions with `dplyr::fun()`\n\nusethis::use_package(\"ggplot2\", \"Suggests\")\n#&gt; ✔ Adding 'ggplot2' to Suggests field in DESCRIPTION\n#&gt; • Use `requireNamespace(\"ggplot2\", quietly = TRUE)` to test if package is installed\n#&gt; • Then directly refer to functions with `ggplot2::fun()`\n\n\n9.6.1 Versiones mínimas\nSi necesita una versión específica de un paquete, especifíquela entre paréntesis después del nombre del paquete:\nImports:\n    dplyr (&gt;= 1.0.0),\n    tidyr (&gt;= 1.1.0)\nLa conveniente función usethis::use_package() también le ayuda a establecer una versión mínima:\n\n# versión exacta\nusethis::use_package(\"dplyr\", min_version = \"1.0.0\")\n\n# versión mínima = versión actualmente instalada\nusethis::use_package(\"dplyr\", min_version = TRUE)\n\nSiempre querrás especificar una versión mínima (dplyr (&gt;= 1.0.0)) en lugar de una versión exacta (dplyr (== 1.0.0)). Dado que R no puede tener varias versiones del mismo paquete cargadas al mismo tiempo, especificar una dependencia exacta aumenta drásticamente la posibilidad de que haya versiones en conflicto 2.\nEl control de versiones es más importante si va a liberar su paquete para que otros lo utilicen. Por lo general, la gente no tiene exactamente las mismas versiones de paquetes instaladas que usted. Si alguien tiene un paquete anterior que no tiene una función que su paquete necesita, recibirá un mensaje de error inútil si su paquete no anuncia la versión mínima que necesita. Sin embargo, si indica una versión mínima, obtendrán automáticamente una actualización cuando instalen su paquete.\nPiense detenidamente si declara una versión mínima para una dependencia. En cierto sentido, lo más seguro es requerir una versión mayor o igual a la versión actual del paquete. Para trabajos públicos, esto se define más naturalmente como la versión CRAN actual de un paquete; Los proyectos privados o personales podrán adoptar algún otro convenio. Pero es importante apreciar las implicaciones para las personas que intentan instalar su paquete: si su instalación local no cumple con todos sus requisitos en torno a las versiones, la instalación forzará las actualizaciones de estas dependencias. Esto es deseable si sus requisitos mínimos de versión son genuinos, es decir, de lo contrario su paquete estaría roto. Pero si los requisitos establecidos tienen una justificación menos sólida, esto puede resultar innecesariamente conservador e inconveniente.\nEn ausencia de requisitos claros y estrictos, debe establecer versiones mínimas (o no) en función de su base de usuarios esperada, las versiones de paquetes que probablemente tengan y un análisis de costo-beneficio para determinar si es demasiado laxo o demasiado conservador. La política de facto del equipo de tidyverse es especificar una versión mínima cuando se utiliza una característica nueva conocida o cuando alguien encuentra un problema de versión en uso auténtico. Esto no es perfecto, pero actualmente no contamos con las herramientas para hacerlo mejor y parece funcionar bastante bien en la práctica.\n\n9.6.2 Depends y LinkingTo\n\nHay otros tres campos que le permiten expresar dependencias más especializadas:\n\n\nDepends: Antes de la implementación de espacios de nombres en R 2.14.0 en 2011, Depends era la única forma de “depender” de otro paquete. Ahora bien, a pesar del nombre, casi siempre deberías usar Imports, no Depends. Aprenderá por qué y cuándo debería seguir usándo Depends, en Sección 10.4.1.\nEl uso actual más legítimo de Depends es indicar una versión mínima para el propio R, p. Depends: R (&gt;= 4.0.0). Nuevamente, piense detenidamente si hace esto. Esto plantea los mismos problemas que establecer una versión mínima para un paquete del que depende, excepto que lo que está en juego es mucho mayor cuando se trata del propio R. Los usuarios no pueden simplemente dar su consentimiento para la actualización necesaria, por lo que, si otros paquetes dependen del suyo, su requisito de versión mínima para R puede causar una cascada de fallas en la instalación de paquetes.\n\nEl paquete backports es útil si desea utilizar una función como tools::R_user_dir(), que se introdujo en 4.0.0 en 2020, sin dejar de ser compatible con versiones anteriores de R.\nLos paquetes tidyverse son oficialmente compatibles con la versión R actual, la versión devel y cuatro versiones anteriores.3 Probamos proactivamente este soporte en la matriz de compilación estándar que utilizamos para la integración continua.\nEs posible que los paquetes con un nivel de uso inferior no necesiten este nivel de rigor. La conclusión principal es: si declara un mínimo de R, debe tener una razón y debe tomar medidas razonables para probar su afirmación con regularidad.\n\n\nLinkingTo: Si su paquete usa código C o C++ de otro paquete, debe incluirlo aquí.\nEnhances: Los paquetes enumerados aquí están “mejorados” por su paquete. Normalmente, esto significa que proporcionas métodos para clases definidas en otro paquete (una especie de Suggests inversas). Pero es difícil definir qué significa eso, por lo que no recomendamos usar Enhances.\n\n9.6.3 Una versión R te pillé\nAntes de abandonar este tema, damos un ejemplo concreto de la facilidad con la que una dependencia de la versión R puede aparecer y tener un impacto más amplio de lo que cabría esperar. La función saveRDS() escribe un único objeto R como un archivo .rds, un formato específico de R. Durante casi 20 años, los archivos .rds utilizaron el formato de serialización “versión 2”. La “Versión 3” se convirtió en la nueva versión predeterminada en R 3.6.0 (lanzada en abril de 2019) y no puede leerse en las versiones de R anteriores a la 3.5.0 (lanzada en abril de 2018).\nMuchos paquetes de R tienen al menos un archivo .rds escondido y, si se vuelve a generar con una versión moderna de R, de forma predeterminada, el nuevo archivo .rds tendrá el formato de “versión 3”. La próxima vez que se compila ese paquete R, como para un envío CRAN, la versión R requerida pasa automáticamente a 3.5.0, como se indica con este mensaje:\nNB: this package now depends on R (&gt;= 3.5.0)\n  WARNING: Added dependency on R &gt;= 3.5.0 because serialized objects in\n  serialize/load version 3 cannot be read in older versions of R.\n  File(s) containing such objects:\n    'path/to/some_file.rds'\nLiteralmente, el archivo DESCRIPTION en el paquete incluido dice DependS: R (&gt;= 3.5.0), incluso si DESCRIPTION en el paquete fuente dice lo contrario4.\nCuando un paquete de este tipo se publica en CRAN, la nueva versión mínima de R es viral, en el sentido de que todos los paquetes que enumeran el paquete original en Imports o incluso en Suggests han heredado, en diversos grados, la nueva dependencia de R &gt;= 3.5.0.\nLa conclusión inmediata es ser muy deliberado acerca de la versión de los archivos .rds hasta que las versiones R anteriores a 3.5.0 hayan caído del límite de lo que pretende admitir. Este problema particular de .rds no estará con nosotros para siempre, pero problemas similares surgen en otros lugares, como en los estándares implícitos en el código fuente compilado de C o C++. El mensaje más amplio es que cuantas más dependencias inversas tenga su paquete, más pensará en las versiones mínimas indicadas de su paquete, especialmente para R.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#otros-campos",
    "href": "description.html#otros-campos",
    "title": "9  DESCRIPTION",
    "section": "\n9.7 Otros campos",
    "text": "9.7 Otros campos\nAlgunos otros campos DESCRIPTION se utilizan mucho y vale la pena conocerlos:\n\nVersion Es muy importante como forma de comunicar en qué punto de su ciclo de vida se encuentra su paquete y cómo evoluciona con el tiempo. Más información en Capítulo 21.\nLazyData es relevante si su paquete pone datos a disposición del usuario. Si especifica LazyData: true, los conjuntos de datos se cargan de forma diferida, lo que los hace disponibles más inmediatamente, es decir, los usuarios no tienen que usar data(). La adición de LazyData: true se maneja automáticamente mediante usethis::use_data(). Se dan más detalles en Capítulo 7.\nEncoding describe la codificación de caracteres de los archivos en todo el paquete. Nuestras herramientas establecerán esto en Encoding: UTF-8, ya que esta es la codificación más común que se usa hoy en día y no conocemos ninguna razón para usar un valor diferente.\nCollate controla el orden en el que se obtienen los archivos R. Esto sólo importa si su código tiene efectos secundarios; más comúnmente porque estás usando S4. Si es necesario, roxygen2 normalmente genera Collate mediante el uso de la etiqueta @include. Consulte ?roxygen2::update_collate para obtener más detalles.\nVignetteBuilder incluye cualquier paquete que su paquete necesite como motor de viñeta. Nuestro flujo de trabajo de viñeta recomendado se describe en Sección 17.1, que enumerará el paquete knitr en VignetteBuilder.\n\nSystemRequirements es donde describe las dependencias externas a R. Este es un campo de texto sin formato y, por ejemplo, en realidad no instala ni verifica nada, por lo que es posible que deba incluir detalles de instalación adicionales en su archivo README (Sección 18.1). El uso más común es en el contexto de un paquete con código compilado, donde se usa SystemRequirements para declarar el estándar C++, la necesidad de crear GNU o alguna otra dependencia externa. Ejemplos:\nSystemRequirements: C++17\nSystemRequirements: GNU make\nSystemRequirements: TensorFlow (https://www.tensorflow.org/)\n\n\nNo recomendamos el uso explícito del campo Date, ya que es muy fácil olvidarse de actualizarlo si administra la fecha manualmente. Este campo se completará en el curso natural de agrupar el paquete, p. al enviar a CRAN, y le recomendamos que deje que eso suceda.\nHay muchos otros campos de descripción que se utilizan con menos frecuencia. Puede encontrar una lista completa en la sección “El archivo DESCRIPTION” de Escribir extensiones R.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#sec-description-custom-fields",
    "href": "description.html#sec-description-custom-fields",
    "title": "9  DESCRIPTION",
    "section": "\n9.8 Campos Personalizados",
    "text": "9.8 Campos Personalizados\nTambién existe cierta flexibilidad para crear sus propios campos para agregar metadatos adicionales. En el sentido más estricto, la única restricción es que no debes reutilizar los nombres de campos oficiales utilizados por R. También debe limitarse a palabras válidas en inglés, para que el corrector ortográfico no marque los nombres de los campos.\nEn la práctica, si planea enviar a CRAN, le recomendamos que cualquier nombre de campo personalizado comience con Config/. Revisaremos esto más adelante cuando expliquemos cómo se usa Config/Needs/website para registrar paquetes adicionales necesarios para crear el sitio web de un paquete (Sección 11.7).\nPodrías notar que create_package() escribe dos campos más que aún no hemos discutido, relacionados con el uso del paquete roxygen2 para documentación:\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.1\nAprenderá más sobre estos en Capítulo 16. El uso de estos nombres de campos específicos es básicamente un accidente de la historia y, si se volviera a hacer hoy, seguirían el patrón Config/* recomendado anteriormente.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "description.html#footnotes",
    "href": "description.html#footnotes",
    "title": "9  DESCRIPTION",
    "section": "",
    "text": "La relación entre “tiene un archivo DESCRIPTION” y “es un paquete” no es tan clara. Muchos proyectos que no son paquetes usan un archivo DESCRIPTION para declarar sus dependencias, es decir, en qué paquetes dependen. De hecho, ¡el proyecto de este libro hace exactamente eso! Este uso no autorizado de DESCRIPTION facilita el uso de herramientas de desarrollo de paquetes para instalar todos los paquetes necesarios para trabajar con un proyecto que no es un paquete.↩︎\nLa necesidad de especificar las versiones exactas de los paquetes, en lugar de las versiones mínimas, surge con más frecuencia en el desarrollo de proyectos que no son paquetes. El paquete renv proporciona una manera de hacer esto, mediante la implementación de entornos específicos del proyecto (bibliotecas de paquetes). renv es un reinicio de un paquete anterior llamado packrat. Si desea congelar las dependencias de un proyecto en versiones exactas, use renv en lugar de (o posiblemente además de) un archivo DESCRIPTION.↩︎\nVea esta publicación de blog para más: https://www.tidyverse.org/blog/2019/04/r-version-support/.↩︎\nLos diferentes estados del paquete, como fuente o empaquetado, se explican en Sección 3.1.↩︎",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>`DESCRIPTION`</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html",
    "href": "dependencies-mindset-background.html",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "",
    "text": "10.1 ¿Cuándo deberías tomar una dependencia?\nToma una dependencia cuando su paquete usa la funcionalidad de otro paquete (u otra herramienta externa). En Sección 9.6, explicamos cómo declarar una dependencia en otro paquete incluyéndolo en DESCRIPTION, generalmente en Imports o Suggests. Pero eso todavía te deja muchas cuestiones en las que pensar:\nUn concepto clave para comprender cómo deben funcionar juntos los paquetes es el de un espacio de nombres (Sección 10.2). Aunque puede resultar un poco confuso, el sistema de espacio de nombres de R es vital para el ecosistema de paquetes. Es lo que garantiza que otros paquetes no interfieran con su código, que su código no interfiera con otros paquetes y que su paquete funcione independientemente del entorno en el que se ejecute. Mostraremos cómo funciona el sistema de espacio de nombres junto con la ruta de búsqueda del usuario (Sección 10.3) y en conjunto con ella.\nEste capítulo contiene material que podrías omitir (o pasar por alto) al hacer tu primer paquete, cuando probablemente estés contento con hacer un paquete que funcione. Pero querrás revisar el material de este capítulo a medida que tus paquetes se vuelvan más ambiciosos y sofisticados.\nEsta sección está adaptada de “It Depende” publicación de blog y discusión escrito por Jim Hester.\nLas dependencias de software son un arma de doble filo. Por un lado, le permiten aprovechar el trabajo de otros, dándole a su software nuevas capacidades y haciendo que su comportamiento e interfaz sean más consistentes con otros paquetes. Al utilizar una solución preexistente, evita volver a implementar la funcionalidad, lo que elimina muchas oportunidades de introducir errores. Por otro lado, es probable que sus dependencias cambien con el tiempo, lo que podría requerir que realice cambios en su paquete, lo que podría aumentar su carga de mantenimiento. Sus dependencias también pueden aumentar el tiempo y el espacio en disco necesarios cuando los usuarios instalan su paquete. Estas desventajas han llevado a algunos a sugerir una mentalidad de “dependencia cero”. Creemos que este es un mal consejo para la mayoría de los proyectos y es probable que conduzca a una menor funcionalidad, un mayor mantenimiento y nuevos errores.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html#sec-dependencies-pros-cons",
    "href": "dependencies-mindset-background.html#sec-dependencies-pros-cons",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "",
    "text": "10.1.1 Las dependencias no son iguales\nUn problema de simplemente minimizar el número absoluto de dependencias es que trata todas las dependencias como equivalentes, como si todas tuvieran los mismos costos y beneficios (o incluso costos infinitos y ningún beneficio). Sin embargo, en realidad, esto está lejos de la verdad. Hay muchos ejes en los que pueden diferir las dependencias, pero algunos de los más importantes incluyen:\n\nEl tipo de dependencia. Algunas dependencias vienen incluidas con el propio R (por ejemplo, base, utilidades, estadísticas) o son uno de los paquetes “recomendados” (por ejemplo, Matrix, supervivencia). Depender de estos paquetes tiene un costo muy bajo, ya que se instalan (casi) universalmente en los sistemas de todos los usuarios y, en su mayoría, cambian solo con las nuevas versiones de R. Por el contrario, existe un costo más alto para una dependencia que proviene, por ejemplo, de un repositorio que no es CRAN, lo que requiere que los usuarios configuren repositorios adicionales antes de la instalación.\nEl número de dependencias ascendentes, es decir, dependencias recursivas. Por ejemplo, el paquete rlang se administra intencionalmente como un paquete de bajo nivel y no tiene dependencias ascendentes aparte del propio R. En el otro extremo, hay paquetes en CRAN con ~250 dependencias recursivas.\nDependencias ya cumplidas. Si su paquete depende de dplyr, entonces depender de tibble no cambia la huella de dependencia, ya que dplyr ya depende de tibble. Además, algunos de los paquetes más populares (por ejemplo, ggplot2) ya estarán instalados en la mayoría de las máquinas de los usuarios. Por lo tanto, es poco probable que agregar una dependencia de ggplot2 genere costos de instalación adicionales en la mayoría de los casos.\n\nLa carga de instalar el paquete. Varios factores hacen que un paquete sea más costoso de instalar, en términos de tiempo, espacio y molestias humanas:\n\nTiempo de compilación: los paquetes que contienen C/C++ pueden tardar muy diferentes en instalarse dependiendo de la complejidad del código. Por ejemplo, el paquete glue tarda ~5 segundos en compilarse en las máquinas de compilación de CRAN, mientras que el paquete readr tarda  ~100 segundos para instalar en las mismas máquinas.\nTamaño del paquete binario: los usuarios que instalan paquetes binarios deben descargarlos, por lo que el tamaño del binario es relevante, especialmente para aquellos con conexiones a Internet lentas. Esto también varía mucho entre paquetes. Los paquetes más pequeños en CRAN tienen un tamaño de alrededor de 1 Kb, mientras que el paquete h2o tiene un tamaño de 170 Mb, ¡y hay archivos binarios de Bioconductor que pesan más de 4 Gb!\nRequisitos del sistema: algunos paquetes requieren dependencias adicionales del sistema para poder usarse. Por ejemplo, el paquete rjags requiere una instalación correspondiente de la biblioteca JAGS. Otro ejemplo es rJava que requiere un SDK de Java y también tiene pasos adicionales necesarios para configurar R para la instalación adecuada de Java, lo que ha causado problemas de instalación para mucha gente.\n\n\nCapacidad de mantenimiento. Es razonable tener mayor confianza en un paquete que está bien establecido y que es mantenido por desarrolladores o equipos con una larga trayectoria y que mantienen muchos otros paquetes. Esto aumenta la probabilidad de que el paquete permanezca en CRAN sin interrupciones y que el mantenedor tenga un enfoque intencional para el ciclo de vida del software (Capítulo 21).\nFuncionalidad. Algunos paquetes implementan una funcionalidad crítica que se utiliza en muchos paquetes. En el tidyverse, ampliamente definido, los paquetes rlang, tidyselect, vctrs y tibble son ejemplos de esto. Al utilizar estos paquetes para tareas complicadas como evaluación no estándar o manipulación de vectores y marcos de datos, los autores de paquetes pueden evitar volver a implementar la funcionalidad básica. Es fácil pensar “¿qué tan difícil puede ser escribir mi propia X?” cuando estás enfocado en el Camino Feliz1. Pero una gran parte del valor que aportan paquetes como vctrs o tibble es permitir que otra persona se preocupe por los casos extremos y el manejo de errores2 . También es valioso tener un comportamiento compartido con otros paquetes, por ejemplo, las reglas de tidyverse para reparación de nombres o reciclaje.\n\nEs de esperar que los detalles anteriores dejen en claro que las dependencias de los paquetes no son iguales.\n\n10.1.2 Prefiere un enfoque holístico, equilibrado y cuantitativo\nEn lugar de esforzarse por lograr un número mínimo de dependencias, recomendamos un enfoque más holístico, equilibrado y cuantitativo.\nUn enfoque holístico analiza el proyecto como un todo y pregunta “¿quién es el público principal?”. Si la audiencia son otros autores de paquetes, entonces un paquete más sencillo con menos dependencias puede ser más apropiado. Si, en cambio, el usuario objetivo es un científico de datos o un estadístico, probablemente ya tendrá instaladas muchas dependencias populares y se beneficiaría de un paquete con más funciones.\nUn enfoque equilibrado comprende que agregar (o eliminar) dependencias conlleva compensaciones. Agregar una dependencia le brinda funciones adicionales, correcciones de errores y pruebas en el mundo real, a costa de un mayor tiempo de instalación, espacio en disco y mantenimiento, si la dependencia tiene cambios importantes. En algunos casos, tiene sentido aumentar las dependencias de un paquete, incluso si ya existe una implementación. Por ejemplo, base R tiene varias implementaciones diferentes de evaluación no estándar con diferentes semánticas entre sus funciones. Lo mismo solía ocurrir con los paquetes tidyverse, pero ahora todos dependen de las implementaciones en tidyselect y rlang paquetes. Los usuarios se benefician de la coherencia mejorada de esta característica y los desarrolladores de paquetes individuales pueden dejar que los mantenedores de tidyselect y rlang se preocupen por los detalles técnicos.\nPor el contrario, eliminar una dependencia reduce el tiempo de instalación, el espacio en disco y evita posibles cambios importantes. Sin embargo, significa que su paquete tendrá menos funciones o que deberá volver a implementarlas usted mismo. Esto, a su vez, requiere tiempo de desarrollo e introduce nuevos errores. Una ventaja de utilizar una solución existente es que obtendrá el beneficio de todos los errores que ya se han descubierto y solucionado. Especialmente si muchos otros paquetes dependen de la dependencia, este es un regalo que sigue dando.\nDe manera similar a la optimización del rendimiento, si le preocupa la carga de las dependencias, tiene sentido abordar esas preocupaciones de una manera específica y cuantitativa. El paquete experimental itdepends fue creado para la charla y publicación de blog en los que se basa esta sección. Sigue siendo una fuente útil de ideas concretas (y código) para analizar qué tan pesada es una dependencia. El paquete pak también tiene varias funciones que son útiles para el análisis de dependencias:\n\npak::pkg_deps_tree(\"tibble\")\n#&gt; tibble 3.1.8 ✨\n#&gt; ├─fansi 1.0.3 ✨\n#&gt; ├─lifecycle 1.0.3 ✨\n#&gt; │ ├─cli 3.4.1 ✨ ⬇ (1.28 MB)\n#&gt; │ ├─glue 1.6.2 ✨\n#&gt; │ └─rlang 1.0.6 ✨ ⬇ (1.81 MB)\n#&gt; ├─magrittr 2.0.3 ✨\n#&gt; ├─pillar 1.8.1 ✨ ⬇ (673.95 kB)\n#&gt; │ ├─cli\n#&gt; │ ├─fansi\n#&gt; │ ├─glue\n#&gt; │ ├─lifecycle\n#&gt; │ ├─rlang\n#&gt; │ ├─utf8 1.2.2 ✨\n#&gt; │ └─vctrs 0.5.1 ✨ ⬇ (1.82 MB)\n#&gt; │   ├─cli\n#&gt; │   ├─glue\n#&gt; │   ├─lifecycle\n#&gt; │   └─rlang\n#&gt; ├─pkgconfig 2.0.3 ✨\n#&gt; ├─rlang\n#&gt; └─vctrs\n#&gt;\n#&gt; Key:  ✨ new |  ⬇ download\n\npak::pkg_deps_explain(\"tibble\", \"rlang\")\n#&gt; tibble -&gt; lifecycle -&gt; rlang\n#&gt; tibble -&gt; pillar -&gt; lifecycle -&gt; rlang\n#&gt; tibble -&gt; pillar -&gt; rlang\n#&gt; tibble -&gt; pillar -&gt; vctrs -&gt; lifecycle -&gt; rlang\n#&gt; tibble -&gt; pillar -&gt; vctrs -&gt; rlang\n#&gt; tibble -&gt; rlang\n#&gt; tibble -&gt; vctrs -&gt; lifecycle -&gt; rlang\n#&gt; tibble -&gt; vctrs -&gt; rlang\n\n\n10.1.3 Pensamientos de dependencia específicos del tidyverse\nLos paquetes mantenidos por el equipo de tidyverse desempeñan diferentes funciones en el ecosistema y se gestionan en consecuencia. Por ejemplo, los paquetes tidyverse y devtools son esencialmente metapaquetes que existen para comodidad del usuario final. En consecuencia, se recomienda que otros paquetes no dependan de tidyverse3 o devtools (Sección 2.2), es decir, estos dos paquetes casi nunca deberían aparecer en Imports . En cambio, un mantenedor de paquetes debe identificar y depender del paquete específico que realmente implementa la funcionalidad deseada.\nEn la sección anterior hablamos de diferentes formas de medir el peso de una dependencia. Tanto tidyverse como devtools pueden considerarse pesados ​​debido al gran número de dependencias recursivas:\n\nn_hard_deps &lt;- function(pkg) {\n  deps &lt;- tools::package_dependencies(pkg, recursive = TRUE)\n  sapply(deps, length)\n}\n\nn_hard_deps(c(\"tidyverse\", \"devtools\"))\n#&gt; Warning: unable to access index for repository http://cran.us.r-project.org /src/contrib:\n#&gt;   cannot open URL 'http://cran.us.r-project.org /src/contrib/PACKAGES'\n#&gt; tidyverse  devtools \n#&gt;         0         0\n\nPor el contrario, varios paquetes están concebidos específicamente como paquetes de bajo nivel que implementan características que deberían funcionar y sentirse igual en todo el ecosistema. Al momento de escribir este artículo, esto incluye:\n\nrlang, para soportar la evaluación ordenada y arrojar errores\ncli y pegamento, para crear una interfaz de usuario rica (que incluye errores)\nwithr, para gestionar el estado de manera responsable\nciclo de vida, para gestionar el ciclo de vida de funciones y argumentos\n\nBásicamente, se consideran dependencias gratuitas y se pueden agregar a DESCRIPTION mediante usethis::use_tidy_dependencies() (que también hace algunas cosas más). No debería sorprender que estos paquetes tengan una huella de dependencia muy pequeña.\n\ntools::package_dependencies(c(\"rlang\", \"cli\", \"glue\", \"withr\", \"lifecycle\"))\n#&gt; Warning: unable to access index for repository http://cran.us.r-project.org /src/contrib:\n#&gt;   cannot open URL 'http://cran.us.r-project.org /src/contrib/PACKAGES'\n#&gt; $rlang\n#&gt; NULL\n#&gt; \n#&gt; $cli\n#&gt; NULL\n#&gt; \n#&gt; $glue\n#&gt; NULL\n#&gt; \n#&gt; $withr\n#&gt; NULL\n#&gt; \n#&gt; $lifecycle\n#&gt; NULL\n\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nBajo ciertas configuraciones, incluidas aquellas utilizadas para envíos CRAN entrantes, R CMD check emite una nota si hay 20 o más paquetes “no predeterminados” en Imports:\nN  checking package dependencies (1.5s)\n   Imports includes 29 non-default packages.\n   Importing from so many packages makes the package vulnerable to any of\n   them becoming unavailable.  Move as many as possible to Suggests and\n   use conditionally.\nNuestro mejor consejo es esforzarse por cumplirlo, ya que debería ser bastante raro necesitar tantas dependencias y es mejor eliminar cualquier nota que pueda. Por supuesto, hay excepciones a cada regla, y quizás su paquete sea una de ellas. En ese caso, es posible que deba defender su caso. Es cierto que muchos paquetes CRAN violan este umbral.\n\n\n\n10.1.4 Ya sea para importar o sugerir\nEl paquete withr es un buen caso de estudio para decidir si incluir una dependencia en Imports o Suggests. withr es muy útil para escribir pruebas que se limpian por sí solas. Dicho uso es compatible con incluir withr en Suggests, ya que los usuarios habituales no necesitan ejecutar las pruebas. Pero a veces un paquete también puede usar withr en sus propias funciones, tal vez para ofrecer sus propias funciones with_*() y local_*(). En ese caso, withr debería aparecer en Imports.\nLas “Importaciones” y las “Sugerencias” difieren en la intensidad y naturaleza de la dependencia:\n\n\nImports: los paquetes enumerados aquí deben estar presentes para que su paquete funcione. Cada vez que se instala su paquete, esos paquetes también se instalarán, si aún no están presentes. devtools::load_all() también verifica que todos los paquetes en Imports estén instalados.\nVale la pena señalar que agregar un paquete a Imports garantiza que se instalará y eso es todo. No tiene nada que ver con importar funciones de ese paquete. Consulte Sección 11.4 para obtener más información sobre cómo usar un paquete en Imports.\n\n\nSuggests: su paquete puede usar estos paquetes, pero no los requiere. Puede utilizar paquetes sugeridos, por ejemplo, conjuntos de datos, para ejecutar pruebas, crear viñetas o tal vez solo haya una función que necesite el paquete.\nLos paquetes enumerados en Suggests no se instalan automáticamente junto con su paquete. Esto significa que no puede asumir que sus usuarios han instalado todos los paquetes sugeridos, pero sí puede asumir que los desarrolladores sí. Consulte Sección 11.5 para saber cómo comprobar si un paquete sugerido está instalado.\n\n\nLas “sugerencias” no son muy relevantes para paquetes donde la base de usuarios es aproximadamente igual al equipo de desarrollo o para paquetes que se utilizan en un contexto muy predecible. En ese caso, es razonable usar “Importaciones” para todo. El uso de “Sugerencias” es principalmente una cortesía para los usuarios externos o para adaptarse a instalaciones muy sencillas. Puede liberar a los usuarios de la descarga de paquetes que rara vez necesitan (especialmente aquellos que son difíciles de instalar) y les permite comenzar con su paquete lo más rápido posible.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html#sec-dependencies-namespace",
    "href": "dependencies-mindset-background.html#sec-dependencies-namespace",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "\n10.2 Espacio de nombres",
    "text": "10.2 Espacio de nombres\nHasta ahora, hemos explicado la mecánica de declarar una dependencia en DESCRIPTION (Sección 9.6) y cómo analizar los costos y beneficios de las dependencias (Sección 10.1). Antes de explicar cómo usar sus dependencias en varias partes de su paquete en Capítulo 11, necesitamos establecer los conceptos de un espacio de nombres de paquete y la ruta de búsqueda.\n\n10.2.1 Motivación\nComo sugiere el nombre, los espacios de nombres proporcionan “espacios” para “nombres”. Proporcionan un contexto para buscar el valor de un objeto asociado con un nombre.\nSin saberlo, probablemente ya hayas utilizado espacios de nombres. ¿Ha utilizado alguna vez el operador ::? Elimina la ambigüedad de funciones con el mismo nombre. Por ejemplo, los paquetes lubridate y here proporcionan una función here(). Si adjunta lubridate primero, entonces aquí, here() se referirá a la versión de here, porque gana el último paquete adjunto. Pero si adjunta los paquetes en el orden opuesto, here() se referirá a la versión lubridate.\n\nlibrary(lubridate)    |  library(here)\nlibrary(here)         |  library(lubridate)\n\nhere() # here::here() |  here() # lubridate::here()\n\nEsto puede resultar confuso. En su lugar, puede calificar la llamada a la función con un espacio de nombres específico: lubridate::here() y here::here(). Entonces el orden en el que se adjuntan los paquetes no importará4.\n\nlubridate::here() # always gets lubridate::here()\nhere::here()      # always gets here::here()\n\nComo verá en Sección 11.4, el estilo de llamada package::function() también es nuestra recomendación predeterminada sobre cómo usar sus dependencias en el código debajo de R/, porque elimina toda ambigüedad. .\nPero, en el contexto del código del paquete, el uso de :: no es realmente nuestra principal línea de defensa contra la confusión vista en el ejemplo anterior. En los paquetes, confiamos en los espacios de nombres para garantizar que todos los paquetes funcionen de la misma manera independientemente de qué paquetes adjunte el usuario.\nConsidere la función sd() del paquete de estadísticas que forma parte de la base R:\n\nsd\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x55682cc1b338&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nSe define en términos de otra función, var(), también del paquete de estadísticas. Entonces, ¿qué sucede si anulamos var() con nuestra propia definición? ¿Se rompe sd()?\n\nvar &lt;- function(x) -5\nvar(1:5)\n#&gt; [1] -5\n\nsd(1:5)\n#&gt; [1] 1.58\n\n¡Sorprendentemente no es así! Esto se debe a que cuando sd() busca un objeto llamado var(), busca primero en el espacio de nombres del paquete de estadísticas, por lo que encuentra stats::var(), no el var() que creamos en el entorno mundial. Sería un caos si funciones como sd() pudieran ser interrumpidas por un usuario redefiniendo var() o adjuntando un paquete que anule var(). El sistema de espacio de nombres del paquete es lo que nos salva de este destino.\n\n10.2.2 El archivo NAMESPACE\n\nEl archivo NAMESPACE juega un papel clave en la definición del espacio de nombres de su paquete. Aquí hay líneas seleccionadas del archivo NAMESPACE en el paquete testthat:\n# Generado por roxygen2: no editar a mano\n\nS3method(compare,character)\nS3method(print,testthat_results)\nexport(compare)\nexport(expect_equal)\nimport(rlang)\nimportFrom(brio,readLines)\nuseDynLib(testthat, .registration = TRUE)\nLa primera línea anuncia que este archivo no está escrito a mano, sino que lo genera el paquete roxygen2. Volveremos a este tema pronto, después de discutir las líneas restantes.\nPuede ver que el archivo NAMESPACE se parece un poco al código R (pero no lo es). Cada línea contiene una directiva: S3method(), export(), importFrom(), etc. Cada directiva describe un objeto R e indica si se exporta desde este paquete para ser utilizado por otros o si se importa desde otro paquete para ser utilizado internamente.\nEstas directivas son las más importantes en nuestro enfoque de desarrollo, en orden de frecuencia:\n\n\nexport(): exporta una función (incluidos los genéricos S3 y S4).\n\nS3method(): exporta un método S3.\n\nimportFrom(): importa el objeto seleccionado desde otro espacio de nombres (incluidos los genéricos de S4).\n\nimport(): importa todos los objetos del espacio de nombres de otro paquete.\n\nuseDynLib(): registra rutinas desde una DLL (esto es específico de paquetes con código compilado).\n\nHay otras directivas que no cubriremos aquí porque se desaconsejan explícitamente o simplemente rara vez aparecen en nuestro trabajo de desarrollo.\n\n\nexportPattern(): exporta todas las funciones que coinciden con un patrón. Creemos que es más seguro utilizar siempre exportaciones explícitas y evitamos el uso de esta directiva.\n\nexportClasses(), exportMethods(), importClassesFrom(), importMethodsFrom(): exporta e importa clases y métodos S4. Sólo trabajamos en el sistema S4 cuando es necesario por compatibilidad con otro paquete, es decir, generalmente no implementamos métodos o clases que poseemos con S4. Por lo tanto, la cobertura de S4 en este libro es mínima.\n\nEn el flujo de trabajo de devtools, el archivo NAMESPACE no está escrito a mano. En su lugar, preferimos generar NAMESPACE con el paquete roxygen2, usando etiquetas específicas ubicadas en un comentario de roxygen encima de la definición de cada función en los archivos R/*.R (Sección 11.3). Tendremos mucho más que decir sobre los comentarios de roxygen y el paquete roxygen2 cuando analicemos la documentación del paquete en Capítulo 16. Por ahora, solo exponemos las razones por las que preferimos este método de generar el archivo NAMESPACE:\n\nLas etiquetas de espacio de nombres están integradas en el código fuente, por lo que cuando lees el código es más fácil ver qué se exporta e importa y por qué.\nRoxygen2 abstrae algunos de los detalles de NAMESPACE. Solo necesita aprender una etiqueta, @export, y roxygen2 determinará qué directiva específica usar, en función de si el objeto asociado es una función normal, un método S3, un método S4 o una clase S4.\nRoxygen2 mantiene ordenado NAMESPACE. No importa cuántas veces aparezca @importFrom foo bar en tus comentarios de roxygen, solo obtendrás un importFrom(foo, bar) en tu NAMESPACE. Roxygen2 también mantiene NAMESPACE organizado en un orden de principio, ordenándolo primero por tipo de directiva y luego alfabéticamente. Roxygen2 elimina la carga de escribir NAMESPACE y al mismo tiempo intenta mantener el archivo lo más legible posible. Esta organización también hace que las diferencias de Git sean mucho más informativas.\n\nTenga en cuenta que puede optar por utilizar roxygen2 para generar solo NAMESPACE, solo man/*.Rd (Capítulo 16), o ambos (como es nuestra práctica). Si no utiliza ninguna etiqueta relacionada con el espacio de nombres, roxygen2 no tocará NAMESPACE. Si no utiliza ninguna etiqueta relacionada con la documentación, roxygen2 no tocará man/.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html#sec-dependencies-search",
    "href": "dependencies-mindset-background.html#sec-dependencies-search",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "\n10.3 Ruta de búsqueda",
    "text": "10.3 Ruta de búsqueda\nPara comprender por qué los espacios de nombres son importantes, necesita un conocimiento sólido de las rutas de búsqueda. Para llamar a una función, R primero tiene que encontrarla. Esta búsqueda se desarrolla de manera diferente para el código de usuario que para el código de paquete y eso se debe al sistema de espacio de nombres.\n\n10.3.1 Búsqueda de funciones para el código de usuario\nEl primer lugar donde R busca un objeto es el entorno global. Si R no lo encuentra allí, busca en la ruta de búsqueda, la lista de todos los paquetes que ha adjuntado. Puede ver esta lista ejecutando search(). Por ejemplo, aquí está la ruta de búsqueda del código de este libro:\n\nsearch()\n#&gt;  [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n#&gt;  [4] \"package:grDevices\" \"package:datasets\"  \"renv:shims\"       \n#&gt;  [7] \"package:utils\"     \"package:methods\"   \"Autoloads\"        \n#&gt; [10] \"package:base\"\n\nEsto tiene una forma específica (ver Figura 10.1):\n\nEl medio ambiente global.\nLos paquetes que se han adjuntado, por ejemplo, mediante library(), desde el más reciente hasta el menos adjunto.\n\nAutocargas, un entorno especial que utiliza enlaces retrasados ​​para ahorrar memoria cargando solo objetos de paquete (como grandes conjuntos de datos) cuando sea necesario.\nEl entorno base, por lo que nos referimos al entorno del paquete base.\n\n\n\n\n\n\n\n\nFigura 10.1: Estado típico de la ruta de búsqueda.\n\n\n\n\nCada elemento en la ruta de búsqueda tiene el siguiente elemento como padre, es decir, se trata de una cadena de entornos que se buscan en orden. En el diagrama, esta relación se muestra como un pequeño círculo azul con una flecha que apunta al padre. El primer entorno (el entorno global) y los dos últimos (Autoloads y el entorno base) son especiales y mantienen su posición.\nPero la sección intermedia de paquetes adjuntos es más dinámica. Cuando se adjunta un nuevo paquete, se inserta inmediatamente después y se convierte en el padre del entorno global. Cuando adjuntas otro paquete con library(), cambia la ruta de búsqueda, como se muestra en Figura 10.2:\n\n\n\n\n\n\n\nFigura 10.2: Se inserta un paquete recién adjunto en la ruta de búsqueda.\n\n\n\n\nEl problema principal sobre cómo funciona la ruta de búsqueda del usuario es el escenario que exploramos en Sección 10.2.1, donde dos paquetes (lubridate y aquí) ofrecen funciones competitivas con el mismo nombre (here()). Ahora debería quedar muy claro por qué la llamada de un usuario a here() puede producir un resultado diferente, dependiendo del orden en el que adjuntó los dos paquetes.\nEste tipo de confusión sería aún más perjudicial si se aplicara al código del paquete, pero afortunadamente no es así. Ahora podemos explicar cómo el sistema de espacio de nombres elimina este problema.\n\n10.3.2 Búsqueda de funciones dentro de un paquete\nEn Sección 10.2.1, demostramos que la definición de un usuario de una función llamada var() no rompe stats::sd(). De alguna manera, para nuestro inmenso alivio, stats::sd() encuentra stats::var() cuando debería. ¿Cómo funciona?\nEsta sección es algo técnica y es absolutamente posible desarrollar un paquete con un espacio de nombres con buen comportamiento sin comprender completamente estos detalles. Considera esta lectura opcional que puedes consultar cuando y si estás interesado. Puedes aprender aún más en Advanced R, especialmente en el capítulo sobre entornos, del cual hemos adaptado parte de este material.\nCada función en un paquete está asociada con un par de entornos: el entorno del paquete, que es lo que aparece en la ruta de búsqueda del usuario, y el entorno espacio de nombres.\n\nEl entorno del paquete es la interfaz externa del paquete. Así es como un usuario normal de R encuentra una función en un paquete adjunto o con ::. Su padre está determinado por la ruta de búsqueda, es decir, el orden en el que se han adjuntado los paquetes. El entorno del paquete solo expone objetos exportados.\nEl entorno del espacio de nombres es la interfaz interna del paquete. Incluye todos los objetos del paquete, tanto exportados como no exportados. Esto garantiza que cada función pueda encontrar todas las demás funciones en el paquete. Cada enlace en el entorno del paquete también existe en el entorno del espacio de nombres, pero no viceversa.\n\nFigura 10.3 representa la función sd() como un rectángulo con un extremo redondeado. Las flechas de paquete:stats y namespace:stats muestran que sd() está vinculado en ambos. Pero la relación no es simétrica. El círculo negro con una flecha que apunta hacia namespace:stats indica dónde sd() buscará los objetos que necesita: en el entorno del espacio de nombres, no en el entorno del paquete.\n\n\n\n\n\n\n\nFigura 10.3: Una función exportada está vinculada en el entorno del paquete y en el espacio de nombres, pero solo vincula el espacio de nombres.\n\n\n\n\n\nEl entorno del paquete controla cómo los usuarios encuentran la función; el espacio de nombres controla cómo la función encuentra sus variables.\n\nCada entorno de espacio de nombres tiene el mismo conjunto de ancestros, como se muestra en Figura 10.4:\n\nCada espacio de nombres tiene un entorno importaciones que puede contener enlaces a funciones utilizadas por el paquete que están definidas en otro paquete. El entorno de importaciones lo controla el desarrollador del paquete con el archivo NAMESPACE. Específicamente, directivas como importFrom() e imports() pueblan este entorno.\nImportar explícitamente cada función base sería tedioso, por lo que el padre del entorno de importaciones es el espacio de nombres base. El espacio de nombres base contiene los mismos enlaces que el entorno base, pero tiene un padre diferente.\nEl padre del espacio de nombres base es el entorno global. Esto significa que si un enlace no está definido en el entorno de importaciones, el paquete lo buscará de la forma habitual. Esto suele ser una mala idea (porque hace que el código dependa de otros paquetes cargados), por lo que R CMD check advierte automáticamente sobre dicho código. Es necesario principalmente por razones históricas, particularmente debido a cómo funciona el envío del método S3.\n\n\n\n\n\n\n\n\nFigura 10.4: El entorno del espacio de nombres tiene el entorno imports como padre, que hereda del entorno de espacio de nombres del paquete base y, en última instancia, el medio ambiente global.\n\n\n\n\nFinalmente, podemos juntarlo todo en este último diagrama, Figura 10.5. Esto muestra la ruta de búsqueda del usuario, en la parte inferior, y la ruta de búsqueda de estadísticas internas, en la parte superior.\n\n\n\n\n\n\n\nFigura 10.5: Para el código de usuario, los objetos se encuentran utilizando la ruta de búsqueda, mientras que el paquete El código utiliza el espacio de nombres.\n\n\n\n\nUn usuario (o algún paquete que esté usando) es libre de definir una función llamada var(). Pero cuando ese usuario llama a sd(), siempre llamará a stats::var() porque sd() busca en una secuencia de entornos determinados por el paquete de estadísticas, no por el usuario. Así es como el sistema de espacio de nombres garantiza que el código del paquete siempre funcione de la misma manera, independientemente de lo que se haya definido en el entorno global o de lo que se haya adjuntado.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html#sec-dependencies-attach-vs-load",
    "href": "dependencies-mindset-background.html#sec-dependencies-attach-vs-load",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "\n10.4 Adjuntar versus cargar",
    "text": "10.4 Adjuntar versus cargar\nEs común escuchar algo como “usamos library(algúnpaquete) para cargar algún paquete”. Pero técnicamente library() adjunta un paquete a la ruta de búsqueda. Este abuso casual de la terminología suele ser inofensivo e incluso puede resultar beneficioso en algunos entornos. Pero a veces es importante ser preciso y pedante y éste es uno de esos momentos. Los desarrolladores de paquetes necesitan saber la diferencia entre adjuntar y cargar un paquete y cuándo preocuparse por esta diferencia.\nSi hay un paquete instalado,\n\nCargar cargará código, datos y cualquier archivo DLL; registrar los métodos S3 y S4; y ejecute la función .onLoad(). Después de cargarlo, el paquete está disponible en la memoria, pero como no está en la ruta de búsqueda, no podrá acceder a sus componentes sin usar ::. De manera confusa, :: también cargará un paquete automáticamente si aún no está cargado.\nAdjuntar coloca el paquete en la ruta de búsqueda (Sección 10.3.1). No puede adjuntar un paquete sin cargarlo primero, por lo que library() (o require()) cargan y luego adjuntan el paquete. Esto también ejecuta la función .onAttach().\n\nHay cuatro funciones que hacen que un paquete esté disponible, que se muestran en Tabla 10.1. Se diferencian según si se cargan o adjuntan y qué sucede si no se encuentra el paquete (es decir, arroja un error o devuelve FALSE).\n\n\nTabla 10.1: Funciones que cargan o adjuntan un paquete.\n\n\n\n\n\n\n\n\n\nArroja un error\nDevulve FALSE\n\n\n\n\nCargar\nloadNamespace(\"x\")\nrequireNamespace(\"x\", quietly = TRUE)\n\n\nAdjuntar\nlibrary(x)\nrequire(x, quietly = TRUE)\n\n\n\n\n\n\nDe las cuatro, estas dos funciones son, con diferencia, las más útiles:\n\nUtilice library(x) en, por ejemplo, un script de análisis de datos o una viñeta. Generará un error si el paquete no está instalado y finalizará el script. Desea adjuntar el paquete para ahorrar escritura. Nunca use library() en el código del paquete debajo de R/ o tests/.\nUtilice requireNamespace(\"x\", quietly = TRUE) dentro de un paquete si desea especificar un comportamiento diferente dependiendo de si un paquete sugerido está instalado o no. Tenga en cuenta que esto también carga el paquete. Damos ejemplos en Sección 11.5.1.\n\nloadNamespace() es algo esotérico y en realidad solo es necesario para el código R interno.\nrequire(pkg) casi nunca es una buena idea5 y, sospechamos, puede provenir de personas que proyectan ciertas esperanzas y sueños en el nombre de la función. Irónicamente, require(pkg) en realidad no requiere éxito al adjuntar el paquete y su función o script continuará incluso en caso de falla. Esto, a su vez, a menudo conduce a un error muy desconcertante mucho más tarde. Si desea “adjuntar o fallar”, use library(). Si desea verificar si el paquete está disponible y proceder en consecuencia, use requireNamespace(\"pkg\", quietly = TRUE).\nUn uso razonable de require() es en un ejemplo que usa un paquete que su paquete sugiere, que se analiza con más detalle en Sección 11.5.3.\nLas funciones .onLoad() y .onAttach() mencionadas anteriormente son dos de varios ganchos que le permiten ejecutar código específico cuando su paquete está cargado o adjunto (o, incluso, desconectado o descargado). La mayoría de los paquetes no necesitan esto, pero estos ganchos son útiles en determinadas situaciones. Consulte Sección 6.5.4 para conocer algunos casos de uso de .onLoad() y .onAttach().\n\n10.4.1 Ya sea para importar o depender\nAhora estamos en condiciones de establecer la diferencia entre Depends e Imports en el archivo DESCRIPTION. Incluir un paquete en “dependencia” o “importaciones” garantiza que se instale cuando sea necesario. La principal diferencia es que un paquete que usted enumere en Imports simplemente se cargará cuando lo use, mientras que un paquete que usted enumere en Dependsse adjuntará cuando su paquete esté adjunto.\nA menos que exista una buena razón para lo contrario, siempre debe enumerar los paquetes en Imports, no en Depends. Esto se debe a que un buen paquete es autónomo y minimiza los cambios en el panorama global, incluida la ruta de búsqueda.6\nLos usuarios de devtools en realidad están expuestos regularmente al hecho de que devtools “depende” de usethis:\n\nlibrary(devtools)\n#&gt; Loading required package: usethis\n\nsearch()\n#&gt;  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n#&gt;  ...\n\nEsta elección está motivada por la compatibilidad con versiones anteriores. Cuando devtools se dividió en varios paquetes más pequeños (Sección 2.2), muchas de las funciones orientadas al usuario pasaron a usaethis. Poner usethis en dependencias fue una elección pragmática para evitar que los usuarios realicen un seguimiento de qué función terminó y dónde.\nUn ejemplo más clásico de dependencia es cómo el paquete censored depende de los paquetes parsnip y surival. parsnip proporciona una interfaz unificada para ajustar modelos y censored es un paquete de extensión para análisis de supervivencia. censored no es útil sin parsnip y survival, por lo que tiene sentido enumerarlos en Depends.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-mindset-background.html#footnotes",
    "href": "dependencies-mindset-background.html#footnotes",
    "title": "10  Dependencias: mentalidad y antecedentes",
    "section": "",
    "text": "En programación, Happy Path es el escenario donde todas las entradas tienen sentido y son exactamente como las cosas “deberían ser”. El Camino Infeliz es todo lo demás (objetos de longitud o dimensión cero, objetos a los que les faltan datos, dimensiones o atributos, objetos que no existen, etc.).↩︎\nAntes de escribir su propia versión de X, eche un vistazo al rastreador de errores y al conjunto de pruebas de otro paquete que implemente X. Esto puede resultar útil para apreciar lo que realmente está involucrado.↩︎\nHay una publicación de blog que advierte a las personas que no dependan del paquete tidyverse: https://www.tidyverse.org/blog/2018/06/tidyverse-not-for-packages/.↩︎\nNos centraremos en los paquetes de este libro, pero hay otras formas además de usar :: para abordar conflictos en el código del usuario final: el paquete en conflicto y la opción \"conflicts.policy\" introducido en base R v3.6.0.↩︎\nLa publicación de blog clásica “library() vs require() en R” de Yihui Xie es otro buen recurso sobre esto.↩︎\nThomas Leeper creó varios paquetes de ejemplo para demostrar el comportamiento desconcertante que puede surgir cuando los paquetes usan Depends y compartió el trabajo en https://github.com/leeper/Depends. Esta demostración también subraya la importancia de usar :: (o importFrom()) al usar funciones externas en su paquete, como se recomienda en Capítulo 11.↩︎",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Dependencias: mentalidad y antecedentes</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html",
    "href": "dependencies-in-practice.html",
    "title": "11  Dependencias: en la práctica",
    "section": "",
    "text": "11.1 Confusión sobre Imports\nEste capítulo presenta los detalles prácticos de cómo trabajar con sus dependencias dentro de su paquete. Si necesita un repaso sobre cualquiera de los antecedentes:\nFinalmente estamos listos para hablar sobre cómo usar diferentes tipos de dependencias dentro de las diferentes partes de su paquete:\nDejemos esto muy claro:\nEs natural suponer que enumerar un paquete en Imports en realidad “importa” el paquete, pero esto es sólo una elección desafortunada de nombre para el campo Imports. El campo Imports garantiza que los paquetes enumerados allí estén instalados cuando se instala su paquete. No pone esas funciones a su disposición, por ejemplo debajo de R/, ni a su usuario.\nNo es automático ni necesariamente aconsejable que un paquete listado en Imports también aparezca en NAMESPACE a través de imports() o importFrom(). Es común que un paquete aparezca en Imports en DESCRIPTION, pero no en NAMESPACE. Lo contrario no es cierto. Cada paquete mencionado en NAMESPACE también debe estar presente en los campos Imports o Depends.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#confusión-sobre-imports",
    "href": "dependencies-in-practice.html#confusión-sobre-imports",
    "title": "11  Dependencias: en la práctica",
    "section": "",
    "text": "Incluir un paquete en Imports en DESCRIPTION no “importa” ese paquete.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#convenciones-para-este-capítulo",
    "href": "dependencies-in-practice.html#convenciones-para-este-capítulo",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.2 Convenciones para este capítulo",
    "text": "11.2 Convenciones para este capítulo\nA veces nuestros ejemplos pueden incluir funciones reales de paquetes reales. Pero si necesitamos hablar de un paquete o función genérica, estas son las convenciones que usamos a continuación:\n\npkg: el nombre de su paquete hipotético\naaapkg o bbbpkg: el nombre de un paquete hipotético del que depende su paquete\naaa_fun(): el nombre de una función exportada por aaapkg",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#sec-dependencies-NAMESPACE-workflow",
    "href": "dependencies-in-practice.html#sec-dependencies-NAMESPACE-workflow",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.3 Flujo de trabajo de NAMESPACE\n",
    "text": "11.3 Flujo de trabajo de NAMESPACE\n\nEn las secciones siguientes, brindamos instrucciones prácticas sobre cómo (y cuándo) importar funciones de otro paquete al suyo y cómo exportar funciones desde su paquete. El archivo que realiza un seguimiento de todo esto es el archivo NAMESPACE (más detalles en Sección 10.2.2).\nEn el flujo de trabajo de devtools y en este libro, generamos el archivo NAMESPACE a partir de comentarios especiales en los archivos R/*.R. Dado que el paquete que finalmente hace este trabajo es roxygen2, estos se denominan “comentarios de roxygen”. Estos comentarios de roxygen también son la base de los temas de ayuda de su paquete, que se tratan en Sección 16.1.1.\nEl archivo NAMESPACE comienza con una única línea comentada que explica la situación (y, con suerte, desaconseja cualquier edición manual):\n# Generated by roxygen2: do not edit by hand\nA medida que incorpora etiquetas roxygen para exportar e importar funciones, necesita volver a generar el archivo NAMESPACE periódicamente. Este es el flujo de trabajo general para regenerar NAMESPACE (y su documentación):\n\n\nAgregue etiquetas relacionadas con el espacio de nombres a los comentarios de roxygen en sus archivos R/*.R. Este es un ejemplo artificial, pero te da la idea básica:\n\n#' @importFrom aaapkg aaa_fun\n#' @import bbbpkg\n#' @export\nfoo &lt;- function(x, y, z) {\n  ...\n}\n\n\n\nEjecute devtools::document() (o presione Ctrl/Cmd + Shift + D en RStudio) para “documentar” su paquete. Por defecto, suceden dos cosas:\n\nLos temas de ayuda en los archivos man/*.Rd están actualizados (cubiertos en Capítulo 16).\n\nSe vuelve a generar el archivo NAMESPACE. En nuestro ejemplo, el archivo NAMESPACE se vería así:\n# Generated by roxygen2: do not edit by hand\n\nexport(foo)\nimport(bbbpkg)\nimportFrom(aaapkg,aaa_fun)\n\n\n\n\nRoxygen2 es bastante inteligente e insertará la directiva apropiada en NAMESPACE, es decir, generalmente puede determinar si usar export() o S3method().\n\n\n\n\n\n\nRStudio\n\n\n\nPresione Ctrl/Cmd + Shift + D para generar el NAMESPACE de su paquete (y los archivos man/*.Rd). Esto también está disponible a través de Document en el menú y panel Build.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#sec-dependencies-in-imports",
    "href": "dependencies-in-practice.html#sec-dependencies-in-imports",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.4 El paquete aparece en Imports\n",
    "text": "11.4 El paquete aparece en Imports\n\nConsidere una dependencia que aparece en DESCRIPTIO en Imports:\nImports:\n    aaapkg\nEl código dentro de su paquete puede asumir que aaapkg está instalado cada vez que se instala pkg.\n\n11.4.1 En el código debajo de R/\nNuestro valor predeterminado recomendado es llamar a funciones externas usando la sintaxis paquete::función():\n\nsomefunction &lt;- function(...) {\n  ...\n  x &lt;- aaapkg::aaa_fun(...)\n  ...\n}\n\nEspecíficamente, le recomendamos que de forma predeterminada no importe nada desde aaapkg a su espacio de nombres. Esto hace que sea muy fácil identificar qué funciones se encuentran fuera de su paquete, lo cual es especialmente útil cuando lea su código en el futuro. Esto también elimina cualquier preocupación sobre conflictos de nombres entre aaapkg y su paquete.\nPor supuesto, hay razones para hacer excepciones a esta regla e importar algo de otro paquete al suyo:\n\nUn operador: No puedes llamar a un operador desde otro paquete vía ::, por lo que debes importarlo. Ejemplos: el operador de fusión nula %||% de rlang o la canalización original %&gt;% de magrittr.\nUna función que usas mucho: si importar una función hace que tu código sea mucho más legible, esa es una buena razón para importarla. Esto literalmente reduce la cantidad de caracteres necesarios para llamar a la función externa. Esto puede ser especialmente útil al generar mensajes dirigidos al usuario, porque hace que sea más probable que las líneas del código fuente correspondan a las líneas de la salida.\nUna función que se llama en un bucle cerrado: hay una pequeña penalización de rendimiento asociada con ::. Es del orden de 100 ns, por lo que solo importará si llamas a la función millones de veces.\n\nUna función útil para su flujo de trabajo interactivo es usethis::use_import_from():\n\nusethis::use_import_from(\"glue\", \"glue_collapse\")\n\nLa llamada anterior escribe esta etiqueta roxygen en el código fuente de su paquete:\n\n#' @importFrom glue glue_collapse\n\n¿Dónde debería ir esta etiqueta de roxygen? Hay dos ubicaciones razonables:\n\nLo más parecido posible al uso de la función externa. Con esta mentalidad, colocaría @importFrom en el comentario de roxygen encima de la función en su paquete donde usa la función externa. Si este es tu estilo, tendrás que hacerlo a mano. Descubrimos que esto parece natural al principio, pero comienza a fallar a medida que se utilizan más funciones externas en más lugares.\n\nEn una ubicación central. Este enfoque mantiene todas las etiquetas @importFrom juntas, en una sección dedicada del archivo de documentación a nivel de paquete (que se puede crear con usethis::use_package_doc(), Sección 16.7). Esto es lo que implementa use_import_from(). Entonces, en R/pkg-package.R, terminarás con algo como esto:\n\n# El siguiente bloque es utilizado por usethis para administrar automáticamente\n# etiquetas de espacio de nombres de roxygen. ¡Modifique con cuidado!\n## usethis namespace: start\n#' @importFrom glue glue_collapse\n## usethis namespace: end\nNULL\n\n\n\nRecuerde que devtools::document() procesa sus comentarios de roxygen (Sección 11.3), que escribe temas de ayuda en man/*.Rd y, relevante para nuestro objetivo actual, genera el NAMESPACE archivo. Si usa use_import_from(), lo hace por usted y también llama a load_all(), haciendo que la función recién importada esté disponible en su sesión actual.\nLa etiqueta roxygen anterior hace que esta directiva aparezca en el archivo NAMESPACE:\nimportFrom(glue, glue_collapse)\nAhora puedes usar la función importada directamente en tu código:\n\nsomefunction &lt;- function(...) {\n  ...\n  x &lt;- glue_collapse(...)\n  ...\n}\n\nA veces haces un uso tan intenso de tantas funciones de otro paquete que deseas importar su espacio de nombres completo. Esto debería ser relativamente raro. En tidyverse, el paquete que más comúnmente tratamos de esta manera es rlang, que funciona casi como un paquete base para nosotros.\nAquí está la etiqueta roxygen que importa todo rlang. Esto debería aparecer en algún lugar de R/*.R, como el espacio dedicado descrito anteriormente para recopilar todas las etiquetas de importación de espacios de nombres.\n\n#' @import rlang\n\nDespués de llamar a devtools::document(), esta etiqueta roxygen hace que esta directiva aparezca en el archivo NAMESPACE:\nimport(rlang)\nEsta es la solución menos recomendada porque puede hacer que su código sea más difícil de leer (no puede saber de dónde proviene una función) y si @importa muchos paquetes, aumenta la posibilidad de que se produzcan conflictos con los nombres de las funciones. Guárdelo para situaciones muy especiales.\n\n11.4.1.1 Cómo no usar un paquete en Importaciones\nA veces tienes un paquete listado en Imports, pero en realidad no lo usas dentro de tu paquete o, al menos, R no cree que lo uses. Eso lleva a una NOTE de R CMD check:\n* checking dependencies in R code ... NOTE\nNamespace in Imports field not imported from: ‘aaapkg’\n  All declared Imports should be used.\nEsto puede suceder si necesita enumerar una dependencia indirecta en “Importaciones”, tal vez para indicar una versión mínima para ella. El metapaquete tidyverse tiene este problema a gran escala, ya que existe principalmente para instalar un conjunto de paquetes en versiones específicas. Otro escenario es cuando su paquete usa una dependencia de tal manera que requiere otro paquete que solo es sugerido por la dependencia directa1. Hay varias situaciones en las que no es obvio que su paquete realmente necesite todos los paquetes enumerados en “Importaciones”, pero de hecho es así.\n¿Cómo puede deshacerse de esta “NOTA”?\nNuestra recomendación es colocar una referencia calificada de espacio de nombres (no una llamada) a un objeto en aaapkg en algún archivo debajo de R/, como un archivo .R asociado con la configuración de todo el paquete:\n\nignore_unused_imports &lt;- function() {\n  aaapkg::aaa_fun\n}\n\nNo es necesario llamar a ignore_unused_imports() en ningún lado. No deberías exportarlo. En realidad, no es necesario ejercitar aaapkg::aaa_fun(). Lo importante es acceder a algo en el espacio de nombres de aaapkg con ::.\nUn método alternativo que podría verse tentado a utilizar es importar aaapkg::aaa_fun() al espacio de nombres de su paquete, probablemente con la etiqueta roxygen @importFrom aaapkg aaa_fun. Esto suprime la “NOTA”, pero también hace más. Esto hace que aaapkg se cargue cada vez que se carga su paquete. Por el contrario, si utiliza el método que recomendamos, el aaapkg sólo se cargará si su usuario hace algo que realmente lo requiera. Esto rara vez importa en la práctica, pero siempre es bueno minimizar o retrasar la carga de paquetes adicionales.\n\n11.4.2 En el código de prueba\nConsulte las funciones externas en sus pruebas tal como las hace en el código debajo de R/. Generalmente esto significa que debes usar aaapkg::aaa_fun(). Pero si ha importado una función particular, ya sea específicamente o como parte de un espacio de nombres completo, puede llamarla directamente en su código de prueba.\nGeneralmente es una mala idea usar library(aaapkg) para adjuntar una de sus dependencias en algún lugar de sus pruebas, porque hace que la ruta de búsqueda en sus pruebas sea diferente de cómo funciona realmente su paquete. Esto se trata con más detalle en Sección 14.2.5.\n\n11.4.3 En ejemplos y viñetas\nSi usa un paquete que aparece en Imports en uno de sus ejemplos o viñetas, deberá adjuntar el paquete con library(aaapkg) o usar una llamada de estilo aaapkg::aaa_fun(). Puedes asumir que aaapkg está disponible, porque eso es lo que garantiza Imports. Lea más en Sección 16.5.4 y Sección 17.4.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#sec-dependencies-in-suggests",
    "href": "dependencies-in-practice.html#sec-dependencies-in-suggests",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.5 El paquete aparece en Suggests\n",
    "text": "11.5 El paquete aparece en Suggests\n\nConsidere una dependencia que aparece en DESCRIPTION en Suggests:\nSuggests:\n    aaapkg\nNO puede asumir que todos los usuarios han instalado aaapkg (pero puede asumir que un desarrollador sí lo ha hecho). Que un usuario tenga aaapkg dependerá de cómo instaló su paquete. La mayoría de las funciones que se utilizan para instalar paquetes admiten un argumento de “dependencias” que controla si se instalan solo las dependencias físicas o se adopta un enfoque más amplio, que incluye paquetes sugeridos:\n\ninstall.packages(dependencies =)\nremotes::install_github(dependencies =)\npak::pkg_install(dependencies =)\n\nEn términos generales, lo predeterminado es no instalar paquetes en Suggests.\n\n11.5.1 En el código debajo de R/\n\nDentro de una función en su propio paquete, verifique la disponibilidad de un paquete sugerido con requireNamespace(\"aaapkg\", quietly = TRUE). Hay dos escenarios básicos: la dependencia es absolutamente necesaria o su paquete ofrece algún tipo de comportamiento alternativo.\n\n# el paquete sugerido es obligatorio \nmy_fun &lt;- function(a, b) {\n  if (!requireNamespace(\"aaapkg\", quietly = TRUE)) {\n    stop(\n      \"Package \\\"aaapkg\\\" must be installed to use this function.\",\n      call. = FALSE\n    )\n  }\n  # código que incluye llamadas como aaapkg::aaa_fun()\n}\n\n# el paquete sugerido es opcional; hay un método alternativo disponible\nmy_fun &lt;- function(a, b) {\n  if (requireNamespace(\"aaapkg\", quietly = TRUE)) {\n    aaapkg::aaa_fun()\n  } else {\n    g()\n  }\n}\n\nEl paquete rlang tiene algunas funciones útiles para comprobar la disponibilidad del paquete: rlang::check_installed() y rlang::is_installed(). Así es como podrían verse las comprobaciones de un paquete sugerido si usas rlang:\n\n# el paquete sugerido es obligatorio\nmy_fun &lt;- function(a, b) {\n  rlang::check_installed(\"aaapkg\", reason = \"to use `aaa_fun()`\")\n  # código que incluye llamadas como aaapkg::aaa_fun()\n}\n\n# el paquete sugerido es opcional; hay un método alternativo disponible\nmy_fun &lt;- function(a, b) {\n  if (rlang::is_installed(\"aaapkg\")) {\n    aaapkg::aaa_fun()\n  } else {\n    g()\n  }\n}\n\nEstas funciones de rlang tienen características útiles para la programación, como vectorización sobre pkg, errores clasificados con una carga útil de datos y, para check_installed(), una oferta para instalar el paquete necesario en una sesión interactiva.\n\n11.5.2 En el código de prueba\nEl equipo de tidyverse generalmente escribe pruebas como si todos los paquetes sugeridos estuvieran disponibles. Es decir, los utilizamos incondicionalmente en las pruebas.\nLa motivación para esta postura es la autoconsistencia y el pragmatismo. El paquete clave necesario para ejecutar pruebas es testthat y aparece en Suggests, no en Imports o Depends. Por lo tanto, si las pruebas realmente se están ejecutando, eso implica que se ha aplicado una noción amplia de dependencias de paquetes.\nAdemás, empíricamente, en cada escenario importante de ejecución de R CMD check, se instalan los paquetes sugeridos. Esto es generalmente cierto para CRAN y nos aseguramos de que así sea en nuestras propias comprobaciones automatizadas. Sin embargo, es importante tener en cuenta que otros mantenedores de paquetes adoptan una postura diferente y optan por proteger todo uso de los paquetes sugeridos en sus pruebas y viñetas.\nA veces incluso hacemos una excepción y protegemos el uso de un paquete sugerido en una prueba. Aquí hay una prueba de ggplot2, que usa testthat::skip_if_not_installed() para omitir la ejecución si el paquete sf sugerido no está disponible.\n\ntest_that(\"basic plot builds without error\", {\n  skip_if_not_installed(\"sf\")\n\n  nc_tiny_coords &lt;- matrix(\n    c(-81.473, -81.741, -81.67, -81.345, -81.266, -81.24, -81.473,\n      36.234, 36.392, 36.59, 36.573, 36.437, 36.365, 36.234),\n    ncol = 2\n  )\n\n  nc &lt;- sf::st_as_sf(\n    data_frame(\n      NAME = \"ashe\",\n      geometry = sf::st_sfc(sf::st_polygon(list(nc_tiny_coords)), crs = 4326)\n    )\n  )\n\n  expect_doppelganger(\"sf-polygons\", ggplot(nc) + geom_sf() + coord_sf())\n})\n\n¿Qué podría justificar el uso de skip_if_not_installed()? En este caso, la instalación del paquete sf puede no ser fácil y es posible que un colaborador quiera ejecutar las pruebas restantes, incluso si sf no está disponible.\nFinalmente, tenga en cuenta que testthat::skip_if_not_installed(pkg, minimal_version = \"xyz\") se puede usar para omitir condicionalmente una prueba según la versión del otro paquete.\n\n11.5.3 En ejemplos y viñetas\nOtro lugar común para usar un paquete sugerido es en un ejemplo y aquí a menudo lo protegemos con require() o requireNamespace(). Este ejemplo es de ggplot2::coord_map(). ggplot2 enumera el paquete de mapas en Suggests.\n\n#' @examples\n#' if (require(\"maps\")) {\n#'   nz &lt;- map_data(\"nz\")\n#'   # Prepara un mapa de Nueva Zelanda\n#'   nzmap &lt;- ggplot(nz, aes(x = long, y = lat, group = group)) +\n#'     geom_polygon(fill = \"white\", colour = \"black\")\n#'  \n#'   # Grafica en cordenadas cartesianas\n#'   nzmap\n#' }\n\nUn ejemplo es básicamente el único lugar donde usaríamos require() dentro de un paquete. Lea más en Sección 10.4.\nNuestra postura con respecto al uso de paquetes sugeridos en viñetas es similar a la de las pruebas. Los paquetes clave necesarios para crear viñetas (rmarkdown y knitr) se enumeran en Suggests. Por lo tanto, si se están creando las viñetas, es razonable suponer que todos los paquetes sugeridos están disponibles. Normalmente utilizamos paquetes sugeridos incondicionalmente dentro de viñetas.\nPero si elige utilizar paquetes sugeridos de forma condicional en sus viñetas, la opción knitr chunk eval es muy útil para lograrlo. Consulte Sección 17.4 para obtener más información.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#sec-dependencies-in-depends",
    "href": "dependencies-in-practice.html#sec-dependencies-in-depends",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.6 El paquete aparece en Depends\n",
    "text": "11.6 El paquete aparece en Depends\n\nConsidere una dependencia que aparece en DESCRIPTION en Depends:\nDepends:\n    aaapkg\nEsta situación tiene mucho en común con un paquete listado en Imports. El código dentro de su paquete puede asumir que aaapkg está instalado en el sistema. La única diferencia es que aaapkg se adjuntará cada vez que se envíe su paquete.\n\n11.6.1 En el código debajo de R/ y en el código de prueba\nSus opciones son exactamente las mismas que usar funciones de un paquete enumerado en Imports:\n\nUtilice la sintaxis aaapkg::aaa_fun().\nImporte una función individual con la etiqueta roxygen @importFrom aaapkg aaa_fun y llame a aaa_fun() directamente.\nImporte todo el espacio de nombres aaapkg con la etiqueta roxygen @import aaapkg y llame a cualquier función directamente.\n\nLa principal diferencia entre esta situación y una dependencia enumerada en Imports es que es mucho más común importar el espacio de nombres completo de un paquete enumerado en Depends. Esto a menudo tiene sentido, debido a la relación de dependencia especial que motivó su inclusión en Depends en primer lugar.\n\n11.6.2 En ejemplos y viñetas\nEsta es la diferencia más obvia entre una dependencia en Depends versus Imports. Dado que su paquete se adjunta cuando se ejecutan sus ejemplos, también se adjunta el paquete que figura en Depends. No es necesario adjuntarlo explícitamente con library(aaapkg).\nEl paquete ggforce depende de ggplot2 y los ejemplos de ggforce::geom_mark_rect() usan funciones como ggplot2::ggplot() y ggplot2::geom_point() sin ninguna llamada explícita a library(ggplot2):\n\nggplot(iris, aes(Petal.Length, Petal.Width)) +\n  geom_mark_rect(aes(fill = Species, filter = Species != 'versicolor')) +\n  geom_point()\n# el código ejemplo continua ...\n\nLa primera línea de código ejecutada en una de sus viñetas es probablemente library(pkg), que adjunta su paquete y, como efecto secundario, adjunta cualquier dependencia enumerada en Depends. No es necesario adjuntar explícitamente la dependencia antes de usarla. El paquete censored depende del paquete de suvirval y el código en vignette(\"examples\", package = \"censored\") comienza así:\n\nlibrary(tidymodels)\nlibrary(censored)\n#&gt; Loading required package: survival\n\n# código de viñeta continua ...",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#sec-dependencies-nonstandard",
    "href": "dependencies-in-practice.html#sec-dependencies-nonstandard",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.7 El paquete es una dependencia no estándar",
    "text": "11.7 El paquete es una dependencia no estándar\nEn los paquetes desarrollados con devtools, es posible que vea archivos DESCRIPTION que utilizan un par de campos no estándar para dependencias de paquetes específicas para tareas de desarrollo.\n\n11.7.1 Dependiendo de la versión de desarrollo de un paquete\nEl campo Remotes se puede utilizar cuando necesita instalar una dependencia desde un lugar no estándar, es decir, desde algún lugar además de CRAN o Bioconductor. Un ejemplo común de esto es cuando estás desarrollando contra una versión de desarrollo de una de tus dependencias. Durante este tiempo, querrás instalar la dependencia desde su repositorio de desarrollo, que suele ser GitHub. La forma de especificar varias fuentes remotas se describe en una viñeta de devtools y en un tema de ayuda del paquete.\nLa dependencia y cualquier requisito de versión mínima aún deben declararse de la forma habitual en, por ejemplo, Imports. usethis::use_dev_package() ayuda a realizar los cambios necesarios en DESCRIPTION. Si su paquete depende temporalmente de una versión de desarrollo de aaapkg, los campos DESCRIPTION afectados podrían evolucionar de esta manera:\n\nEstable --&gt;              Desarrollo --&gt;               Estable de nuevo\n----------------------   ---------------------------   ----------------------\nPackage: pkg             Package: pkg                  Package: pkg\nVersion: 1.0.0           Version: 1.0.0.9000           Version: 1.1.0\nImports:                 Imports:                      Imports: \n    aaapkg (&gt;= 2.1.3)       aaapkg (&gt;= 2.1.3.9000)       aaapkg (&gt;= 2.2.0)\n                         Remotes:   \n                             jane/aaapkg \n\n\n\n\n\n\nCRAN\n\n\n\nEs importante tener en cuenta que no debe enviar su paquete a CRAN en el estado intermedio, es decir, con un campo Remotes y con una dependencia requerida en una versión que no está disponible en CRAN o Bioconductor. Para los paquetes CRAN, esto solo puede ser un estado de desarrollo temporal, que eventualmente se resuelve cuando la dependencia se actualiza en CRAN y usted puede aumentar su versión mínima en consecuencia.\n\n\n\n11.7.2 El campo Config/Needs/*\n\nTambién puede ver paquetes desarrollados por devtools con paquetes enumerados en los campos DESCRIPTION en el formato Config/Needs/*, que describimos en Sección 9.8.\n\nEl uso de Config/Needs/* no está directamente relacionado con devtools. Es más exacto decir que está asociado con flujos de trabajo de integración continua puestos a disposición de la comunidad en https://github.com/r-lib/actions/ y expuesto a través de funciones como usethis::use_github_action(). Un campo Config/Needs/* le indica a la acción de GitHub setup-r-dependencies acerca de paquetes adicionales que deben instalarse.\nConfig/Needs/website es el más común y proporciona un lugar para especificar paquetes que no son una dependencia formal, pero que deben estar presentes para construir el sitio web del paquete (Capítulo 19). El paquete readxl es un buen ejemplo. Tiene un artículo sin viñeta sobre flujos de trabajo que muestra a readxl trabajando en conjunto con otros paquetes de tidyverse, como readr y purrr. ¡Pero no tiene sentido que readxl tenga una dependencia formal de readr o purrr o (peor aún) tidyverse!\nA la izquierda está lo que readxl tiene en el campo Configuración/Necesidades/sitio web de DESCRIPCIÓN para indicar que se necesita tidyverse para construir el sitio web, que también está formateado con un estilo que se encuentra en tidyverse/template Repositorio de GitHub. A la derecha está el extracto correspondiente de la configuración del flujo de trabajo que crea e implementa el sitio web.\nen DESCRIPTION                  en .github/workflows/pkgdown.yaml\n--------------------------      ---------------------------------\nConfig/Needs/website:           - uses: r-lib/actions/setup-r-dependencies@v2\n    tidyverse,                    with:\n    tidyverse/tidytemplate          extra-packages: pkgdown\n                                    needs: website\nLos sitios web de paquetes y la integración continua se analizan con más detalle en Capítulo 19 y Sección 20.2, respectivamente.\nLa convención Config/Needs/* es útil porque permite a un desarrollador usar DESCRIPTION como su registro definitivo de dependencias de paquetes, manteniendo al mismo tiempo una distinción clara entre las verdaderas dependencias de tiempo de ejecución y aquellas que solo son necesarias para tareas de desarrollo especializadas.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#exportaciones",
    "href": "dependencies-in-practice.html#exportaciones",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.8 Exportaciones",
    "text": "11.8 Exportaciones\nPara que una función se pueda utilizar fuera de su paquete, debe exportarla. Cuando crea un nuevo paquete con usethis::create_package(), al principio no se exporta nada, ni siquiera una vez que agrega algunas funciones. Aún puedes experimentar interactivamente con load_all(), ya que carga todas las funciones, no solo las que se exportan. Pero si instala y adjunta el paquete con library(pkg) en una nueva sesión de R, notará que no hay funciones disponibles.\n\n11.8.1 Qué exportar\nExporta funciones que quieras que utilicen otras personas. Las funciones exportadas deben estar documentadas y debe tener cuidado al cambiar su interfaz: ¡otras personas las están usando! Generalmente es mejor exportar muy poco que demasiado. Es fácil empezar a exportar algo que antes no hacía; Es difícil dejar de exportar una función porque podría romper el código existente. Siempre opte por el lado de la precaución y la simplicidad. Es más fácil darle a las personas más funcionalidades que quitarles cosas a las que están acostumbradas.\nCreemos que los paquetes que tienen una amplia audiencia deben esforzarse por hacer una cosa y hacerlo bien. Todas las funciones de un paquete deben estar relacionadas con un único problema (o un conjunto de problemas estrechamente relacionados). Cualquier función que no esté relacionada con ese propósito no debe exportarse. Por ejemplo, la mayoría de nuestros paquetes tienen un archivo utils.R (Sección 6.1) que contiene pequeñas funciones de utilidad que son útiles internamente, pero que no forman parte del propósito principal de esos paquetes. No exportamos tales funciones. Hay al menos dos razones para esto:\n\nLibertad para ser menos robusto y menos general. Una utilidad para uso interno no tiene por qué implementarse de la misma manera que una función utilizada por otros. Sólo necesita cubrir su propio caso de uso.\nDependencias inversas lamentables. No desea que las personas dependan de su paquete para obtener funcionalidades y funciones que no están relacionadas con su propósito principal.\n\nDicho esto, si estás creando un paquete para ti mismo, es mucho menos importante ser tan disciplinado. Como sabe lo que hay en su paquete, está bien tener un paquete “misceláneo” local que contenga una mezcolanza de funciones que le resulten útiles. Pero probablemente no sea una buena idea lanzar un paquete de este tipo para un uso más amplio.\nA veces su paquete tiene una función que podría ser de interés para otros desarrolladores que amplíen su paquete, pero no para los usuarios típicos. En este caso, se desea exportar la función, pero también darle un perfil muy bajo en términos de documentación pública. Esto se puede lograr combinando las etiquetas roxygen @export y @keywords internal. La palabra clave internal evita que la función aparezca en el índice del paquete, pero el tema de ayuda asociado todavía existe y la función sigue apareciendo entre las exportadas en el archivo NAMESPACE.\n\n11.8.2 Reexportación\nA veces desea que algo esté disponible para los usuarios de su paquete y que en realidad lo proporciona una de sus dependencias. Cuando devtools se dividió en varios paquetes más pequeños (Sección 2.2), muchas de las funciones orientadas al usuario se trasladaron a otra parte. Para usar esto, la solución elegida fue incluirlo en Depends (Sección 10.4.1), pero esa no es una buena solución general. En cambio, devtools ahora reexporta ciertas funciones que en realidad se encuentran en un paquete diferente.\nAquí hay un modelo para reexportar un objeto de otro paquete, usando la función session_info() como nuestro ejemplo:\n\n\nEnumere el paquete que aloja el objeto reexportado en Imports en DESCRIPCIÓN.2 En este caso, la función session_info() se exporta mediante el paquete sessioninfo.\nImports:\n    sessioninfo\n\n\nEn uno de sus archivos R/*.R, tenga una referencia a la función de destino, precedida por etiquetas roxygen tanto para importar como para exportar.\n\n#' @export\n#' @importFrom sessioninfo session_info\nsessioninfo::session_info\n\n\n\n¡Eso es todo! La próxima vez que vuelva a generar NAMESPACE, estas dos líneas estarán allí (normalmente intercaladas con otras exportaciones e importaciones):\n...\nexport(session_info)\n...\nimportFrom(sessioninfo,session_info)\n...\nY esto explica cómo library(devtools) hace que session_info() esté disponible en la sesión actual. Esto también conducirá a la creación del archivo man/reexports.Rd, que perfecciona el requisito de que su paquete debe documentar todas sus funciones exportadas. Este tema de ayuda enumera todos los objetos reexportados y enlaces a su documentación principal.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#importaciones-y-exportaciones-relacionadas-con-s3",
    "href": "dependencies-in-practice.html#importaciones-y-exportaciones-relacionadas-con-s3",
    "title": "11  Dependencias: en la práctica",
    "section": "\n11.9 Importaciones y exportaciones relacionadas con S3",
    "text": "11.9 Importaciones y exportaciones relacionadas con S3\nR tiene múltiples sistemas de programación orientada a objetos (OOP):\n\nS3 es actualmente el más importante para nosotros y es lo que se aborda en este libro. El capítulo S3 de Advanced R es un buen lugar para aprender más sobre S3 conceptualmente y el paquete vctrs vale la pena estudiarlo para obtener conocimientos prácticos.\nS4 es muy importante dentro de ciertas comunidades R, sobre todo dentro del proyecto Bioconductor. Solo usamos S4 cuando es necesario por compatibilidad con otros paquetes. Si desea obtener más información, el capítulo S4 de Advanced R es un buen punto de partida y tiene recomendaciones de recursos adicionales.\nR6 se utiliza en muchos paquetes de tidyverse (definido en sentido amplio), pero está fuera del alcance de este libro. Algunos buenos lugares para obtener más información incluyen el sitio web del paquete R6, el capítulo R6 de Advanced R y la documentación de roxygen2 relacionada con R6.\n\nEn términos de problemas de espacio de nombres en torno a las clases de S3, lo principal a considerar son las funciones genéricas y sus implementaciones específicas de clase conocidas como métodos. Si su paquete “posee” una clase S3, tiene sentido exportar una función constructora fácil de usar. A menudo, esto es sólo una función normal y no existe un ángulo S3 especial.\nSi su paquete “posee” un genérico S3 y desea que otros puedan usarlo, debe exportar el genérico. Por ejemplo, el paquete dplyr exporta la función genérica dplyr::count() y también implementa y exporta un método específico, count.data.frame():\n\n#' ... toda la documentación habitual para count()...\n#' @export\ncount &lt;- function(x, ..., wt = NULL, sort = FALSE, name = NULL) {\n  UseMethod(\"count\")\n}\n\n#' @export\ncount.data.frame &lt;- function(\n  x,\n  ...,\n  wt = NULL,\n  sort = FALSE,\n  name = NULL,\n  .drop = group_by_drop_default(x)) { ... }\n\nLas líneas correspondientes en el archivo NAMESPACE de dplyr se ven así:\n...\nS3method(count,data.frame)\n...\nexport(count)\n...\nAhora imagina que tu paquete implementa un método para count() para una clase que “tu posees” (no data.frame). Un buen ejemplo es el paquete dbplyr, que implementa el genérico count() de dplyr para la clase tbl_lazy de dbplyr.\nEn este caso, @export no funcionará porque supone que el genérico count() está incluido o importado en el NAMESPACE de dbplyr, por lo que en su lugar necesitamos usar @exportS3Method, proporcionando el genérico preciso que estamos proporcionando. un método para.\n\n#' @exportS3Method dplyr::count\ncount.tbl_lazy &lt;- function(x, ..., wt = NULL, sort = FALSE, name = NULL) { ... }\n\nEn NAMESPACE, tenemos:\nS3method(dplyr::count,tbl_lazy)\nEsto también funciona para genéricos de paquetes que son dependencias sugeridas, por ejemplo donde el paquete glue implementa un método para testthat que es compare() genérico: glue enumera testthat que solo es una dependencia sugerida, por lo que (a partir de R 3.6.0) R registrará condicionalmente el método compare.glue() cuando ambos testthat y los paquetes de glue estarán cargados.\ndbplyr también proporciona métodos para varios genéricos proporcionados por el paquete base, como dim() y names(); en este caso, aún podemos usar @export ya que los genéricos están disponibles en el paquete NAMESPACE.\nEn dbplyr/R/tbl_lazy.R, tenemos:\n\n#' @export\ndim.tbl_lazy &lt;- function(x) {\n  c(NA, length(op_vars(x$lazy_query)))\n}\n\n#' @export\nnames.tbl_lazy &lt;- function(x) {\n  colnames(x)\n}\n\nEn NAMESPACE, esto produce:\nS3method(dim,tbl_lazy)\n...\nS3method(names,tbl_lazy)",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "dependencies-in-practice.html#footnotes",
    "href": "dependencies-in-practice.html#footnotes",
    "title": "11  Dependencias: en la práctica",
    "section": "",
    "text": "Por ejemplo, si su paquete necesita llamar a ggplot2::geom_hex(), puede optar por incluir hexbin en Imports, ya que ggplot2 solo lo incluye en Suggests.↩︎\nRecuerde que usethis::use_package() es útil para agregar dependencias a DESCRIPTION.↩︎",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Dependencias: en la práctica</span>"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "12  Licencias",
    "section": "",
    "text": "12.1 Panorama general\nEl objetivo de este capítulo es brindarle las herramientas básicas para administrar las licencias de su paquete R. Obviamente, somos desarrolladores de R y no abogados, y nada de esto es asesoramiento legal. Pero, afortunadamente, si estás escribiendo un paquete de código abierto o un paquete utilizado sólo dentro de tu organización1, no necesitas ser un experto para hacer lo correcto. Debe elegir una licencia que declare cómo desea que se use su código y, si incluye código escrito por otra persona, debe respetar la licencia que utiliza.\nEste capítulo comienza con una descripción general de las licencias y cómo obtener licencias para su propio código. Luego discutiremos los detalles más importantes sobre la aceptación del código que se le proporciona (por ejemplo, en una solicitud de extracción) y cómo agrupar el código escrito por otras personas. Terminaremos con una breve discusión de las implicaciones de usar código de otros paquetes.\nPara comprender los deseos del autor, es útil comprender los dos campos principales de las licencias de código abierto:\nCuando analizamos todos los lenguajes de programación, las licencias permisivas son las más comunes. Por ejemplo, una encuesta de 2015 sobre repositorios de GitHub encontró que ~55% usaba un permiso licencia y ~20% utilizó una licencia copyleft. La comunidad R es bastante diferente: a partir de 2022, mi análisis2 encontró que ~70% de los paquetes CRAN usan una licencia copyleft y ~20% usa una licencia permisiva. Esto significa que obtener la licencia de su paquete R requiere un poco más de cuidado que para otros lenguajes.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#panorama-general",
    "href": "license.html#panorama-general",
    "title": "12  Licencias",
    "section": "",
    "text": "Las licencias permisivas son muy sencillas. El código con una licencia permisiva se puede copiar, modificar y publicar libremente, y la única restricción es que se debe conservar la licencia. Las licencias MIT y Apache son las más licencias permisivas modernas comunes; Las licencias permisivas más antiguas incluyen las diversas formas de la licencia BSD.\nLas licencias Copyleft son más estrictas. La licencia copyleft más común es la GPL que le permite copiar y modificar libremente el código para uso personal, pero si publica versiones modificadas o paquete con otro código, la versión modificada o paquete completo también debe tener licencia GPL.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#código-que-escribes",
    "href": "license.html#código-que-escribes",
    "title": "12  Licencias",
    "section": "\n12.2 Código que escribes",
    "text": "12.2 Código que escribes\nComenzaremos hablando sobre el código que usted escribe y cómo otorgarle licencia para dejar en claro cómo quiere que la gente lo trate. Es importante utilizar una licencia porque, si no lo hace, se aplican las leyes de derechos de autor predeterminadas, lo que significa que nadie puede hacer una copia de su código sin su permiso expreso.\nEn breve:\n\nSi desea una licencia permisiva para que las personas puedan usar su código con restricciones mínimas, elija la licencia MIT con use_mit_license().\nSi desea una licencia copyleft para que todos los derivados y paquetes de su código también sean de código abierto, elija la licencia GPLv3 con use_gpl_license().\nSi su paquete contiene principalmente datos, no código, y desea restricciones mínimas, elija la licencia CC0 con use_cc0_license(). O si desea solicitar atribución cuando se utilizan sus datos, elija la licencia CC BY llamando a use_ccby_license().\nSi no desea que su código sea de código abierto, llame a use_proprietary_license(). CRAN no puede distribuir dichos paquetes.\n\nVolveremos con más detalles y presentaremos algunas otras licencias en Sección 12.2.2.\n\n12.2.1 Archivos clave\nHay tres archivos clave que se utilizan para registrar su decisión de concesión de licencia:\n\n\nCada licencia establece el campo License en DESCRIPTION. Contiene el nombre de la licencia en un formato estándar para que R CMD check y CRAN puedan verificarla automáticamente. Viene en cuatro formas principales:\n\nUna especificación de nombre y versión, por ejemplo GPL (&gt;= 2), o Apache License (== 2.0).\nUna abreviatura estándar, por ejemplo GPL-2, LGPL-2.1, Artístico-2.0.\nUn nombre de una “plantilla” de licencia y un archivo que contiene variables específicas. El caso más común es MIT + archivo LICENSE, donde el archivo LICENSE debe contener dos campos: el año y el titular de los derechos de autor.\nDirección al texto completo de una licencia no estándar, archivo LICENSE.\n\nSon posibles estructuras de concesión de licencias más complicadas, pero están fuera del alcance de este texto. Consulte la sección Licencias de “Escribir extensiones de R” para obtener más detalles.\n\nComo se describió anteriormente, el archivo LICENSE se utiliza de dos maneras. Algunas licencias son plantillas que requieren que se completen detalles adicionales en el archivo LICENSE. El archivo LICENSE también puede contener el texto completo de licencias no estándar y de código no abierto. No se le permite incluir el texto completo de las licencias estándar.\nLICENSE.md incluye una copia del texto completo de la licencia. Todas las licencias de código abierto requieren que se incluya una copia de la licencia, pero CRAN no le permite incluir una copia de las licencias estándar en su paquete, por lo que también usamos .Rbuildignore para asegurarnos de que este archivo no se envíe a CRAN.\n\nHay otro archivo al que volveremos en Sección 12.4.2: LICENSE.note. Esto se utiliza cuando ha incluido código escrito por otras personas y partes de su paquete tienen licencias más permisivas que el conjunto.\n\n12.2.2 Más licencias para el código\nLe dimos el mínimo absoluto que necesita saber arriba. Pero vale la pena mencionar algunas licencias más importantes ordenadas aproximadamente de más permisivas a menos permisivas:\n\nuse_apache_license(): la Licencia Apache es similar a la licencia MIT pero también incluye una concesión de patente explícita. Las patentes son otro componente de la propiedad intelectual distinto de los derechos de autor, y algunas organizaciones también se preocupan por la protección frente a las reclamaciones de patentes.\nuse_lgpl_license(): la LGPL es un poco más débil que la GPL, lo que le permite agrupar código LPGL usando cualquier licencia para el trabajo más grande.\nuse_gpl_license(): Ya hemos discutido la GPL, pero hay un detalle importante a tener en cuenta: la GPL tiene dos versiones principales, GPLv2 y GPLv3, y no son compatibles (es decir, no se pueden agrupar códigos GPLv2 y GPLv3 en el mismo proyecto). Para evitar este problema, generalmente se recomienda licenciar su paquete como GPL &gt;=2 o GPL &gt;= 3 para que las versiones futuras de la licencia GPL también se apliquen a su código. Esto es lo que hace use_gpl_license() de forma predeterminada.\nuse_agpl_license(): La AGPL define la distribución para incluir la prestación de un servicio a través de una red, de modo que si utiliza el código AGPL para proporcionar un servicio web , todo el código incluido también debe ser de código abierto. Debido a que se trata de una exigencia considerablemente más amplia que la GPL, muchas empresas prohíben expresamente el uso del software AGPL.\n\nHay muchas otras licencias disponibles. Para obtener una vista de alto nivel del espacio de licencias de código abierto y los detalles de las licencias individuales, recomendamos encarecidamente, que hemos utilizado en los enlaces anteriores. Para obtener más detalles sobre la concesión de licencias de paquetes R, recomendamos Licensing R de Colin Fay. La principal desventaja de elegir una licencia que no está en la lista anterior es que menos usuarios de R entenderán lo que significa y les resultará más difícil usar su código.\n\n12.2.3 Licencias para datos\nTodas estas licencias están diseñadas específicamente para aplicarse al código fuente, por lo que si publica un paquete que contiene principalmente datos, debe utilizar un tipo diferente de licencia. Recomendamos una de las dos licencias Creative Commons:\n\nSi desea que los datos estén disponibles lo más libremente posible, utilice la licencia CC0 con use_cc0_license(). Esta es una licencia permisiva equivalente a la licencia MIT, pero se aplica a los datos, no al código.3\nSi desea solicitar atribución cuando otra persona utiliza sus datos, puede utilizar la licencia CC-BY, con use_ccby_license().\n\n12.2.4 Cambiar Licencia\nCambiar su licencia después del hecho es difícil porque requiere el permiso de todos los titulares de derechos de autor y, a menos que haya tomado medidas especiales (más sobre eso a continuación), esto incluirá a todos los que hayan contribuido con una cantidad no trivial de código.\nSi necesita volver a obtener la licencia de un paquete, le recomendamos los siguientes pasos:\n\nVerifique el campo Authors@R en DESCRIPTION para confirmar que el paquete no contiene código empaquetado (del cual hablaremos en Sección 12.4).\nEncuentre a todos los contribuyentes consultando el historial de Git o la visualización de los contribuyentes en GitHub.\nOpcionalmente, inspeccione las contribuciones específicas y elimine a las personas que solo contribuyeron con correcciones de errores tipográficos y similares4.\nPregunte a todos los contribuyentes si están de acuerdo con cambiar la licencia. Si todos los contribuyentes están en GitHub, la forma más sencilla de hacerlo es crear un problema en el que enumere a todos los contribuyentes y les pida que confirmen que están de acuerdo con el cambio.\nUna vez que todos los titulares de derechos de autor lo hayan aprobado, realice el cambio llamando a la función de licencia correspondiente.\n\nPuede leer sobre cómo tidyverse siguió este proceso para unificarse en la licencia MIT en https://www.tidyverse.org/blog/2021/12/relicensing-packages/.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#sec-code-given-to-you",
    "href": "license.html#sec-code-given-to-you",
    "title": "12  Licencias",
    "section": "\n12.3 Código proporcionado a usted",
    "text": "12.3 Código proporcionado a usted\nMuchos paquetes incluyen código no escrito por el autor. Hay dos formas principales en que esto sucede: otras personas pueden optar por contribuir a su paquete mediante una solicitud de extracción o algo similar, o usted puede encontrar algún código y optar por agruparlo. Esta sección analizará el código que otros le brindan y la siguiente sección analizará el código que usted incluye.\nCuando alguien aporta código a su paquete mediante una solicitud de extracción o similar, puede asumir que el autor está contento con que su código use su licencia. Esto está explícito en los términos de servicio de GitHub, pero generalmente se considera verdadero independientemente de cómo se contribuya el código 5.\nSin embargo, el autor conserva los derechos de autor de su código, lo que significa que no puedes cambiar la licencia sin su permiso (más sobre esto en breve). Si desea conservar la capacidad de cambiar la licencia, necesita un “acuerdo de licencia de colaborador” explícito o CLA, donde el autor reasigna explícitamente los derechos de autor. Esto es más importante para proyectos duales de código abierto/comerciales porque permite fácilmente licencias duales en las que el código se pone a disposición del mundo con una licencia copyleft y para los clientes que pagan con una licencia diferente y más permisiva.\nTambién es importante reconocer la contribución y es una buena práctica ser generoso con el agradecimiento y la atribución. En tidyverse, solicitamos que todos los contribuyentes de código incluyan una viñeta en NEWS.md con su nombre de usuario de GitHub, y agradecemos a todos los contribuyentes en los anuncios de lanzamiento. Solo agregamos desarrolladores principales6 al archivo DESCRIPTION; pero algunos proyectos optan por agregar a todos los contribuyentes, sin importar cuán pequeños sean.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#sec-code-you-bundle",
    "href": "license.html#sec-code-you-bundle",
    "title": "12  Licencias",
    "section": "\n12.4 Código que empaquetas",
    "text": "12.4 Código que empaquetas\nHay tres razones comunes por las que podrías optar por incluir código escrito por otra persona:\n\nEstás incluyendo la biblioteca CSS o JS de otra persona para crear una página web o widgets HTML útiles y atractivos. Shiny es un gran ejemplo de un paquete que hace esto ampliamente.\nEstás proporcionando un contenedor R para una biblioteca C o C++ simple. (Para bibliotecas complejas de C/C++, normalmente no incluye el código en su paquete, sino que lo vincula a una copia instalada en otra parte del sistema).\nHas copiado una pequeña cantidad de código R de otro paquete para evitar crear una dependencia. Generalmente, depender de otro paquete es lo correcto porque no necesita preocuparse por la licencia y automáticamente obtendrá correcciones de errores. Pero a veces sólo necesitas una cantidad muy pequeña de código de un paquete grande, y copiarlo y pegarlo en tu paquete es lo correcto.\n\n\n12.4.1 License compatibility\nCompatibilidad de licencia\nAntes de incluir el código de otra persona en su paquete, primero debe verificar que la licencia incluida sea compatible con su licencia. Al distribuir código, puede agregar restricciones adicionales, pero no puede eliminar restricciones, lo que significa que la compatibilidad de licencias no es simétrica. Por ejemplo, puede agrupar código con licencia MIT en un paquete con licencia GPL, pero no puede agrupar código con licencia GPL en un paquete con licencia MIT.\nHay cinco casos principales a considerar:\n\nSi su licencia y la de ellos son iguales: está bien agruparlas.\nSi su licencia es MIT o BSD, está bien agruparla.\nSi su código tiene una licencia copyleft y su código tiene una licencia permisiva, no puede agrupar su código. Deberá considerar un enfoque alternativo, ya sea buscar código con una licencia más permisiva o colocar el código externo en un paquete separado.\nSi el código proviene de Stack Overflow, está licenciado7 con la licencia Creative Common CC BY-SA, que solo es compatible con GPLv38 . Esto significa que debe tener especial cuidado al utilizar el código Stack Overflow en paquetes de código abierto . . Obtenga más información en https://empirical-software.engineering/blog/so-snippets-in-gh-projects.\nDe lo contrario, tendrás que investigar un poco. Wikipedia tiene un [diagrama útil] (https://en.wikipedia.org/wiki/License_compatibility#Compatibility_of_FOSS_licenses) y Google es tu amigo. Es importante tener en cuenta que las diferentes versiones de la misma licencia no son necesariamente compatibles, por ejemplo GPLv2 y GPLv3 no son compatibles.\n\nSi su paquete no es de código abierto, las cosas son más complicadas. Las licencias permisivas siguen siendo fáciles y las licencias copyleft generalmente no restringen su uso siempre y cuando no distribuya el paquete fuera de su empresa. Pero este es un tema complejo y las opiniones difieren, y usted debe consultar primero con su departamento legal.\n\n12.4.2 Cómo incluir\nUna vez que haya determinado que las licencias son compatibles, puede traer el código en su paquete. Al hacerlo, debe preservar todas las declaraciones de licencia y derechos de autor existentes y facilitar al máximo que los futuros lectores comprendan la situación de la licencia:\n\nSi incluye un fragmento de otro proyecto, generalmente es mejor colocar su propio archivo y asegurarse de que el archivo tenga declaraciones de derechos de autor y una descripción de la licencia en la parte superior.\nSi incluye varios archivos, colóquelos en un directorio y coloque un archivo de licencia en ese directorio.\n\nTambién debe incluir algunos metadatos estándar en Authors@R. Debe utilizar role = \"cph\" para declarar que el autor es el titular de los derechos de autor, con un comentario, comment, que describa de qué es autor.\nSi realiza el envío a CRAN y el código incluido tiene una licencia diferente (pero compatible), también debe incluir un archivo LICENSE.note que describa la licencia general del paquete y las licencias específicas de cada componente individual. Por ejemplo, el paquete diffviewer incluye seis bibliotecas de Javascript, todas las cuales utilizan una licencia permisiva. DESCRIPTION enumera todos los titulares de derechos de autor y la LICENSE.nota describe sus licencias. (Otros paquetes utilizan otras técnicas, pero creemos que este es el enfoque más simple que funcionará con CRAN).",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#código-que-utilizas",
    "href": "license.html#código-que-utilizas",
    "title": "12  Licencias",
    "section": "\n12.5 Código que utilizas",
    "text": "12.5 Código que utilizas\n\nObviamente, todo el código R que escribe utiliza R, y R tiene licencia GPL. ¿Eso significa que su código R siempre debe tener licencia GPL? No, y la Fundación R lo dejó claro en 2009. De manera similar, es nuestra opinión personal que la licencia de su paquete no necesita ser compatible con las licencias de los paquetes R que usted simplemente usa llamando a sus funciones R exportadas (es decir, a través de Suggests o Imports).\nLas cosas son diferentes en otros lenguajes, como C, porque la creación de un ejecutable en C casi invariablemente termina copiando algún componente del código que usa en el ejecutable. Esto también puede surgir si su paquete R tiene código compilado y lo vincula (usando LinkingTo en su DESCRIPTION): necesitará investigar más para asegurarse de que su licencia sea compatible. Sin embargo, si solo está vinculando a R, generalmente puede obtener la licencia que desee porque los encabezados de R tienen licencia Lesser GPL.\nPor supuesto, cualquier usuario de su paquete tendrá que descargar todos los paquetes de los que depende su paquete (así como el propio R), por lo que aún tendrá que cumplir con los términos de esas licencias.",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "license.html#footnotes",
    "href": "license.html#footnotes",
    "title": "12  Licencias",
    "section": "",
    "text": "Inspirado en el de Sean Kross.↩︎\nInspirado en el de Sean Kross.↩︎\nSi le preocupan las implicaciones de la licencia CC0 con respecto a las citas, es posible que le interese la publicación del blog de Dryad ¿Por qué Dryad usa CC0?.↩︎\nLas contribuciones muy simples, como las correcciones de errores tipográficos, generalmente no están protegidas por derechos de autor porque no son trabajos creativos. Pero incluso una sola frase puede considerarse un trabajo creativo, así que opte por la seguridad y, si tiene alguna duda, deje al colaborador.↩︎\nAlgunas organizaciones particularmente reacias al riesgo exigen que los contribuyentes proporcionen un certificado de origen de desarrollador, pero esto es relativamente raro en general y no lo hemos visto en el Comunidad R.↩︎\nhttps://stackoverflow.com/help/licensing↩︎\nhttps://stackoverflow.com/help/licensing↩︎\nhttps://creativecommons.org/share-your-work/licensing-considerations/compatible-licenses/↩︎",
    "crumbs": [
      "Metadatos del paquete",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Licencias</span>"
    ]
  },
  {
    "objectID": "testing-basics.html",
    "href": "testing-basics.html",
    "title": "13  Conceptos básicos de pruebas",
    "section": "",
    "text": "13.1 ¿Por qué vale la pena realizar pruebas formales?\nLas pruebas son una parte vital del desarrollo de paquetes: garantizan que su código haga lo que desea. Sin embargo, las pruebas añaden un paso adicional a su flujo de trabajo. Para hacer esta tarea más fácil y efectiva, este capítulo le mostrará cómo realizar pruebas automatizadas formales utilizando el paquete testthat.\nLa primera etapa de su viaje a las pruebas es convencerse de que las pruebas tienen suficientes beneficios para justificar el trabajo. Para algunos de nosotros, esto es fácil de aceptar. Otros deben aprender por las malas.\nUna vez que haya decidido adoptar las pruebas automatizadas, es hora de aprender algunas mecánicas y descubrir dónde encajan las pruebas en su flujo de trabajo de desarrollo.\nA medida que usted y sus paquetes R evolucionen, comenzará a encontrar situaciones de prueba en las que es fructífero utilizar técnicas que son algo específicas de las pruebas y que difieren de lo que hacemos a continuación en R/.\nHasta ahora, su flujo de trabajo probablemente se vea así:\nMientras estás probando tu código en este flujo de trabajo, solo lo haces de manera informal. El problema con este enfoque es que cuando vuelvas a este código dentro de 3 meses para agregar una nueva característica, probablemente hayas olvidado algunas de las pruebas informales que ejecutaste la primera vez. Esto hace que sea muy fácil descifrar el código que solía funcionar.\nMuchos de nosotros adoptamos las pruebas automatizadas cuando nos damos cuenta de que estamos corrigiendo un error por segunda o quinta vez. Mientras escribimos código o corregimos errores, podemos realizar algunas pruebas interactivas para asegurarnos de que el código en el que estamos trabajando haga lo que queremos. Pero es fácil olvidar todos los diferentes casos de uso que necesita verificar si no tiene un sistema para almacenar y volver a ejecutar las pruebas. Esta es una práctica común entre los programadores de R. El problema no es que no pruebes tu código, es que no automatizas tus pruebas.\nEn este capítulo aprenderá cómo realizar la transición de pruebas informales ad hoc, realizadas de forma interactiva en la consola, a pruebas automatizadas (también conocidas como pruebas unitarias). Si bien convertir pruebas interactivas informales en pruebas formales requiere un poco más de trabajo inicial, vale la pena de cuatro maneras:",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#por-qué-vale-la-pena-realizar-pruebas-formales",
    "href": "testing-basics.html#por-qué-vale-la-pena-realizar-pruebas-formales",
    "title": "13  Conceptos básicos de pruebas",
    "section": "",
    "text": "Escribe una función.\nCárguelo con devtools::load_all(), tal vez mediante Ctrl/Cmd + Shift + L.\nExperimente con ello en la consola para ver si funciona.\nEnjuague y repita.\n\n\n\n\n\n\nMenos errores. Debido a que es explícito acerca de cómo debe comportarse su código, tendrá menos errores. La razón es un poco parecida a la razón por la que funciona la contabilidad por partida doble: debido a que usted describe el comportamiento de su código en dos lugares, tanto en su código como en sus pruebas, puede comparar uno con el otro.\nCon las pruebas informales, resulta tentador simplemente explorar el uso típico y auténtico, similar a escribir ejemplos. Sin embargo, al escribir pruebas formales, es natural adoptar una mentalidad más conflictiva y anticipar cómo entradas inesperadas podrían romper su código.\nSi siempre introduce nuevas pruebas cuando agrega una nueva característica o función, evitará que se creen muchos errores en primer lugar, porque abordará proactivamente los molestos casos extremos. Las pruebas también evitan que (re) rompas una característica cuando estás modificando otra.\n\nMejor estructura de código. El código bien diseñado tiende a ser fácil de probar y usted puede aprovecharlo. Si tiene dificultades para escribir pruebas, considere si el problema es en realidad el diseño de su(s) función(es). El proceso de redacción de pruebas es una excelente manera de obtener comentarios gratuitos, privados y personalizados sobre qué tan bien factorizado está su código. Si integra las pruebas en su flujo de trabajo de desarrollo (en lugar de planificar realizar las pruebas “más tarde”), se verá sometido a una presión constante para dividir operaciones complicadas en funciones separadas que funcionan de forma aislada. Las funciones que son más fáciles de probar suelen ser más fáciles de entender y recombinar de nuevas formas.\nLlamada a la acción. Cuando comenzamos a corregir un error, primero nos gusta convertirlo en una prueba (fallida). Esto es maravillosamente eficaz para hacer que su objetivo sea muy concreto: hacer que esta prueba pase. Este es básicamente un caso especial de una metodología general conocida como desarrollo impulsado por pruebas.\nCódigo robusto. Si sabe que todas las funciones principales de su paquete están bien cubiertas por las pruebas, puede realizar grandes cambios con confianza sin preocuparse de romper algo accidentalmente. Esto proporciona una excelente verificación de la realidad cuando cree que ha descubierto una nueva y brillante forma de simplificar su paquete. A veces, estas “simplificaciones” no tienen en cuenta algún caso de uso importante y sus pruebas lo salvarán de usted mismo.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#presentamos-testthat",
    "href": "testing-basics.html#presentamos-testthat",
    "title": "13  Conceptos básicos de pruebas",
    "section": "\n13.2 Presentamos testthat",
    "text": "13.2 Presentamos testthat\nEste capítulo describe cómo probar su paquete R usando el paquete testthat: https://testthat.r-lib.org\nSi está familiarizado con los marcos para pruebas unitarias en otros lenguajes, debe tener en cuenta que existen algunas diferencias fundamentales con testthat. Esto se debe a que R es, en esencia, más un lenguaje de programación funcional que un lenguaje de programación orientado a objetos. Por ejemplo, debido a que los principales sistemas orientados a objetos de R (S3 y S4) se basan en funciones genéricas (es decir, un método implementa una función genérica para una clase específica), los enfoques de prueba creados alrededor de objetos y métodos no tienen mucho sentido.\ntestthat 3.0.0 (lanzado el 31 de octubre de 2020) introdujo la idea de una edición de testthat, específicamente la tercera edición de testthat, a la que nos referimos como testthat 3e. Una edición es un conjunto de comportamientos que usted debe elegir explícitamente utilizar, lo que nos permite realizar cambios que de otro modo serían incompatibles con versiones anteriores. Esto es particularmente importante para testthat, ya que tiene una gran cantidad de paquetes que lo utilizan (casi 5000 según el último recuento). Para utilizar testthat 3e, debe tener una versión de testthat &gt;= 3.0.0 y aceptar explícitamente los comportamientos de la tercera edición. Esto permite que testthat continúe evolucionando y mejorando sin romper los paquetes históricos que se encuentran en una fase de mantenimiento bastante pasiva. Puede obtener más información en el artículo testthat 3e y la publicación del blog Actualización a testthat edición 3.\nRecomendamos testthat 3e para todos los paquetes nuevos y recomendamos actualizar los paquetes existentes que se mantienen activamente para usar testthat 3e. A menos que digamos lo contrario, este capítulo describe la prueba que 3e.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#sec-tests-mechanics-workflow",
    "href": "testing-basics.html#sec-tests-mechanics-workflow",
    "title": "13  Conceptos básicos de pruebas",
    "section": "\n13.3 Mecánica de prueba y flujo de trabajo",
    "text": "13.3 Mecánica de prueba y flujo de trabajo\n\n13.3.1 Configuración inicial\nPara configurar su paquete para usar testthat, ejecute:\n\nusethis::use_testthat(3)\n\nEsto va a:\n\nCrear un directorio tests/testthat/.\n\nAgregar testthat al campo Suggests en DESCRIPTION y especificar testthat 3e en el campo Config/testthat/edition. Los campos DESCRIPTION afectados podrían verse así:\nSuggests: testthat (&gt;= 3.0.0)\nConfig/testthat/edition: 3\n\n\nCrear un archivo tests/testthat.R que ejecuta todas sus pruebas cuando se ejecute R CMD check (Sección 4.5). Para un paquete llamado “pkg”, el contenido de este archivo será algo como:\n\nlibrary(testthat)\nlibrary(pkg)\n\ntest_check(\"pkg\")\n\n\n\nEsta configuración inicial suele ser algo que se hace una vez por paquete. Sin embargo, incluso en un paquete que ya usa testthat, es seguro ejecutar use_testthat(3), cuando esté listo para optar por testthat 3e.\n¡No edite tests/testthat.R! Se ejecuta durante R CMD check (y, por lo tanto, devtools::check()), pero no se usa en la mayoría de los otros escenarios de ejecución de pruebas (como devtools::test() o devtools: :test_active_file()). Si desea hacer algo que afecte todas sus pruebas, casi siempre hay una mejor manera que modificar el script estándar tests/testthat.R. Este capítulo detalla muchas formas diferentes de hacer que los objetos y la lógica estén disponibles durante las pruebas.\n\n13.3.2 Crear una prueba\nA medida que define funciones en su paquete, en los archivos debajo de R/, agrega las pruebas correspondientes a los archivos .R en tests/testthat/. Recomendamos encarecidamente que la organización de los archivos de prueba coincida con la organización de los archivos R/, discutidos en Sección 6.1: La función foofy() (y sus amigos y ayudantes) debe definirse en R/foofy.R y sus pruebas deben vivir en tests/testthat/test-foofy.R.\nR                                     tests/testthat\n└── foofy.R                           └── test-foofy.R\n    foofy &lt;- function(...) {...}          test_that(\"foofy does this\", {...})\n                                          test_that(\"foofy does that\", {...})\nIncluso si tiene diferentes convenciones para la organización y el nombre de archivos, tenga en cuenta que las pruebas testthat deben residir en archivos debajo de tests/testthat/ y estos nombres de archivos deben comenzar con test. El nombre del archivo de prueba se muestra en la salida de testthat, lo que proporciona un contexto útil1.\n\nusethis ofrece un par de funciones útiles para crear o alternar entre archivos:\n\nusethis::use_r()\nusethis::use_test()\n\nCualquiera de los dos puede ser llamado con un nombre de archivo (base), para crear un archivo de novo y abrirlo para editarlo:\n\nuse_r(\"foofy\")    # creates and opens R/foofy.R\nuse_test(\"blarg\") # creates and opens tests/testthat/test-blarg.R\n\nEl dúo use_r() / use_test() tiene algunas características convenientes que los hacen “simplemente funcionar” en muchas situaciones comunes:\n\nAl determinar el archivo de destino, pueden tener en cuenta la presencia o ausencia de la extensión .R y el prefijo test-.\n\nEquivalente: use_r(\"foofy.R\"), use_r(\"foofy\")\n\nEquivalente: use_test(\"test-blarg.R\"), use_test(\"blarg.R\"), use_test(\"blarg\")\n\n\n\nSi el archivo de destino ya existe, se abre para editarlo. De lo contrario, el objetivo se crea y luego se abre para editarlo.\n\n\n\n\n\n\n\nRStudio\n\n\n\nSi R/foofy.R es el archivo activo en su editor de código fuente, ¡incluso puede llamar a use_test() sin argumentos! El archivo de prueba de destino se puede inferir: si está editando R/foofy.R, probablemente desee trabajar en el archivo de prueba complementario, tests/testthat/test-foofy.R. Si aún no existe, se crea y, de cualquier manera, el archivo de prueba se abre para editarlo. Todo esto también funciona al revés. Si está editando tests/testthat/test-foofy.R, una llamada a use_r() (opcionalmente, crea y) abre R/foofy.R.\n\n\nEn pocas palabras: use_r() / use_test() son útiles para crear inicialmente estos pares de archivos y, más tarde, para desviar su atención de uno a otro.\nCuando use_test() crea un nuevo archivo de prueba, inserta una prueba de ejemplo:\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n\nReemplazarás esto con tu propia descripción y lógica, pero es un buen recordatorio de la forma básica:\n\nUn archivo de prueba contiene una o más pruebas test_that().\nCada prueba describe lo que está probando: por ejemplo, “la multiplicación funciona”.\nCada prueba tiene una o más expectativas: por ejemplo, expect_equal(2 * 2, 4).\n\nA continuación, entramos en muchos más detalles sobre cómo probar sus propias funciones.\n\n13.3.3 Ejecutar pruebas\nDependiendo de dónde se encuentre en el ciclo de desarrollo, ejecutará sus pruebas en varias escalas. Cuando itera rápidamente una función, puede trabajar a nivel de pruebas individuales. A medida que el código se asiente, ejecutará archivos de prueba completos y, finalmente, todo el conjunto de pruebas.\nMicroiteración: esta es la fase interactiva en la que inicia y perfecciona una función y sus pruebas en conjunto. Aquí ejecutará devtools::load_all() con frecuencia y luego ejecutará expectativas individuales o pruebas completas de forma interactiva en la consola. Tenga en cuenta que load_all() adjunta testthat, por lo que lo coloca en la posición perfecta para probar sus funciones y ejecutar pruebas y expectativas individuales.\n\n# modifica la función foofy() y vuelve a cargarla\ndevtools::load_all()\n\n# explorar y perfeccionar interactivamente expectativas y pruebas\nexpect_equal(foofy(...), EXPECTED_FOOFY_OUTPUT)\n\ntest_that(\"foofy does good things\", {...})\n\nMezzo-iteración: A medida que las funciones de un archivo y sus pruebas asociadas comienzan a tomar forma, querrás ejecutar el archivo completo de pruebas asociadas, tal vez con testthat::test_file():\n\n\ntestthat::test_file(\"tests/testthat/test-foofy.R\")\n\n\n\n\n\n\n\nRStudio\n\n\n\nEn RStudio, tiene un par de atajos para ejecutar un único archivo de prueba.\nSi el archivo de prueba de destino es el archivo activo, puede usar el botón “Ejecutar pruebas” en la esquina superior derecha del editor de origen.\nTambién hay una función útil, devtools::test_active_file(). Infiere el archivo de prueba de destino a partir del archivo activo y, de manera similar a cómo funcionan use_r() y use_test(), funciona independientemente de si el archivo activo es un archivo de prueba o un R/*.R complementario. archivo. Puede invocar esto a través de “Ejecutar un archivo de prueba” en el menú Complementos. Sin embargo, para usuarios habituales (¡como nosotros!), recomendamos vincular esto a un método abreviado de teclado; Usamos Ctrl/Cmd + T.\n\n\nMacroiteración: a medida que se acerque a la finalización de una nueva función o corrección de errores, querrá ejecutar todo el conjunto de pruebas.\nLo más frecuente es que hagas esto con devtools::test():\n\ndevtools::test()\n\nLuego, eventualmente, como parte de R CMD check con devtools::check():\n\ndevtools::check()\n\n\n\n\n\n\n\nRStudio\n\n\n\ndevtools::test() está asignado a Ctrl/Cmd + Shift + T. devtools::check() está asignado a Ctrl/Cmd + Shift + E.\n\n\n\nLa salida de devtools::test() se ve así:\ndevtools::test()\nℹ Loading usethis\nℹ Testing usethis\n✓ | F W S  OK | Context\n✓ |         1 | addin [0.1s]\n✓ |         6 | badge [0.5s]\n   ...\n✓ |        27 | github-actions [4.9s]\n   ...\n✓ |        44 | write [0.6s]\n\n══ Results ═════════════════════════════════════════════════════════════════\nDuration: 31.3 s\n\n── Skipped tests  ──────────────────────────────────────────────────────────\n• Not on GitHub Actions, Travis, or Appveyor (3)\n\n[ FAIL 1 | WARN 0 | SKIP 3 | PASS 728 ]\nEl error de la prueba se informa así:\nFailure (test-release.R:108:3): get_release_data() works if no file found\nres$Version (`actual`) not equal to \"0.0.0.9000\" (`expected`).\n\n`actual`:   \"0.0.0.1234\"\n`expected`: \"0.0.0.9000\"\nCada error proporciona una descripción de la prueba (p. ej., “get_release_data() funciona si no se encuentra ningún archivo”), su ubicación (p. ej., “test-release.R:108:3”) y el motivo del error (p. ej., “res$Versión (actual) no es igual a”0.0.0.9000” (esperado)“).\nLa idea es que modifiques tu código (ya sea las funciones definidas debajo de R/ o las pruebas en tests/testthat/) hasta que todas las pruebas pasen.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#organización-de-pruebas",
    "href": "testing-basics.html#organización-de-pruebas",
    "title": "13  Conceptos básicos de pruebas",
    "section": "\n13.4 Organización de pruebas",
    "text": "13.4 Organización de pruebas\nUn archivo de prueba se encuentra en tests/testthat/. Su nombre debe comenzar con “prueba”. Inspeccionaremos y ejecutaremos un archivo de prueba del paquete stringr.\n\nPero primero, a los efectos de reproducir este libro, debemos adjuntar stringr y probar eso. Tenga en cuenta que en situaciones de ejecución de pruebas de la vida real, las herramientas de desarrollo de paquetes se encargan de esto:\n\nDurante el desarrollo interactivo, devtools::load_all() hace que testthat y el paquete en desarrollo estén disponibles (tanto sus funciones exportadas como no exportadas).\nDurante la ejecución de la prueba independiente, devtools::test_active_file(), devtools::test() y tests/testthat.R se encargan de esto.\n\n\n\n\n\n\n\nImportante\n\n\n\nSus archivos de prueba no deben incluir estas llamadas library(). También solicitamos explícitamente testthat edición 3, pero en un paquete real esto se declarará en DESCRIPTION.\n\nlibrary(testthat)\nlibrary(stringr)\nlocal_edition(3)\n\n\n\nAquí está el contenido de tests/testthat/test-dup.r de stringr:\n\ntest_that(\"basic duplication works\", {\n  expect_equal(str_dup(\"a\", 3), \"aaa\")\n  expect_equal(str_dup(\"abc\", 2), \"abcabc\")\n  expect_equal(str_dup(c(\"a\", \"b\"), 2), c(\"aa\", \"bb\"))\n  expect_equal(str_dup(c(\"a\", \"b\"), c(2, 3)), c(\"aa\", \"bbb\"))\n})\n#&gt; Test passed\n\ntest_that(\"0 duplicates equals empty string\", {\n  expect_equal(str_dup(\"a\", 0), \"\")\n  expect_equal(str_dup(c(\"a\", \"b\"), 0), rep(\"\", 2))\n})\n#&gt; Test passed\n\ntest_that(\"uses tidyverse recycling rules\", {\n  expect_error(str_dup(1:2, 1:3), class = \"vctrs_error_incompatible_size\")\n})\n#&gt; Test passed\n\nEste archivo muestra una combinación típica de pruebas:\n\n“La duplicación básica funciona” prueba el uso típico de str_dup().\n“0 duplicados equivalen a una cadena vacía” investiga un caso extremo específico.\n“usa reglas de reciclaje de tidyverse” comprueba que la entrada con formato incorrecto produzca un tipo específico de error.\n\nLas pruebas están organizadas jerárquicamente: las expectativas se agrupan en pruebas que se organizan en archivos:\n\nUn archivo contiene múltiples pruebas relacionadas. En este ejemplo, el archivo tests/testthat/test-dup.r tiene todas las pruebas para el código en R/dup.r.\n\nUna prueba agrupa múltiples expectativas para probar el resultado de una función simple, una variedad de posibilidades para un solo parámetro de una función más complicada o una funcionalidad estrechamente relacionada de múltiples funciones. Es por eso que a veces se les llama pruebas unitarias. Cada prueba debe cubrir una única unidad de funcionalidad. Se crea una prueba con test_that(desc, code).\nEs común escribir la descripción (desc) para crear algo que se lea naturalmente, por ejemplo, test_that(\"la duplicación básica funciona\", {... }). Un informe de falla de prueba incluye esta descripción, razón por la cual desea una declaración concisa del propósito de la prueba, por ejemplo, un comportamiento específico.\n\nUna expectativa es el átomo de la prueba. Describe el resultado esperado de un cálculo: ¿Tiene el valor correcto y la clase correcta? ¿Produce un error cuando debería? Una expectativa automatiza la verificación visual de los resultados en la consola. Las expectativas son funciones que comienzan con expect_.\n\nDesea organizar las cosas de manera que, cuando una prueba falle, sepa qué está mal y en qué parte de su código buscar el problema. Esto motiva todas nuestras recomendaciones con respecto a la organización de archivos, el nombre de los archivos y la descripción de la prueba. Finalmente, trate de evitar poner demasiadas expectativas en una prueba; es mejor tener más pruebas más pequeñas que menos pruebas más grandes.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#expectativas",
    "href": "testing-basics.html#expectativas",
    "title": "13  Conceptos básicos de pruebas",
    "section": "\n13.5 Expectativas",
    "text": "13.5 Expectativas\nUna expectativa es el mejor nivel de prueba. Hace una afirmación binaria sobre si un objeto tiene o no las propiedades esperadas. Este objeto suele ser el valor de retorno de una función en su paquete.\nTodas las expectativas tienen una estructura similar:\n\nComienzan con expect_.\nTienen dos argumentos principales: el primero es el resultado real, el segundo es lo que se espera.\nSi los resultados reales y esperados no coinciden, la prueba arroja un error.\nAlgunas expectativas tienen argumentos adicionales que controlan los puntos más finos de comparar un resultado real y esperado.\n\nSi bien normalmente colocará las expectativas dentro de las pruebas dentro de los archivos, también puede ejecutarlas directamente. Esto facilita la exploración de las expectativas de forma interactiva. Hay más de 40 expectativas en el paquete testthat, que se pueden explorar en el índice de referencia de testthat. Aquí sólo cubriremos las expectativas más importantes.\n\n13.5.1 Pruebas de igualdad\nexpect_equal() comprueba la igualdad, con una cantidad razonable de tolerancia numérica:\n\nexpect_equal(10, 10)\nexpect_equal(10, 10L)\nexpect_equal(10, 10 + 1e-7)\nexpect_equal(10, 11)\n#&gt; Error: 10 (`actual`) not equal to 11 (`expected`).\n#&gt; \n#&gt;   `actual`: 10\n#&gt; `expected`: 11\n\nSi desea probar la equivalencia exacta, utilice expect_identical().\n\nexpect_equal(10, 10 + 1e-7)\nexpect_identical(10, 10 + 1e-7)\n#&gt; Error: 10 (`actual`) not identical to 10 + 1e-07 (`expected`).\n#&gt; \n#&gt;   `actual`: 10.0000000\n#&gt; `expected`: 10.0000001\n\nexpect_equal(2, 2L)\nexpect_identical(2, 2L)\n#&gt; Error: 2 (`actual`) not identical to 2L (`expected`).\n#&gt; \n#&gt; `actual` is a double vector (2)\n#&gt; `expected` is an integer vector (2)\n\n\n13.5.2 Prueba de errores\nUtilice expect_error() para comprobar si una expresión arroja un error. Es la expectativa más importante en un trío que también incluye expect_warning() y expect_message(). Aquí vamos a enfatizar los errores, pero la mayor parte de esto también se aplica a las advertencias y mensajes.\nPor lo general, le importan dos cosas cuando prueba un error:\n\n¿El código falla? Específicamente, ¿falla por el motivo correcto?\n¿Tiene sentido el mensaje que lo acompaña para el ser humano que necesita lidiar con el error?\n\nLa solución básica es esperar un tipo específico de condición:\n\n1 / \"a\"\n#&gt; Error in 1/\"a\": non-numeric argument to binary operator\nexpect_error(1 / \"a\") \n\nlog(-1)\n#&gt; Warning in log(-1): NaNs produced\n#&gt; [1] NaN\nexpect_warning(log(-1))\n\nSin embargo, esto es un poco peligroso, especialmente cuando se prueba un error. ¡Hay muchas maneras en que el código falla! Considere la siguiente prueba:\n\nexpect_error(str_duq(1:2, 1:3))\n\nEsta expectativa tiene como objetivo probar el comportamiento de reciclaje de str_dup(). Pero, debido a un error tipográfico, prueba el comportamiento de una función inexistente, str_duq(). El código arroja un error y, por lo tanto, la prueba anterior pasa, pero por el motivo equivocado. Debido al error tipográfico, el error real arrojado se debe a que no se puede encontrar la función str_duq():\n\nstr_duq(1:2, 1:3)\n#&gt; Error in str_duq(1:2, 1:3): could not find function \"str_duq\"\n\nHistóricamente, la mejor defensa contra esto era afirmar que el mensaje de condición coincide con una determinada expresión regular, mediante el segundo argumento, regexp.\n\nexpect_error(1 / \"a\", \"non-numeric argument\")\nexpect_warning(log(-1), \"NaNs produced\")\n\nDe hecho, esto hace que nuestro problema de error tipográfico salga a la superficie:\n\nexpect_error(str_duq(1:2, 1:3), \"recycle\")\n#&gt; Error in str_duq(1:2, 1:3): could not find function \"str_duq\"\n\nLos desarrollos recientes tanto en base R como en rlang hacen que sea cada vez más probable que las condiciones se señalen con una clase, lo que proporciona una mejor base para crear expectativas precisas. Eso es exactamente lo que ya has visto en este ejemplo de cadena. Para esto sirve el argumento class:\n\n# falla, el error tiene una clase incorrecta\nexpect_error(str_duq(1:2, 1:3), class = \"vctrs_error_incompatible_size\")\n#&gt; Error in str_duq(1:2, 1:3): could not find function \"str_duq\"\n\n# pasa, el error tiene la clase esperada\nexpect_error(str_dup(1:2, 1:3), class = \"vctrs_error_incompatible_size\")\n\n\nSi tiene la opción, exprese sus expectativas en términos de la clase de la condición, en lugar de su mensaje. A menudo esto está bajo su control, es decir, si su paquete indica la condición. Si la condición se origina en la base R u otro paquete, proceda con precaución. Esto suele ser un buen recordatorio para reconsiderar la conveniencia de probar una condición que, en primer lugar, no está completamente bajo su control.\nPara verificar la ausencia de un error, advertencia o mensaje, use expect_no_error():\n\nexpect_no_error(1 / 2)\n\nPor supuesto, esto es funcionalmente equivalente a simplemente ejecutar 1/2 dentro de una prueba, pero algunos desarrolladores encuentran expresiva la expectativa explícita.\nSi realmente le importa el mensaje de la condición, las pruebas instantáneas de testthat 3e son el mejor enfoque, que describimos a continuación.\n\n13.5.3 Pruebas de instantáneas\nA veces resulta difícil o incómodo describir un resultado esperado con código. Las pruebas instantáneas son una gran solución a este problema y esta es una de las principales innovaciones en testthat 3e. La idea básica es registrar el resultado esperado en un archivo separado y legible por humanos. En el futuro, prueba que le avisa cuando un resultado recién calculado difiere de la instantánea registrada anteriormente. Las pruebas de instantáneas son particularmente adecuadas para monitorear la interfaz de usuario de su paquete, como sus mensajes informativos y errores. Otros casos de uso incluyen probar imágenes u otros objetos complicados.\nIlustraremos las pruebas de instantáneas utilizando el paquete waldo. Debajo del capó, testthat 3e usa waldo para hacer el trabajo pesado de comparaciones “reales versus esperadas”, por lo que es bueno que sepas un poco sobre waldo de todos modos. Uno de los principales objetivos de diseño de Waldo es presentar las diferencias de una manera clara y práctica, en lugar de una frustrante declaración de que “esto difiere de aquello y sé exactamente cómo, pero no te lo diré”. Por lo tanto, el formato de la salida de waldo::compare() es muy intencional y se adapta bien a una prueba de instantáneas. El resultado binario de TRUE (real == esperado) versus FALSE (real! = esperado) es bastante fácil de verificar y podría obtener su propia prueba. Aquí nos preocupa escribir una prueba para garantizar que las diferencias se informen al usuario de la forma prevista.\nWaldo utiliza algunos diseños diferentes para mostrar diferencias, dependiendo de diversas condiciones. Aquí restringimos deliberadamente el ancho para activar un diseño de lado a lado.2 (Hablaremos más sobre el paquete withr a continuación).\n\nwithr::with_options(\n  list(width = 20),\n  waldo::compare(c(\"X\", letters), c(letters, \"X\"))\n)\n#&gt;     old | new    \n#&gt; [1] \"X\" -        \n#&gt; [2] \"a\" | \"a\" [1]\n#&gt; [3] \"b\" | \"b\" [2]\n#&gt; [4] \"c\" | \"c\" [3]\n#&gt; \n#&gt;      old | new     \n#&gt; [25] \"x\" | \"x\" [24]\n#&gt; [26] \"y\" | \"y\" [25]\n#&gt; [27] \"z\" | \"z\" [26]\n#&gt;          - \"X\" [27]\n\nLas dos entradas principales difieren en dos ubicaciones: una al principio y otra al final. Este diseño presenta ambos, con algún contexto circundante, que ayuda al lector a orientarse.\nAsí es como se vería esto como una prueba instantánea:\n\n\ntest_that(\"side-by-side diffs work\", {\n  withr::local_options(width = 20)\n  expect_snapshot(\n    waldo::compare(c(\"X\", letters), c(letters, \"X\"))\n  )\n})\n\nSi ejecuta expect_snapshot() o una prueba que contiene expect_snapshot() de forma interactiva, verá esto:\nCan't compare snapshot to reference when testing interactively\nℹ Run `devtools::test()` or `testthat::test_file()` to see changes\nseguido de una vista previa de la salida de la instantánea.\nEsto le recuerda que las pruebas instantáneas solo funcionan cuando se ejecutan de forma no interactiva, es decir, mientras se ejecuta un archivo de prueba completo o todo el conjunto de pruebas. Esto se aplica tanto a la grabación de instantáneas como a su comprobación.\nLa primera vez que se ejecuta esta prueba a través de devtools::test() o similar, verá algo como esto (suponga que la prueba está en tests/testthat/test-diff.R):\n── Warning (test-diff.R:63:3): side-by-side diffs work ─────────────────────\nAdding new snapshot:\nCode\n  waldo::compare(c(\n    \"X\", letters), c(\n    letters, \"X\"))\nOutput\n      old | new    \n  [1] \"X\" -        \n  [2] \"a\" | \"a\" [1]\n  [3] \"b\" | \"b\" [2]\n  [4] \"c\" | \"c\" [3]\n  \n       old | new     \n  [25] \"x\" | \"x\" [24]\n  [26] \"y\" | \"y\" [25]\n  [27] \"z\" | \"z\" [26]\n           - \"X\" [27]\nSiempre hay una advertencia al crear la instantánea inicial. La instantánea se agrega a tests/testthat/_snaps/diff.md, bajo el título “side-by-side diffs work”, que proviene de la descripción de la prueba. La instantánea se ve exactamente como lo que un usuario ve de forma interactiva en la consola, que es la experiencia que queremos comprobar. El archivo de instantánea también es muy legible, lo cual resulta agradable para el desarrollador del paquete. Esta legibilidad se extiende a los cambios de instantáneas, es decir, al examinar las diferencias de Git y revisar las solicitudes de extracción en GitHub, lo que le ayuda a controlar su interfaz de usuario. En el futuro, siempre que su paquete continúe recapitulando la instantánea esperada, esta prueba pasará.\nSi ha escrito muchas pruebas unitarias convencionales, podrá apreciar lo adecuadas que son las pruebas instantáneas para este caso de uso. Si nos viésemos obligados a incluir el resultado esperado en el archivo de prueba, habría una gran cantidad de citas, escapes y administración de nuevas líneas. Irónicamente, con las expectativas convencionales, el resultado que espera que vea su usuario tiende a quedar oscurecido por una pesada capa de ruido sintáctico.\n¿Qué pasa cuando falla una prueba instantánea? Imaginemos un cambio interno hipotético en el que las etiquetas predeterminadas cambian de “old” y “new” a “OLD” y “NEW”. Así es como reaccionaría esta prueba instantánea:\n── Failure (test-diff.R:63:3): side-by-side diffs work──────────────────────────\nSnapshot of code has changed:\nold[3:15] vs new[3:15]\n  \"    \\\"X\\\", letters), c(\"\n  \"    letters, \\\"X\\\"))\"\n  \"Output\"\n- \"      old | new    \"\n+ \"      OLD | NEW    \"\n  \"  [1] \\\"X\\\" -        \"\n  \"  [2] \\\"a\\\" | \\\"a\\\" [1]\"\n  \"  [3] \\\"b\\\" | \\\"b\\\" [2]\"\n  \"  [4] \\\"c\\\" | \\\"c\\\" [3]\"\n  \"  \"\n- \"       old | new     \"\n+ \"       OLD | NEW     \"\nand 3 more ...\n\n* Run `snapshot_accept('diff')` to accept the change\n* Run `snapshot_review('diff')` to interactively review the change\nEsta diferencia se presenta de manera más efectiva en la mayoría de los usos del mundo real, por ejemplo, en la consola, mediante un cliente Git o mediante una aplicación Shiny (ver más abajo). Pero incluso esta versión en texto plano resalta los cambios con bastante claridad. Cada uno de los dos lugares de cambio se indica con un par de líneas marcadas con - y +, que muestran cómo ha cambiado la instantánea.\nPuedes llamar a testthat::snapshot_review('diff') para revisar los cambios localmente en una aplicación Shiny, lo que te permite omitir o aceptar instantáneas individuales. O, si todos los cambios son intencionales y esperados, puede ir directamente a testthat::snapshot_accept('diff'). Una vez que haya resincronizado su salida real y las instantáneas archivadas, sus pruebas pasarán una vez más. En la vida real, las pruebas instantáneas son una excelente manera de mantenerse informado sobre los cambios en la interfaz de usuario de su paquete, debido a sus propios cambios internos o a cambios en sus dependencias o incluso al propio R.\nexpect_snapshot() tiene algunos argumentos que vale la pena conocer:\n\ncran = FALSE: De forma predeterminada, las pruebas instantáneas se omiten si parece que se están ejecutando en los servidores de CRAN. Esto refleja la intención típica de las pruebas instantáneas, que es monitorear proactivamente la interfaz de usuario, pero no verificar su corrección, lo que presumiblemente es el trabajo de otras pruebas unitarias que no se omiten. En el uso típico, un cambio de instantánea es algo que el desarrollador querrá saber, pero no indica un defecto real.\n\nerror = FALSE: De forma predeterminada, el código de instantánea no puede generar un error. Consulte expect_error(), descrito anteriormente, para conocer un enfoque para probar errores. Pero a veces quieres evaluar “¿Tiene sentido este mensaje de error para un humano?” y tenerlo presentado en contexto en una instantánea es una excelente manera de verlo con nuevos ojos. Especifique error = TRUE en este caso:\n\nexpect_snapshot(error = TRUE,\n  str_dup(1:2, 1:3)\n)\n\n\ntransform: a veces una instantánea contiene elementos volátiles e insignificantes, como una ruta de archivo temporal o una marca de tiempo. El argumento transform acepta una función, presumiblemente escrita por usted, para eliminar o reemplazar dicho texto modificable. Otro uso de “transformar” es eliminar información confidencial de la instantánea.\nvariante: A veces las instantáneas reflejan las condiciones ambientales, como el sistema operativo o la versión de R o una de tus dependencias, y necesitas una instantánea diferente para cada variante. Esta es una característica experimental y algo avanzada, por lo que si puedes organizar las cosas para usar una sola instantánea, probablemente deberías hacerlo.\n\nEn un uso típico, testthat se encargará de administrar los archivos de instantáneas debajo de tests/testthat/_snaps/. Esto sucede en el curso normal de la ejecución de las pruebas y, tal vez, al llamar a testthat::snapshot_accept().\n\n13.5.4 Atajos para otros patrones comunes\nConcluimos esta sección con algunas expectativas más que surgen con frecuencia. Pero recuerde que la prueba tiene muchas más expectativas prediseñadas de las que podemos demostrar aquí.\nVarias expectativas pueden describirse como “atajos”, es decir, simplifican un patrón que aparece con suficiente frecuencia como para merecer su propio envoltorio.\n\n\nexpect_match(object, regexp, ...) es un atajo que envuelve grepl(pattern = regexp, x = object, ...). Compara una entrada de vector de caracteres con una expresión regular regexp. El argumento opcional “todos” controla si todos los elementos o solo uno deben coincidir. Lea la documentación expect_match() para ver cómo argumentos adicionales, como ignore.case = FALSE o fixed = TRUE, se pueden pasar a grepl().\n\nstring &lt;- \"Testing is fun!\"\n\nexpect_match(string, \"Testing\") \n\n#  Falla, la coincidencia distingue entre mayúsculas y minúsculas\nexpect_match(string, \"testing\")\n#&gt; Error: `string` does not match \"testing\".\n#&gt; Actual value: \"Testing is fun!\"\n\n#  Pasa porque se pasan argumentos adicionales a grepl():\nexpect_match(string, \"testing\", ignore.case = TRUE)\n\n\nexpect_length(object, n) es un atajo para expect_equal(length(object), n).\nexpect_setequal(x, y) prueba que cada elemento de x ocurre en y, y que cada elemento de y ocurre en x. Pero no fallará si “x” e “y” tienen sus elementos en un orden diferente.\n\nexpect_s3_class() y expect_s4_class() comprueban que un objeto hereda() de una clase especificada. expect_type()comprueba el typeof() de un objeto.\n\nmodel &lt;- lm(mpg ~ wt, data = mtcars)\nexpect_s3_class(model, \"lm\")\nexpect_s3_class(model, \"glm\")\n#&gt; Error: `model` inherits from 'lm' not 'glm'.\n\n\n\nexpect_true() y expect_false() son complementos útiles si ninguna de las otras expectativas cumple con lo que necesitas.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-basics.html#footnotes",
    "href": "testing-basics.html#footnotes",
    "title": "13  Conceptos básicos de pruebas",
    "section": "",
    "text": "La función heredada testthat::context() ahora se reemplaza y se desaconseja su uso en código nuevo o mantenido activamente. En la prueba 3e, context() está formalmente obsoleto; simplemente deberías eliminarlo. Una vez que adopta un enfoque intencional y sincronizado para la organización de los archivos debajo de R/ y tests/testthat/, la información contextual necesaria está ahí mismo en el nombre del archivo, lo que hace que el context() heredado sea superfluo.↩︎\nLa prueba de Waldo real que inspira este ejemplo apunta a una función auxiliar no exportada que produce el diseño deseado. Pero este ejemplo utiliza una función waldo exportada por simplicidad.↩︎",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Conceptos básicos de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-design.html",
    "href": "testing-design.html",
    "title": "14  Diseñar su conjunto de pruebas",
    "section": "",
    "text": "14.1 Qué probar\nExiste un delicado equilibrio en la redacción de exámenes. Cada prueba que escribe hace que sea menos probable que su código cambie sin darse cuenta; pero también puede hacer que sea más difícil cambiar tu código a propósito. Es difícil dar buenos consejos generales sobre la redacción de exámenes, pero estos puntos pueden resultarle útiles:",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Diseñar su conjunto de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-design.html#qué-probar",
    "href": "testing-design.html#qué-probar",
    "title": "14  Diseñar su conjunto de pruebas",
    "section": "",
    "text": "Siempre que tenga la tentación de escribir algo en una declaración impresa o en una expresión de depuración, escríbalo como una prueba. — Martin Fowler\n\n\n\nConcéntrese en probar la interfaz externa de sus funciones: si prueba la interfaz interna, entonces será más difícil cambiar la implementación en el futuro porque, además de modificar el código, también necesitará actualizar todas las pruebas.\nEsforzarse por probar cada comportamiento en una y sólo una prueba. Luego, si ese comportamiento cambia más adelante, solo necesitará actualizar una única prueba.\nEvite probar código simple que esté seguro de que funcionará. En su lugar, concentre su tiempo en código del que no esté seguro, que sea frágil o que tenga interdependencias complicadas. Dicho esto, a menudo cometemos la mayor cantidad de errores cuando asumimos erróneamente que el problema es simple y no necesita ninguna prueba.\nSiempre escribe una prueba cuando descubras un error. Puede que le resulte útil adoptar la filosofía de dar prioridad a la prueba. Allí siempre se comienza escribiendo las pruebas y luego se escribe el código que las hace pasar. Esto refleja una importante estrategia de resolución de problemas: comience estableciendo sus criterios de éxito, cómo sabe si ha resuelto el problema.\n\n\n14.1.1 Cobertura de prueba\nOtra forma concreta de dirigir sus esfuerzos de redacción de exámenes es examinar la cobertura de su examen. El paquete cover (https://covr.r-lib.org) se puede utilizar para determinar qué líneas del código fuente de su paquete se ejecutan (¡o no!) cuando se ejecuta el conjunto de pruebas. La mayoría de las veces esto se presenta como un porcentaje. En términos generales, cuanto más alto, mejor.\nEn cierto sentido técnico, el objetivo es una cobertura de prueba del 100%; sin embargo, esto rara vez se logra en la práctica y, a menudo, está bien. Pasar de una cobertura del 90 % o 99 % al 100 % no siempre es el mejor uso de su tiempo y energía de desarrollo. En muchos casos, ese último 10% o 1% a menudo requiere algo de gimnasia incómoda para cubrirlo. A veces esto te obliga a introducir burlas o alguna otra complejidad nueva. No sacrifique la capacidad de mantenimiento de su conjunto de pruebas para cubrir algún caso extremo extraño que aún no ha demostrado ser un problema. Recuerde también que no todas las líneas de código o todas las funciones tienen la misma probabilidad de albergar errores. Concentre su energía de prueba en el código que sea complicado, basándose en su opinión experta y en cualquier evidencia empírica que haya acumulado sobre los puntos críticos de errores.\nUsamos covr regularmente, de dos maneras diferentes:\n\nUso local e interactivo. Usamos principalmente devtools::test_coverage_active_file() y devtools::test_coverage(), para explorar la cobertura de un archivo individual o del paquete completo, respectivamente.\nUso automático y remoto a través de GitHub Actions (GHA). Cubrimos la integración continua y GHA más a fondo en Capítulo 20, pero al menos mencionaremos aquí que usethis::use_github_action(\"test-coverage\") configura un flujo de trabajo de GHA que monitorea constantemente la cobertura de su prueba. La cobertura de la prueba puede ser una métrica especialmente útil al evaluar una solicitud de extracción (ya sea propia o de un colaborador externo). Un cambio propuesto que esté bien cubierto por pruebas tiene menos riesgo de fusionarse.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Diseñar su conjunto de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-design.html#sec-testing-design-principles",
    "href": "testing-design.html#sec-testing-design-principles",
    "title": "14  Diseñar su conjunto de pruebas",
    "section": "\n14.2 Principios de alto nivel para realizar pruebas",
    "text": "14.2 Principios de alto nivel para realizar pruebas\nEn secciones posteriores, ofrecemos estrategias concretas sobre cómo manejar dilemas de prueba comunes en R. Aquí exponemos los principios de alto nivel que sustentan estas recomendaciones:\n\nLo ideal es que una prueba sea autosuficiente y autónoma.\nEl flujo de trabajo interactivo es importante, porque interactuará principalmente con sus pruebas cuando fallen.\nEs más importante que el código de prueba sea obvio que, por ejemplo, lo más SECO posible.\nSin embargo, el flujo de trabajo interactivo no debería “filtrarse” ni socavar el conjunto de pruebas.\n\nEscribir buenas pruebas para una base de código a menudo resulta más desafiante que escribir el código en primer lugar. Esto puede resultar un poco sorprendente si eres nuevo en el desarrollo de paquetes y te preocupa estar haciéndolo mal. ¡No te preocupes, no lo eres! Las pruebas presentan muchos desafíos y maniobras únicos, que tienden a tener mucho menos tiempo en las comunidades de programación que las estrategias para escribir el “código principal”, es decir, el contenido debajo de R/. Como resultado, se requiere un esfuerzo más deliberado para desarrollar sus habilidades y gustos en torno a las pruebas.\nMuchos de los paquetes mantenidos por nuestro equipo violan algunos de los consejos que encontrará aquí. Hay (al menos) dos razones para ello:\n\nprueba que ha estado evolucionando durante más de doce años y este capítulo refleja las lecciones acumuladas aprendidas de esa experiencia. Las pruebas en muchos paquetes se han implementado durante mucho tiempo y reflejan prácticas típicas de diferentes épocas y diferentes mantenedores.\nEstas no son reglas estrictas y rápidas, sino más bien pautas. Siempre habrá situaciones específicas en las que tendrá sentido infringir la regla.\n\nEste capítulo no puede abordar todas las situaciones de prueba posibles, pero esperamos que estas pautas le ayuden en su futura toma de decisiones.\n\n14.2.1 Pruebas autosuficientes\n\nTodas las pruebas deben esforzarse por ser herméticas: una prueba debe contener toda la información necesaria para configurar, ejecutar y desmantelar su entorno. Las pruebas deben asumir lo menos posible sobre el entorno exterior….\nDel libro Ingeniería de software en Google, Capítulo 11\n\nRecuerde este consejo que se encuentra en Sección 6.5, que cubre el “código principal” de su paquete, es decir, todo lo que está debajo de R/:\n\nLos archivos .R debajo de R/ deberían consistir casi en su totalidad en definiciones de funciones. Cualquier otro código de nivel superior es sospechoso y debe revisarse cuidadosamente para detectar una posible conversión en una función.\n\nTenemos consejos análogos para sus archivos de prueba:\n\nLos archivos test-*.R debajo de tests/testthat/ deberían consistir casi en su totalidad en llamadas a test_that(). Cualquier otro código de nivel superior es sospechoso y se debe considerar cuidadosamente su reubicación en llamadas a test_that() o en otros archivos que reciben un tratamiento especial dentro de un paquete R o desde testthat.\n\nEliminar (o al menos minimizar) el código de nivel superior fuera de test_that() tendrá el efecto beneficioso de hacer que sus pruebas sean más herméticas. Este es básicamente el análogo de prueba del consejo general de programación de que es aconsejable evitar el intercambio de estado no estructurado.\nLa lógica en el nivel superior de un archivo de prueba tiene un alcance incómodo: los objetos o funciones definidos aquí tienen lo que se podría llamar “alcance del archivo de prueba”, si las definiciones aparecen antes de la primera llamada a test_that(). Si el código de nivel superior se intercala entre las llamadas test_that(), puedes incluso crear un “alcance parcial del archivo de prueba”.\nAl escribir pruebas, puede resultar conveniente confiar en estos objetos con ámbito de archivo, especialmente al principio de la vida de un conjunto de pruebas, por ejemplo, cuando cada archivo de prueba cabe en una pantalla. Pero encontramos que confiar implícitamente en objetos en el entorno principal de una prueba tiende a hacer que un conjunto de pruebas sea más difícil de entender y mantener con el tiempo.\nConsidere un archivo de prueba con código de nivel superior esparcido a su alrededor, fuera de test_that():\n\ndat &lt;- data.frame(x = c(\"a\", \"b\", \"c\"), y = c(1, 2, 3))\n\nskip_if(today_is_a_monday())\n\ntest_that(\"foofy() does this\", {\n  expect_equal(foofy(dat), ...)\n})\n\ndat2 &lt;- data.frame(x = c(\"x\", \"y\", \"z\"), y = c(4, 5, 6))\n\nskip_on_os(\"windows\")\n\ntest_that(\"foofy2() does that\", {\n  expect_snapshot(foofy2(dat, dat2))\n})\n\nRecomendamos reubicar la lógica de ámbito de archivo a un ámbito más limitado o más amplio. Así es como se vería usar un alcance limitado, es decir, alinear todo dentro de las llamadas test_that():\n\ntest_that(\"foofy() does this\", {\n  skip_if(today_is_a_monday())\n  \n  dat &lt;- data.frame(x = c(\"a\", \"b\", \"c\"), y = c(1, 2, 3))\n  \n  expect_equal(foofy(dat), ...)\n})\n\ntest_that(\"foofy() does that\", {\n  skip_if(today_is_a_monday())\n  skip_on_os(\"windows\")\n  \n  dat &lt;- data.frame(x = c(\"a\", \"b\", \"c\"), y = c(1, 2, 3))\n  dat2 &lt;- data.frame(x = c(\"x\", \"y\", \"z\"), y = c(4, 5, 6))\n  \n  expect_snapshot(foofy(dat, dat2))\n})\n\nA continuación, analizaremos técnicas para mover la lógica de ámbito de archivo a un ámbito más amplio.\n\n14.2.2 Pruebas autónomas\nCada prueba test_that() tiene su propio entorno de ejecución, lo que la hace algo autónoma. Por ejemplo, un objeto R que crea dentro de una prueba no existe después de que finaliza la prueba:\n\nexists(\"thingy\")\n#&gt; [1] FALSE\n\ntest_that(\"thingy exists\", {\n  thingy &lt;- \"thingy\"\n  expect_true(exists(thingy))\n})\n#&gt; Test passed\n\nexists(\"thingy\")\n#&gt; [1] FALSE\n\nEl objeto thingy vive y muere completamente dentro de los límites de test_that(). Sin embargo, testthat no sabe cómo limpiar después de acciones que afectan otros aspectos del panorama de R:\n\nEl sistema de archivos: crear y eliminar archivos, cambiar el directorio de trabajo, etc.\nLa ruta de búsqueda: library(), attach().\nOpciones globales, como options() y par(), y variables de entorno.\n\nObserve cómo llamadas como library(), options() y Sys.setenv() tienen un efecto persistente después de una prueba, incluso cuando se ejecutan dentro de test_that():\n\ngrep(\"jsonlite\", search(), value = TRUE)\n#&gt; character(0)\ngetOption(\"opt_whatever\")\n#&gt; NULL\nSys.getenv(\"envvar_whatever\")\n#&gt; [1] \"\"\n\ntest_that(\"landscape changes leak outside the test\", {\n  library(jsonlite)\n  options(opt_whatever = \"whatever\")\n  Sys.setenv(envvar_whatever = \"whatever\")\n  \n  expect_match(search(), \"jsonlite\", all = FALSE)\n  expect_equal(getOption(\"opt_whatever\"), \"whatever\")\n  expect_equal(Sys.getenv(\"envvar_whatever\"), \"whatever\")\n})\n#&gt; Test passed\n\ngrep(\"jsonlite\", search(), value = TRUE)\n#&gt; [1] \"package:jsonlite\"\ngetOption(\"opt_whatever\")\n#&gt; [1] \"whatever\"\nSys.getenv(\"envvar_whatever\")\n#&gt; [1] \"whatever\"\n\nEstos cambios en el panorama persisten incluso más allá del archivo de prueba actual, es decir, se trasladan a todos los archivos de prueba posteriores.\nSi es fácil evitar realizar tales cambios en su código de prueba, ¡esa es la mejor estrategia! Pero si es inevitable, entonces debes asegurarte de limpiar lo que ensucias. Esta mentalidad es muy similar a la que defendimos en Sección 6.5, cuando analizamos cómo diseñar funciones educadas.\nNos gusta usar el paquete withr (https://withr.r-lib.org) para realizar cambios temporales en el estado global, porque captura automáticamente el estado inicial y organiza la restauración final. Ya has visto un ejemplo de su uso cuando exploramos las pruebas instantáneas:\n\ntest_that(\"side-by-side diffs work\", {\n  withr::local_options(width = 20) # &lt;-- (°_°) look here!\n  expect_snapshot(\n    waldo::compare(c(\"X\", letters), c(letters, \"X\"))\n  )\n})\n\nEsta prueba requiere que el ancho de visualización se establezca en 20 columnas, que es considerablemente menor que el ancho predeterminado. withr::local_options(width = 20) establece la opción width en 20 y, al final de la prueba, restaura la opción a su valor original. withr también es agradable de usar durante el desarrollo interactivo: las acciones diferidas aún se capturan en el entorno global y se pueden ejecutar explícitamente a través de withr::deferred_run() o implícitamente reiniciando R.\nRecomendamos incluir withr en Suggests, si solo lo vas a usar en tus pruebas, o en Imports, si también lo usas debajo de R/. Llame a las funciones withr como lo hicimos anteriormente, por ejemplo, como withr::local_whatever(), en cualquier caso. Consulte Sección 10.4.1 y Sección 11.5.2 para obtener más información.\n\n\n\n\n\n\nTip\n\n\n\nLa forma más sencilla de agregar un paquete a DESCRIPCIÓN es con, por ejemplo, usethis::use_package(\"withr\", type = \"Suggests\"). Para los paquetes de tidyverse, withr se considera una “dependencia libre”, es decir, tidyverse usa withr tan ampliamente que no dudamos en usarlo siempre que sea útil.\n\n\nwithr tiene un gran conjunto de funciones local_*() / with_*() preimplementadas que deberían manejar la mayoría de sus necesidades de prueba, así que verifique allí antes de escribir las suyas. Si no existe nada que satisfaga sus necesidades, withr::defer() es la forma general de programar alguna acción al final de una prueba.1\nAsí es como solucionaríamos los problemas en el ejemplo anterior usando withr: Detrás de escena, revertimos los cambios de paisaje, así que podemos intentar esto nuevamente.\n\ngrep(\"jsonlite\", search(), value = TRUE)\n#&gt; character(0)\ngetOption(\"opt_whatever\")\n#&gt; NULL\nSys.getenv(\"envvar_whatever\")\n#&gt; [1] \"\"\n\ntest_that(\"withr makes landscape changes local to a test\", {\n  withr::local_package(\"jsonlite\")\n  withr::local_options(opt_whatever = \"whatever\")\n  withr::local_envvar(envvar_whatever = \"whatever\")\n  \n  expect_match(search(), \"jsonlite\", all = FALSE)\n  expect_equal(getOption(\"opt_whatever\"), \"whatever\")\n  expect_equal(Sys.getenv(\"envvar_whatever\"), \"whatever\")\n})\n#&gt; Test passed\n\ngrep(\"jsonlite\", search(), value = TRUE)\n#&gt; character(0)\ngetOption(\"opt_whatever\")\n#&gt; NULL\nSys.getenv(\"envvar_whatever\")\n#&gt; [1] \"\"\n\ntestthat se apoya en gran medida en withr para hacer que los entornos de ejecución de pruebas sean lo más reproducibles y autónomos posible. En testthat 3e, testthat::local_reproducible_output() es implícitamente parte de cada prueba test_that().\n\ntest_that(\"something specific happens\", {\n  local_reproducible_output() # &lt;-- this happens implicitly\n  \n  # su código de prueba, que puede ser sensible a las condiciones ambientales, como\n  # ancho de visualización o el número de colores admitidos\n})\n\nlocal_reproducible_output() establece temporalmente varias opciones y variables de entorno en valores favorables para las pruebas, por ejemplo, suprime la salida en color, desactiva las comillas elegantes, establece el ancho de la consola y establece LC_COLLATE = \"C\". Por lo general, puedes disfrutar pasivamente de los beneficios de local_reproducible_output(). Pero es posible que desee llamarlo explícitamente al replicar resultados de pruebas de forma interactiva o si desea anular la configuración predeterminada en una prueba específica.\n\n14.2.3 Plan para el fracaso de la prueba\nWe regret to inform you that most of the quality time you spend with your tests will be when they are inexplicably failing.\n\nEn su forma más pura, la automatización de pruebas consta de tres actividades: escribir pruebas, ejecutar pruebas y reaccionar ante fallas de pruebas….\nRecuerde que las pruebas a menudo se revisan sólo cuando algo se rompe. Cuando lo llamen para arreglar una prueba fallida que nunca antes había visto, agradecerá que alguien se haya tomado el tiempo para hacerlo fácil de entender. El código se lee mucho más de lo que se escribe, ¡así que asegúrese de escribir la prueba que le gustaría leer!\nDel libro Ingeniería de software en Google, Capítulo 11\n\nLa mayoría de nosotros no trabajamos con una base de código del tamaño de Google. Pero incluso en un equipo de una sola persona, las pruebas que escribiste hace seis meses bien podrían haber sido escritas por otra persona. Especialmente cuando están fallando.\nCuando realizamos verificaciones de dependencia inversa, que a menudo involucran cientos o miles de paquetes CRAN, tenemos que inspeccionar las fallas de las pruebas para determinar si los cambios en nuestros paquetes son los culpables. Como resultado, nos enfrentamos regularmente con pruebas fallidas en paquetes de otras personas, lo que nos deja con muchas opiniones sobre prácticas que crean problemas innecesarios en las pruebas.\nEl nirvana de solución de problemas de prueba se ve así: en una nueva sesión de R, puede hacer devtools::load_all() e inmediatamente ejecutar una prueba individual o recorrerla línea por línea. No es necesario buscar código de configuración que deba ejecutarse manualmente primero, que se encuentre en otra parte del archivo de prueba o quizás en un archivo completamente diferente. El código relacionado con las pruebas que se encuentra en una ubicación no convencional provoca un dolor adicional autoinfligido cuando menos lo necesita.\nConsidere este ejemplo extremo y abstracto de una prueba que es difícil de solucionar debido a dependencias implícitas en el código de rango libre:\n\n# docenas o cientos de líneas de código de nivel superior, intercaladas con otras pruebas,\n# que debes leer y ejecutar selectivamente\n\ntest_that(\"f() works\", {\n  x &lt;- function_from_some_dependency(object_with_unknown_origin)\n  expect_equal(f(x), 2.5)\n})\n\nEsta prueba es mucho más fácil de realizar si las dependencias se invocan de la manera normal, es decir, mediante ::, y los objetos de prueba se crean en línea:\n\n# docenas o cientos de líneas de pruebas autónomas y autosuficientes,\n# ¡todo lo cual puedes ignorar con seguridad!\n\ntest_that(\"f() works\", {\n  useful_thing &lt;- ...\n  x &lt;- somePkg::someFunction(useful_thing)\n  expect_equal(f(x), 2.5)\n})\n\nEsta prueba es autosuficiente. El código dentro de {... } crea explícitamente los objetos o condiciones necesarios y realiza llamadas explícitas a cualquier función auxiliar. Esta prueba no se basa en objetos o dependencias que estén disponibles ambientalmente.\nLas pruebas autosuficientes y autónomas son beneficiosas para todos: es literalmente más seguro diseñar las pruebas de esta manera y también hace que las pruebas sean mucho más fáciles de solucionar para los humanos más adelante.\n\n14.2.4 La repetición está bien\nUna consecuencia obvia de nuestra sugerencia de minimizar el código con “alcance de archivo” es que sus pruebas probablemente tendrán algunas repeticiones. ¡Y eso está bien! Vamos a hacer la controvertida recomendación de que tolere una buena cantidad de duplicación en el código de prueba, es decir, que pueda relajar algunas de sus tendencias DRY (“no repetirse”).\n\nMantenga al lector en su función de prueba. Un buen código de producción está bien factorizado; Un buen código de prueba es obvio. … piense en qué hará que el problema sea obvio cuando falle una prueba.\nDe la publicación del blog Por qué los buenos desarrolladores escriben malas pruebas unitarias\n\nAquí hay un ejemplo de juguete para concretar las cosas.\n\ntest_that(\"multiplication works\", {\n  useful_thing &lt;- 3\n  expect_equal(2 * useful_thing, 6)\n})\n#&gt; Test passed\n\ntest_that(\"subtraction works\", {\n  useful_thing &lt;- 3\n  expect_equal(5 - useful_thing, 2)\n})\n#&gt; Test passed\n\nEn la vida real, useful_thing suele ser un objeto más complicado cuya creación de instancias resulta de alguna manera engorrosa. Observe cómo aparece useful_thing &lt;- 3 en más de un lugar. La sabiduría convencional dice que deberíamos SECAR este código. Es tentador simplemente mover la definición de useful_thing fuera de las pruebas:\n\nuseful_thing &lt;- 3\n\ntest_that(\"multiplication works\", {\n  expect_equal(2 * useful_thing, 6)\n})\n#&gt; Test passed\n\ntest_that(\"subtraction works\", {\n  expect_equal(5 - useful_thing, 2)\n})\n#&gt; Test passed\n\nPero realmente creemos que la primera forma, con repetición, suele ser la mejor opción.\nEn este punto, muchos lectores podrían estar pensando “¡pero el código que quizás tenga que repetir es mucho más largo que 1 línea!”. A continuación describimos el uso de dispositivos de prueba. A menudo, esto puede reducir situaciones complicadas a algo parecido a este ejemplo simple.\n\n14.2.5 Eliminar la tensión entre las pruebas interactivas y automatizadas\nYour test code will be executed in two different settings:\n\nDesarrollo y mantenimiento de pruebas interactivas, que incluye tareas como:\n\nCreación de prueba inicial\nModificación de pruebas para adaptarse al cambio.\nFallo en la prueba de depuración\n\n\nEjecuciones de pruebas automatizadas, que se logra con funciones como:\n\nArchivo único: devtools::test_active_file(), testthat::test_file()\n\nPaquete completo: devtools::test(), devtools::check()\n\n\n\n\nLa prueba automatizada de todo su paquete es lo que tiene prioridad. En última instancia, este es el objetivo de sus pruebas. Sin embargo, la experiencia interactiva es claramente importante para los humanos que realizan este trabajo. Por lo tanto, es importante encontrar un flujo de trabajo agradable, pero también asegurarse de no manipular nada para una conveniencia interactiva que realmente comprometa la salud del conjunto de pruebas.\nEstos dos modos de ejecución de pruebas no deberían entrar en conflicto entre sí. Si percibe tensión entre estos dos modos, esto puede indicar que no está aprovechando al máximo algunas de las características de testthat y la forma en que está diseñado para funcionar con devtools::load_all().\nCuando trabaje en sus pruebas, use load_all(), tal como lo hace cuando trabaja debajo de R/. Por defecto, load_all() hace todas estas cosas:\n\nSimula la reconstrucción, reinstalación y recarga de su paquete.\nHace que todo el espacio de nombres de su paquete esté disponible, incluidas funciones y objetos no exportados y cualquier cosa que haya importado de otro paquete.\nAdjunta testthat, es decir, biblioteca(testthat).\nEjecuta archivos auxiliares de prueba, es decir, ejecuta test/testthat/helper.R (más sobre esto a continuación).\n\nEsto elimina la necesidad de realizar llamadas a library() debajo de tests/testthat/, para la gran mayoría de los paquetes de R. Claramente, cualquier instancia de “biblioteca (prueba que)” ya no es necesaria. Del mismo modo, cualquier instancia de adjuntar una de sus dependencias a través de library(somePkg) es innecesaria. En sus pruebas, si necesita llamar funciones desde algúnPkg, hágalo tal como lo hace debajo de R/. Si ha importado la función a su espacio de nombres, use fun(). Si no lo ha hecho, utilice somePkg::fun(). Es justo decir que library(somePkg) en las pruebas debería ser tan raro como tomar una dependencia a través de Depends, es decir, casi siempre hay una alternativa mejor.\nLas llamadas innecesarias a library(somePkg) en archivos de prueba tienen un verdadero inconveniente, porque en realidad cambian el panorama de R. library() altera la ruta de búsqueda. Esto significa que las circunstancias bajo las cuales está realizando la prueba pueden no reflejar necesariamente las circunstancias bajo las cuales se utilizará su paquete. Esto hace que sea más fácil crear errores de prueba sutiles, que tendrás que solucionar en el futuro.\nOtra función que casi nunca debería aparecer debajo de tests/testhat/ es source(). Hay varios archivos especiales con una función oficial en los flujos de trabajo de prueba (ver más abajo), sin mencionar toda la maquinaria del paquete R, que brindan mejores formas de hacer que funciones, objetos y otra lógica estén disponibles en sus pruebas.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Diseñar su conjunto de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-design.html#sec-tests-files-overview",
    "href": "testing-design.html#sec-tests-files-overview",
    "title": "14  Diseñar su conjunto de pruebas",
    "section": "\n14.3 Archivos relevantes para las pruebas",
    "text": "14.3 Archivos relevantes para las pruebas\nAquí revisamos qué archivos de paquetes son especialmente relevantes para las pruebas y, de manera más general, las mejores prácticas para interactuar con el sistema de archivos de sus pruebas.\n\n14.3.1 Ocultar a simple vista: archivos debajo de R/\n\n¡Las funciones más importantes a las que necesitarás acceder desde tus pruebas son claramente las que están en tu paquete! Aquí estamos hablando de todo lo que se define debajo de R/. Las funciones y otros objetos definidos por su paquete siempre están disponibles durante las pruebas, independientemente de si se exportan o no. Para el trabajo interactivo, devtools::load_all() se encarga de esto. Durante las pruebas automatizadas, testthat se encarga de esto internamente.\nEsto implica que los ayudantes de prueba pueden definirse absolutamente debajo de R/ y usarse libremente en sus pruebas. Podría tener sentido reunir dichos ayudantes en un archivo claramente marcado, como uno de estos:\n.                              \n├── ...\n└── R\n    ├── ...\n    ├── test-helpers.R\n    ├── test-utils.R\n    ├── testthat.R\n    ├── utils-testing.R\n    └── ...\nPor ejemplo, el paquete dbplyr usa R/testthat.R para definir un par de ayudas para facilitar las comparaciones y las expectativas. que involucra objetos tbl, que se utiliza para representar tablas de bases de datos.\n\ncompare_tbl &lt;- function(x, y, label = NULL, expected.label = NULL) {\n  testthat::expect_equal(\n    arrange(collect(x), dplyr::across(everything())),\n    arrange(collect(y), dplyr::across(everything())),\n    label = label,\n    expected.label = expected.label\n  )\n}\n\nexpect_equal_tbls &lt;- function(results, ref = NULL, ...) {\n  # código que prepara las cosas...\n\n  for (i in seq_along(results)) {\n    compare_tbl(\n      results[[i]], ref,\n      label = names(results)[[i]],\n      expected.label = ref_name\n    )\n  }\n\n  invisible(TRUE)\n}\n\n\n14.3.2 tests/testthat.R\n\nRecuerde la configuración de prueba inicial descrita en Sección 13.3: El archivo estándar tests/testthat.R tiene este aspecto:\n\nlibrary(testthat)\nlibrary(pkg)\n\ntest_check(\"pkg\")\n\nRepetimos el consejo de no editar tests/testthat.R. Se ejecuta durante R CMD check (y, por lo tanto, devtools::check()), pero no se usa en la mayoría de los otros escenarios de ejecución de pruebas (como devtools::test() o devtools: :test_active_file() o durante el desarrollo interactivo). No adjunte sus dependencias aquí con library(). Llámelos en sus pruebas de la misma manera que lo hace debajo de R/ (Sección 11.4.2, Sección 11.5.2).\n\n14.3.3 Pruebe esos archivos auxiliares\nOtro tipo de archivo que siempre ejecuta load_all() y al comienzo de las pruebas automatizadas es un archivo auxiliar, definido como cualquier archivo debajo de tests/testthat/ que comienza con helper. Los archivos auxiliares son un arma poderosa en la batalla para eliminar el código que flota en el nivel superior de los archivos de prueba. Los archivos auxiliares son un excelente ejemplo de lo que queremos decir cuando recomendamos mover dicho código a un alcance más amplio. Los objetos o funciones definidos en un archivo auxiliar están disponibles para todas sus pruebas.\nSi tiene solo uno de esos archivos, probablemente debería llamarlo helper.R. Si organiza sus ayudantes en varios archivos, puede incluir un sufijo con información adicional. A continuación se muestran ejemplos de cómo podrían verse dichos archivos:\n.                              \n├── ...\n└── tests\n    ├── testthat\n    │   ├── helper.R\n    │   ├── helper-blah.R\n    │   ├── helper-foo.R    \n    │   ├── test-foofy.R\n    │   └── (more test files)\n    └── testthat.R\nMuchos desarrolladores utilizan archivos auxiliares para definir funciones auxiliares de prueba personalizadas, que describimos en detalle en Capítulo 15. En comparación con la definición de ayudantes debajo de R/, algunas personas encuentran que tests/testthat/helper.R deja más claro que estas utilidades son específicamente para probar el paquete. Esta ubicación también parece más natural si sus ayudantes confían en las funciones de prueba. Por ejemplo, usethis y vroom ambos tienen archivos tests/testthat/helper.R bastante extensos que definen muchos ayudantes de prueba personalizados. Aquí hay dos ayudantes de uso muy simples que verifican que el proyecto actualmente activo (generalmente un proyecto de prueba efímero) tenga un archivo o carpeta específica:\n\nexpect_proj_file &lt;- function(...) expect_true(file_exists(proj_path(...)))\nexpect_proj_dir &lt;- function(...) expect_true(dir_exists(proj_path(...)))\n\nUn archivo auxiliar también es una buena ubicación para el código de configuración necesario para sus efectos secundarios. Este es un caso en el que tests/testthat/helper.R es claramente más apropiado que un archivo debajo de R/. Por ejemplo, en un paquete de envoltura de API, helper.R es un buen lugar para (intentar) autenticarse con las credenciales de prueba 2.\n\n14.3.4 Testthat archivos de configuración\nTestthat tiene un tipo de archivo especial más: archivos de configuración, definidos como cualquier archivo debajo de test/testthat/ que comienza con setup. A continuación se muestra un ejemplo de cómo podría verse:\n.                              \n├── ...\n└── tests\n    ├── testthat\n    │   ├── helper.R\n    │   ├── setup.R\n    │   ├── test-foofy.R\n    │   └── (more test files)\n    └── testthat.R\nUn archivo de instalación se maneja casi exactamente como un archivo auxiliar, pero con dos grandes diferencias:\n\nLos archivos de instalación no se ejecutan con devtools::load_all().\nLos archivos de instalación suelen contener el código de desmontaje correspondiente.\n\nLos archivos de configuración son buenos para la configuración de pruebas globales diseñada para la ejecución de pruebas en entornos remotos o no interactivos. Por ejemplo, puede desactivar el comportamiento dirigido a un usuario interactivo, como enviar mensajes o escribir en el portapapeles.\nSi alguna parte de su configuración debe revertirse después de la ejecución de la prueba, también debe incluir el código de desmontaje necesario en setup.R3. Recomendamos mantener el código de desmontaje junto con el código de configuración, en setup.R, porque esto hace que sea más fácil garantizar que permanezcan sincronizados. El entorno artificial teardown_env() existe como un identificador mágico para usar en withr::defer() y withr::local_*() / withr::with_*().\nAquí hay un ejemplo de setup.R del paquete reprex, donde desactivamos la funcionalidad de vista previa HTML y del portapapeles durante las pruebas:\n\nop &lt;- options(reprex.clipboard = FALSE, reprex.html_preview = FALSE)\n\nwithr::defer(options(op), teardown_env())\n\nDado que aquí solo estamos modificando opciones, podemos ser aún más concisos y usar la función prediseñada withr::local_options() y pasar teardown_env() como .local_envir:\n\nwithr::local_options(\n  list(reprex.clipboard = FALSE, reprex.html_preview = FALSE),\n  .local_envir = teardown_env()\n)\n\n\n14.3.5 Archivos ignorados por testthat\ntestthat solo ejecuta automáticamente archivos donde ambos son verdaderos:\n\nEl archivo es hijo directo de tests/testthat/\n\nEl nombre del archivo comienza con una de las cadenas específicas:\n\nhelper\nsetup\ntest\n\n\n\nEstá bien tener otros archivos o directorios en tests/testthat/, pero testthat no hará nada automáticamente con ellos (aparte del directorio _snaps, que contiene instantáneas).\n\n14.3.6 Almacenamiento de datos de prueba\nMuchos paquetes contienen archivos que contienen datos de prueba. ¿Dónde deberían almacenarse? La mejor ubicación es en algún lugar debajo de tests/testthat/, a menudo en un subdirectorio, para mantener todo ordenado. A continuación se muestra un ejemplo, donde useful_thing1.rds y useful_thing2.rds contienen objetos utilizados en los archivos de prueba.\n.\n├── ...\n└── tests\n    ├── testthat\n    │   ├── fixtures\n    │   │   ├── make-useful-things.R\n    │   │   ├── useful_thing1.rds\n    │   │   └── useful_thing2.rds\n    │   ├── helper.R\n    │   ├── setup.R\n    │   └── (all the test files)\n    └── testthat.R\nLuego, en sus pruebas, utilice testthat::test_path() para crear una ruta de archivo sólida para dichos archivos.\n\ntest_that(\"foofy() does this\", {\n  useful_thing &lt;- readRDS(test_path(\"fixtures\", \"useful_thing1.rds\"))\n  # ...\n})\n\ntestthat::test_path() es extremadamente útil, porque produce la ruta correcta en los dos modos importantes de ejecución de pruebas:\n\nDesarrollo y mantenimiento de pruebas interactivas, donde el directorio de trabajo presumiblemente está configurado en el nivel superior del paquete.\nPruebas automatizadas, donde el directorio de trabajo generalmente se establece en algo debajo de tests/.\n\n14.3.7 Dónde escribir archivos durante la prueba\nSi es fácil evitar escribir archivos de sus pruebas, ese es definitivamente el mejor plan. Pero hay muchas ocasiones en las que realmente debes escribir archivos.\nSolo debes escribir archivos dentro del directorio temporal de la sesión. No escribas en el directorio tests/ de tu paquete. No escriba en el directorio de trabajo actual. No escriba en el directorio de inicio del usuario. Aunque esté escribiendo en el directorio temporal de la sesión, aún debe limpiarlo, es decir, eliminar cualquier archivo que haya escrito.\nLa mayoría de los desarrolladores de paquetes no quieren escuchar esto porque suena como una molestia. Pero no es tan complicado una vez que te familiarizas con algunas técnicas y desarrollas algunos hábitos nuevos. Un alto nivel de disciplina en el sistema de archivos también elimina varios errores de prueba y hará que su vida con CRAN funcione mejor.\nEsta prueba es de roxygen2 y demuestra todo lo que recomendamos:\n\ntest_that(\"can read from file name with utf-8 path\", {\n  path &lt;- withr::local_tempfile(\n    pattern = \"Universit\\u00e0-\",\n    lines = c(\"#' @include foo.R\", NULL)\n  )\n  expect_equal(find_includes(path), \"foo.R\")\n})\n\nwithr::local_tempfile() crea un archivo dentro del directorio temporal de la sesión cuya vida útil está vinculada al entorno “local”, en este caso, el entorno de ejecución de una prueba individual. Es un contenedor alrededor de base::tempfile() y pasa, por ejemplo, el argumento pattern, por lo que tienes cierto control sobre el nombre del archivo. Opcionalmente, puede proporcionar “líneas” para completar el archivo en el momento de la creación o puede escribir en el archivo de todas las formas habituales en los pasos posteriores. Finalmente, sin ningún esfuerzo especial por tu parte, el archivo temporal se eliminará automáticamente al finalizar la prueba.\nA veces necesitas aún más control sobre el nombre del archivo. En ese caso, puede usar withr::local_tempdir() para crear un directorio temporal que se elimina automáticamente y escribir archivos con nombres intencionales dentro de este directorio.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Diseñar su conjunto de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-design.html#footnotes",
    "href": "testing-design.html#footnotes",
    "title": "14  Diseñar su conjunto de pruebas",
    "section": "",
    "text": "on.exit() de Base R es otra alternativa, pero requiere más de tu parte. Debe capturar el estado original y escribir el código de restauración usted mismo. También recuerde hacer on.exit(..., add = TRUE) si hay alguna posibilidad de que se pueda agregar una segunda llamada on.exit() en la prueba. Probablemente también quieras establecer el valor predeterminado after = FALSE.↩︎\ngoogledrive hace esto en https://github.com/tidyverse/googledrive/blob/906680f84b2cec2e4553978c9711be8d42ba33f7/tests/testthat/helper.R#L1-L10.↩︎\nUn enfoque heredado (que todavía funciona, pero ya no se recomienda) es colocar el código de desmontaje en tests/testthat/teardown.R.↩︎",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Diseñar su conjunto de pruebas</span>"
    ]
  },
  {
    "objectID": "testing-advanced.html",
    "href": "testing-advanced.html",
    "title": "15  Técnicas de prueba avanzadas",
    "section": "",
    "text": "15.1 Accesorios de prueba\nCuando no sea práctico hacer que su prueba sea completamente autosuficiente, prefiera hacer que el objeto, la lógica o las condiciones necesarios estén disponibles de una manera estructurada y explícita. Hay un término preexistente para esto en ingeniería de software: un dispositivo de prueba.\nLa idea principal es que debemos hacer que sea lo más fácil y obvio posible organizar el mundo en un estado propicio para las pruebas. Describimos varias soluciones específicas a este problema:",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Técnicas de prueba avanzadas</span>"
    ]
  },
  {
    "objectID": "testing-advanced.html#accesorios-de-prueba",
    "href": "testing-advanced.html#accesorios-de-prueba",
    "title": "15  Técnicas de prueba avanzadas",
    "section": "",
    "text": "Un dispositivo de prueba es algo que se utiliza para probar consistentemente algún elemento, dispositivo o software. — Wikipedia\n\n\n\nPoner código repetido en una función auxiliar de tipo constructor. Téngalo en cuenta si se demuestra que la construcción es lenta.\nSi el código repetido tiene efectos secundarios, escriba una función local_*() personalizada para hacer lo que sea necesario y limpiar después.\nSi los métodos anteriores son demasiado lentos o incómodos y lo que necesita es bastante estable, guárdelo como un archivo estático y cárguelo.\n\n\n15.1.1 Crear cosas_útiles con una función auxiliar\n¿Es complicado crear una useful_thing? ¿Se necesitan varias líneas de código, pero no mucho tiempo ni memoria? En ese caso, escriba una función auxiliar para crear una useful_thing a pedido:\n\nnew_useful_thing &lt;- function() {\n  # tu complicado código para crear algo útil va aquí\n}\n\ny llamar a ese ayudante en las pruebas afectadas:\n\ntest_that(\"foofy() does this\", {\n  useful_thing1 &lt;- new_useful_thing()\n  expect_equal(foofy(useful_thing1, x = \"this\"), EXPECTED_FOOFY_OUTPUT)\n})\n\ntest_that(\"foofy() does that\", {\n  useful_thing2 &lt;- new_useful_thing()\n  expect_equal(foofy(useful_thing2, x = \"that\"), EXPECTED_FOOFY_OUTPUT)\n})\n\n¿Dónde debería definirse el asistente new_useful_thing()? Esto vuelve a lo que describimos en Sección 14.3. Los ayudantes de prueba se pueden definir debajo de R/, como cualquier otra utilidad interna de su paquete. Otra ubicación popular es en un archivo auxiliar de prueba, por ejemplo, tests/testthat/helper.R. Una característica clave de ambas opciones es que los asistentes están disponibles durante el mantenimiento interactivo a través de devtools::load_all().\nSi es complicado Y costoso crear una useful_thing, su función auxiliar podría incluso usar la memorización para evitar un nuevo cálculo innecesario. Una vez que tienes una ayuda como new_useful_thing(), a menudo descubres que tiene usos más allá de las pruebas, por ejemplo, detrás de escena en una viñeta. A veces incluso te das cuenta de que debes definirlo debajo de R/ y exportarlo y documentarlo, para que puedas usarlo libremente en documentación y pruebas.\n\n15.1.2 Crear (y destruir) una cosa_útil “local”\nSHasta ahora, nuestro ejemplo de useful_thing era un objeto R normal, que se limpia automáticamente al final de cada prueba. ¿Qué pasa si la creación de algo útil tiene un efecto secundario en el sistema de archivos local, en un recurso remoto, en las opciones de sesión de R, en las variables de entorno o similares? Entonces su función auxiliar debería crear una useful_thing y limpiarla después. En lugar de un simple constructor new_useful_thing(), escribirás una función personalizada al estilo de las funciones local_*() de withr:\n\nlocal_useful_thing &lt;- function(..., env = parent.frame()) {\n  # tu complicado código para crear algo útil va aquí\n  withr::defer(\n    # tu complicado código para limpiar después de algo útil va aquí\n    envir = env\n  )\n}\n\nÚselo en sus pruebas de esta manera:\n\ntest_that(\"foofy() does this\", {\n  useful_thing1 &lt;- local_useful_thing()\n  expect_equal(foofy(useful_thing1, x = \"this\"), EXPECTED_FOOFY_OUTPUT)\n})\n\ntest_that(\"foofy() does that\", {\n  useful_thing2 &lt;- local_useful_thing()\n  expect_equal(foofy(useful_thing2, x = \"that\"), EXPECTED_FOOFY_OUTPUT)\n})\n\n¿Dónde debería definirse el asistente local_useful_thing()? Se aplican todos los consejos dados anteriormente para new_useful_thing(): defínalo debajo de R/ o en un archivo auxiliar de prueba.\nPara obtener más información sobre cómo escribir ayudas personalizadas como local_useful_thing(), consulte la viñeta de testthat en dispositivos de prueba.\n\n15.1.3 Almacenar una cosa_útil concreta de forma persistente\nSi crear una useful_thing es costosa, en términos de tiempo o memoria, tal vez no necesites volver a crearla para cada ejecución de prueba. Puede crear useful_thing una vez, almacenarlo como un dispositivo de prueba estático y cargarlo en las pruebas que lo necesiten. Aquí hay un boceto de cómo podría verse esto:\n\ntest_that(\"foofy() does this\", {\n  useful_thing1 &lt;- readRDS(test_path(\"fixtures\", \"useful_thing1.rds\"))\n  expect_equal(foofy(useful_thing1, x = \"this\"), EXPECTED_FOOFY_OUTPUT)\n})\n\ntest_that(\"foofy() does that\", {\n  useful_thing2 &lt;- readRDS(test_path(\"fixtures\", \"useful_thing2.rds\"))\n  expect_equal(foofy(useful_thing2, x = \"that\"), EXPECTED_FOOFY_OUTPUT)\n})\n\nAhora podemos revisar una lista de archivos anterior, que abordaba exactamente este escenario:\n.\n├── ...\n└── tests\n    ├── testthat\n    │   ├── fixtures\n    │   │   ├── make-useful-things.R\n    │   │   ├── useful_thing1.rds\n    │   │   └── useful_thing2.rds\n    │   ├── helper.R\n    │   ├── setup.R\n    │   └── (all the test files)\n    └── testthat.R\nEsto muestra archivos de prueba estáticos almacenados en tests/testthat/fixtures/, pero también observe el script R complementario, make-useful-things.R. A partir del análisis de datos, todos sabemos que no existe un script que se ejecute solo una vez. El refinamiento y la iteración son inevitables. Esto también es válido para objetos de prueba como useful_thing1.rds. Recomendamos encarecidamente guardar el código R utilizado para crear los objetos de prueba, para que puedan volver a crearse según sea necesario.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Técnicas de prueba avanzadas</span>"
    ]
  },
  {
    "objectID": "testing-advanced.html#construyendo-sus-propias-herramientas-de-prueba",
    "href": "testing-advanced.html#construyendo-sus-propias-herramientas-de-prueba",
    "title": "15  Técnicas de prueba avanzadas",
    "section": "\n15.2 Construyendo sus propias herramientas de prueba",
    "text": "15.2 Construyendo sus propias herramientas de prueba\nVolvamos al tema de la duplicación en su código de prueba. Le recomendamos que tenga una mayor tolerancia a la repetición en el código de prueba, con el fin de hacer que sus pruebas sean obvias. Pero todavía hay un límite en cuanto a la cantidad de repetición que se puede tolerar. Hemos cubierto técnicas como cargar objetos estáticos con test_path(), escribir un constructor como new_useful_thing() o implementar un dispositivo de prueba como local_useful_thing(). Hay incluso más tipos de ayudas de prueba que pueden resultar útiles en determinadas situaciones.\n\n15.2.1 Ayudante definido dentro de una prueba\nConsidere esta prueba para la función str_trunc() en stringr:\n\n# de stringr (hipotéticamente)\ntest_that(\"truncations work for all sides\", {\n  expect_equal(\n    str_trunc(\"This string is moderately long\", width = 20, side = \"right\"),\n    \"This string is mo...\"\n  )\n  expect_equal(\n    str_trunc(\"This string is moderately long\", width = 20, side = \"left\"),\n    \"...s moderately long\"\n  )\n  expect_equal(\n    str_trunc(\"This string is moderately long\", width = 20, side = \"center\"),\n    \"This stri...ely long\"\n  )\n})\n\nHay mucha repetición aquí, lo que aumenta la posibilidad de errores de copiar y pegar y, en general, hace que los ojos se pongan vidriosos. A veces es bueno crear un asistente hiperlocal, dentro de la prueba. Así es como se ve realmente la prueba en stringr\n\n# de stringr (en realidad)\ntest_that(\"truncations work for all sides\", {\n\n  trunc &lt;- function(direction) str_trunc(\n    \"This string is moderately long\",\n    direction,\n    width = 20\n  )\n\n  expect_equal(trunc(\"right\"),   \"This string is mo...\")\n  expect_equal(trunc(\"left\"),    \"...s moderately long\")\n  expect_equal(trunc(\"center\"),  \"This stri...ely long\")\n})\n\nUn asistente hiperlocal como trunc() es particularmente útil cuando le permite encajar todos los negocios importantes para cada expectativa en una línea. Luego, sus expectativas se pueden leer casi como una tabla entre lo real y lo esperado, para un conjunto de casos de uso relacionados. Arriba, es muy fácil ver cómo cambia el resultado a medida que truncamos la entrada desde la derecha, la izquierda y el centro.\nTenga en cuenta que esta técnica debe utilizarse con extrema moderación. Un asistente como trunc() es otro lugar donde puedes introducir un error, por lo que es mejor mantener dichos asistentes extremadamente breves y simples.\n\n15.2.2 Expectativas personalizadas\nSi se considera necesario un ayudante más complicado, es un buen momento para reflexionar sobre por qué es así. Si es complicado ponerse en posición para probar una función, eso podría ser una señal de que también es complicado usar esa función. ¿Necesitas refactorizarlo? Si la función parece sólida, entonces probablemente necesite utilizar un asistente más formal, definido fuera de cualquier prueba individual, como se describió anteriormente.\nUn tipo específico de ayuda que quizás quieras crear es una expectativa personalizada. Aquí hay dos muy simples de usethis:\n\nexpect_usethis_error &lt;- function(...) {\n  expect_error(..., class = \"usethis_error\")\n}\n\nexpect_proj_file &lt;- function(...) {\n  expect_true(file_exists(proj_path(...)))\n}\n\nexpect_usethis_error() comprueba que un error tenga la clase \"usethis_error\". expect_proj_file() es un contenedor simple alrededor de file_exists() que busca el archivo en el proyecto actual. Son funciones muy simples, pero la gran cantidad de repeticiones y la expresividad de sus nombres las hacen sentir justificadas.\nEs algo complicado crear una expectativa personalizada adecuada, es decir, una que se comporte como las expectativas integradas en testthat. Lo remitimos a la viñeta Expectativas personalizadas si desea obtener más información al respecto.\nPor último, puede resultar útil saber qué prueba pone a disposición información específica cuando se está ejecutando:\n\n\nLa variable de entorno TESTTHAT está establecida en \"true\". testthat::is_testing() es un atajo:\n\nis_testing &lt;- function() {\n  Sys.getenv(\"TESTTHAT\")\n}\n\n\n\nEl paquete bajo prueba está disponible como la variable de entorno TESTTHAT_PKG y testthat::testing_package() es un acceso directo:\n\ntesting_package &lt;- function() {\n  Sys.getenv(\"TESTTHAT_PKG\")\n}\n\n\n\nEn algunas situaciones, es posible que desee explotar esta información sin depender del tiempo de ejecución de testthat. En ese caso, simplemente inserte la fuente de estas funciones directamente en su paquete.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Técnicas de prueba avanzadas</span>"
    ]
  },
  {
    "objectID": "testing-advanced.html#cuando-las-pruebas-se-vuelven-difíciles",
    "href": "testing-advanced.html#cuando-las-pruebas-se-vuelven-difíciles",
    "title": "15  Técnicas de prueba avanzadas",
    "section": "\n15.3 Cuando las pruebas se vuelven difíciles",
    "text": "15.3 Cuando las pruebas se vuelven difíciles\nA pesar de todas las técnicas que hemos cubierto hasta ahora, siguen existiendo situaciones en las que todavía resulta muy difícil escribir pruebas. En esta sección, revisamos más formas de lidiar con situaciones desafiantes:\n\nSaltarse una prueba en determinadas situaciones.\nBurlarse de un servicio externo.\nLidiar con los secretos\n\n\n15.3.1 Saltarse una prueba\nA veces es imposible realizar una prueba: es posible que no tenga conexión a Internet o que no tenga acceso a las credenciales necesarias. Desafortunadamente, otra razón probable se desprende de esta simple regla: cuantas más plataformas utilice para probar su código, más probable será que no pueda ejecutar todas sus pruebas, todo el tiempo. En resumen, hay ocasiones en las que, en lugar de reprobar, simplemente quieres saltarte una prueba.\n\n15.3.1.1 testthat::skip()\n\nAquí usamos testthat::skip() para escribir un skipper personalizado hipotético, skip_if_no_api():\n\nskip_if_no_api() &lt;- function() {\n  if (api_unavailable()) {\n    skip(\"API not available\")\n  }\n}\n\ntest_that(\"foo api returns bar when given baz\", {\n  skip_if_no_api()\n  ...\n})\n\nskip_if_no_api() es otro ejemplo más de ayuda de prueba y los consejos ya dados sobre dónde definirlo se aplican aquí también.\nLos skip() y los motivos asociados se informan en línea a medida que se ejecutan las pruebas y también se indican claramente en el resumen:\n\ndevtools::test()\n#&gt; ℹ Loading abcde\n#&gt; ℹ Testing abcde\n#&gt; ✔ | F W S  OK | Context\n#&gt; ✔ |         2 | blarg\n#&gt; ✔ |     1   2 | foofy\n#&gt; ────────────────────────────────────────────────────────────────────────────────\n#&gt; Skip (test-foofy.R:6:3): foo api returns bar when given baz\n#&gt; Reason: API not available\n#&gt; ────────────────────────────────────────────────────────────────────────────────\n#&gt; ✔ |         0 | yo                                                              \n#&gt; ══ Results ═════════════════════════════════════════════════════════════════════\n#&gt; ── Skipped tests  ──────────────────────────────────────────────────────────────\n#&gt; • API not available (1)\n#&gt; \n#&gt; [ FAIL 0 | WARN 0 | SKIP 1 | PASS 4 ]\n#&gt; \n#&gt; 🥳\n\nEs probable que aparezca algo como skip_if_no_api() muchas veces en su conjunto de pruebas. Esta es otra ocasión en la que resulta tentador SECAR las cosas, elevando skip() al nivel superior del archivo. Sin embargo, todavía nos inclinamos por llamar a skip_if_no_api() en cada prueba donde sea necesario.\n\n# we prefer this:\ntest_that(\"foo api returns bar when given baz\", {\n  skip_if_no_api()\n  ...\n})\n\ntest_that(\"foo api returns an errors when given qux\", {\n  skip_if_no_api()\n  ...\n})\n\n# Más allá de esto:\nskip_if_no_api()\n\ntest_that(\"foo api returns bar when given baz\", {...})\n\ntest_that(\"foo api returns an errors when given qux\", {...})\n\nDentro del ámbito del código de nivel superior en archivos de prueba, tener un skip() al principio de un archivo de prueba es una de las situaciones más benignas. Pero una vez que un archivo de prueba no cabe completamente en su pantalla, crea una conexión implícita pero fácil de pasar por alto entre skip() y las pruebas individuales.\n\n15.3.1.2 Funciones skip() incorporadas\nDe manera similar a las expectativas integradas de test, existe una familia de funciones skip() que anticipan algunas situaciones comunes. Estas funciones a menudo le liberan de la necesidad de escribir un patrón personalizado. A continuación se muestran algunos ejemplos de las funciones skip() más útiles:\n\ntest_that(\"foo api returns bar when given baz\", {\n  skip_if(api_unavailable(), \"API not available\")\n  ...\n})\ntest_that(\"foo api returns bar when given baz\", {\n  skip_if_not(api_available(), \"API not available\")\n  ...\n})\n\nskip_if_not_installed(\"sp\")\nskip_if_not_installed(\"stringi\", \"1.2.2\")\n\nskip_if_offline()\nskip_on_cran()\nskip_on_os(\"windows\")\n\n\n15.3.1.3 Peligros de saltar\nUn desafío con los saltos es que actualmente son completamente invisibles en CI: si automáticamente omite demasiadas pruebas, es fácil engañarse pensando que todas sus pruebas están pasando cuando en realidad simplemente se están omitiendo. En un mundo ideal, su CI/CD facilitaría ver cuántas pruebas se omiten y cómo eso cambia con el tiempo.\nEs una buena práctica profundizar periódicamente en los resultados de la “R CMD check”, especialmente en CI, y asegurarse de que los saltos sean los esperados. Pero esto tiende a ser algo que hay que aprender a través de la experiencia.\n\n15.3.2 Mocking\nLa práctica conocida como mocking ocurre cuando reemplazamos algo que es complicado, poco confiable o fuera de nuestro control por algo más simple, que está totalmente bajo nuestro control. Por lo general, se realiza mocking de un servicio externo, como una API REST, o una función que informa algo sobre el estado de la sesión, como si la sesión es interactiva.\nLa aplicación clásica de mocking se encuentra en el contexto de un paquete que incluye una API externa. Para probar sus funciones, técnicamente necesita realizar una llamada en vivo a esa API para obtener una respuesta, que luego procesa. Pero, ¿qué pasa si esa API requiere autenticación o si es algo inestable y tiene un tiempo de inactividad ocasional? Puede ser más productivo simplemente fingir llamar a la API pero, en cambio, probar el código bajo su control procesando una respuesta pregrabada de la API real.\nNuestro principal consejo sobre realizar mocking es evitarlo si puedes. Esto no es una acusación de mocking, sino simplemente una evaluación realista de que realizar mocking introduce una nueva complejidad que no siempre está justificada por los beneficios.\nDado que la mayoría de los paquetes de R no necesitan la realización de mocking, no lo cubrimos aquí. En su lugar, le indicaremos los paquetes que representan lo último sobre esto en R hoy en día:\n\nmockery: https://github.com/r-lib/mockery\n\nmockr: https://krlmlr.github.io/mockr/\n\nhttptest: https://enpiar.com/r/httptest/\n\nhttptest2: https://enpiar.com/httptest2/\n\nwebfakes: https://webfakes.r-lib.org\n\n\nTenga en cuenta también que, en el momento de escribir este artículo, parece probable que el paquete testthat reintroduzca algunas capacidades de mocking (después de haber salido previamente del negocio de mocking una vez). La versión v3.1.7 tiene dos nuevas funciones experimentales, testthat::with_mocked_bindings() y testthat::local_mocked_bindings().\n\n15.3.3 Secretos\nOtro desafío común para los paquetes que incluyen un servicio externo es la necesidad de administrar las credenciales. Específicamente, es probable que necesite proporcionar un conjunto de credenciales de prueba para probar completamente su paquete.\nNuestro principal consejo aquí es diseñar su paquete de modo que gran parte del mismo pueda probarse sin acceso en vivo y autenticado al servicio externo.\nPor supuesto, aún querrá poder probar su paquete con el servicio real que incluye, en entornos que admitan variables de entorno seguras. Dado que este también es un tema muy especializado, no entraremos en más detalles aquí. En su lugar, lo remitimos a la viñeta API de ajuste en el paquete httr2, que ofrece soporte sustancial para la gestión de secretos.",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Técnicas de prueba avanzadas</span>"
    ]
  },
  {
    "objectID": "testing-advanced.html#consideraciones-especiales-para-paquetes-cran",
    "href": "testing-advanced.html#consideraciones-especiales-para-paquetes-cran",
    "title": "15  Técnicas de prueba avanzadas",
    "section": "\n15.4 Consideraciones especiales para paquetes CRAN",
    "text": "15.4 Consideraciones especiales para paquetes CRAN\nCRAN ejecuta R CMD check en todos los paquetes aportados, tanto al momento del envío como de forma regular después de la aceptación. Esta verificación incluye, entre otras, la prueba que realiza las pruebas. Discutimos el desafío general de preparar su paquete para enfrentar todos los “sabores” de cheques de CRAN en Sección 22.4.1. Aquí nos centramos en consideraciones específicas de CRAN para su conjunto de pruebas.\nCuando un paquete entra en conflicto con la Política de repositorio de CRAN (https://cran.r-project.org/web/packages/policies.html), el conjunto de pruebas suele ser el culpable (aunque no siempre). Si su paquete está destinado a CRAN, esto debería influir en cómo escribe sus pruebas y cómo (o si) se ejecutarán en CRAN.\n\n15.4.1 Saltar una prueba\nSi una prueba específica simplemente no es apropiada para ser ejecutada por CRAN, incluya skip_on_cran() desde el principio.\n\ntest_that(\"some long-running thing works\", {\n  skip_on_cran()\n  # código de prueba que potencialmente puede tardar \"un tiempo\" en ejecutarse  \n})\n\nDebajo del capó, skip_on_cran() consulta la variable de entorno NOT_CRAN. Dicha prueba solo se ejecutará cuando NOT_CRAN se haya definido explícitamente como \"true\". Esta variable la establecen devtools y testthat, lo que permite que esas pruebas se ejecuten en entornos donde espera tener éxito (y donde puede tolerar y solucionar fallas ocasionales).\nEn particular, los flujos de trabajo de GitHub Actions que recomendamos en Sección 20.2.1 ejecutarán pruebas con NOT_CRAN = \"true\". Para ciertos tipos de funcionalidad, no existe una forma práctica de probarlas en CRAN y sus propias comprobaciones, en GitHub Actions o un servicio de integración continua equivalente, son su mejor método de control de calidad.\nIncluso hay casos raros en los que tiene sentido mantener las pruebas fuera de su paquete por completo. El equipo de tidymodels utiliza esta estrategia para pruebas de tipo integración de todo su ecosistema que serían imposibles de alojar dentro de un paquete CRAN individual.\n\n15.4.2 Velocidad\nSus pruebas deben ejecutarse relativamente rápido; idealmente, menos de un minuto en total. Utilice skip_on_cran() en una prueba que inevitablemente sea de larga duración.\n\n15.4.3 Reproducibilidad\nTenga cuidado al probar cosas que probablemente sean variables en las máquinas CRAN. Es arriesgado probar cuánto tiempo lleva algo (porque las máquinas CRAN a menudo están muy cargadas) o probar código paralelo (debido a que CRAN ejecuta múltiples pruebas de paquetes en paralelo, no siempre habrá múltiples núcleos disponibles). La precisión numérica también puede variar entre plataformas, así que use expect_equal() a menos que tenga una razón específica para usar expect_identical().\n\n15.4.4 Pruebas inestables\nDebido a la escala a la que CRAN verifica los paquetes, básicamente no hay margen para una prueba que es “simplemente inestable”, es decir, que a veces falla por razones incidentales. CRAN no procesa los resultados de las pruebas de su paquete como usted lo hace, donde puede inspeccionar cada falla y ejercer un juicio humano sobre qué tan preocupante es.\nProbablemente sea una buena idea eliminar las pruebas inestables, ¡sólo por tu propio bien! Pero si tiene pruebas valiosas y bien escritas que son propensas a fallas molestas ocasionales, definitivamente coloque skip_on_cran() al principio.\nEl ejemplo clásico es cualquier prueba que acceda a un sitio web o API web. Dado que cualquier recurso web en el mundo experimentará un tiempo de inactividad ocasional, es mejor no permitir que dichas pruebas se ejecuten en CRAN. La Política de repositorio de CRAN dice:\n\nLos paquetes que utilizan recursos de Internet deberían fallar elegantemente con un mensaje informativo si el recurso no está disponible o ha cambiado (y no dar aviso de verificación ni error).\n\nA menudo, hacer que tal falla sea “elegante” iría en contra del comportamiento que realmente desea en la práctica, es decir, querría que su usuario recibiera un error si su solicitud falla. Por eso suele ser más práctico probar dicha funcionalidad en otro lugar.\nRecuerde que las pruebas instantáneas (Capítulo 13), de forma predeterminada, también se omiten en CRAN. Normalmente se utilizan estas pruebas para controlar, por ejemplo, cómo se ven varios mensajes informativos. Pequeños cambios en el formato de los mensajes son algo sobre lo que desea recibir una alerta, pero no indican un defecto importante en su paquete. Esta es la motivación para el comportamiento predeterminado skip_on_cran() de las pruebas instantáneas.\nFinalmente, las pruebas inestables causan problemas a quienes mantienen sus dependencias. Cuando se actualizan los paquetes de los que depende, CRAN ejecuta R CMD check en todas las dependencias inversas, incluido su paquete. Si su paquete tiene pruebas inestables, su paquete puede ser la razón por la que otro paquete no pasa las comprobaciones entrantes de CRAN y puede retrasar su liberación.\n\n15.4.5 Higiene del sistema de archivos y procesos\nEn Sección 14.3.7, le instamos a que escriba únicamente en el directorio temporal de la sesión y que limpie lo que haya dejado usted mismo. Esta práctica hace que su conjunto de pruebas sea mucho más fácil de mantener y predecible. Para los paquetes que están (o aspiran a estar) en CRAN, esto es absolutamente necesario según la política del repositorio de CRAN:\n\nLos paquetes no deben escribirse en el espacio de archivos de inicio del usuario (incluidos los portapapeles), ni en ningún otro lugar del sistema de archivos aparte del directorio temporal de la sesión R (o durante la instalación en la ubicación señalada por TMPDIR: y dicho uso debe limpiarse). … Se pueden permitir excepciones limitadas en sesiones interactivas si el paquete obtiene la confirmación del usuario.\n\nDel mismo modo, debes esforzarte en ser higiénico con respecto a cualquier proceso que inicies:\n\nLos paquetes no deben iniciar software externo (como visores o navegadores de PDF) durante los ejemplos o pruebas a menos que esa instancia específica del software se cierre explícitamente después.\n\nAcceder al portapapeles es la tormenta perfecta que potencialmente entra en conflicto con ambas pautas, ya que el portapapeles se considera parte del espacio de archivos de inicio del usuario y, en Linux, puede iniciar un proceso externo (por ejemplo, xsel o xclip). Por lo tanto, es mejor desactivar cualquier funcionalidad del portapapeles en sus pruebas (y asegurarse de que, durante el uso auténtico, su usuario claramente opte por ello).",
    "crumbs": [
      "Probar",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Técnicas de prueba avanzadas</span>"
    ]
  },
  {
    "objectID": "man.html",
    "href": "man.html",
    "title": "16  Documentación de la función",
    "section": "",
    "text": "16.1 conceptos básicos de roxygen2\nEn este capítulo, aprenderá sobre la documentación de funciones, a la que los usuarios acceden con ?algunafunción o help(\"algunafunción\"). Base R proporciona una forma estándar de documentar un paquete donde cada función está documentada en un tema, un archivo .Rd (“documentación R”) en el directorio man/. Los archivos .Rd utilizan una sintaxis personalizada, basada libremente en LaTeX, y se pueden representar en HTML, texto sin formato o pdf, según sea necesario, para verlos en diferentes contextos.\nEn el ecosistema devtools, no editamos archivos .Rd directamente con nuestras propias manos. En su lugar, incluimos “comentarios de roxygen” con formato especial encima del código fuente para cada función1. Luego usamos el paquete roxygen2 para generar los archivos .Rd a partir de estos comentarios especiales2 . Hay algunas ventajas al usar roxygen2 :\nEn este capítulo nos centraremos en documentar funciones, pero las mismas ideas se aplican a documentar conjuntos de datos (Sección 7.1.2), clases, genéricos y paquetes. Puede obtener más información sobre esos temas importantes en vignette(\"rd-other\", package = \"roxygen2\").\nPara comenzar, analizaremos el flujo de trabajo básico de roxygen2 y analizaremos la estructura general de los comentarios de roxygen2, que están organizados en bloques y etiquetas. También destacamos las mayores ventajas de utilizar Markdown con roxygen2.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#conceptos-básicos-de-roxygen2",
    "href": "man.html#conceptos-básicos-de-roxygen2",
    "title": "16  Documentación de la función",
    "section": "",
    "text": "16.1.1 El flujo de trabajo de documentación\nA diferencia de testthat, no hay un movimiento de apertura obvio para declarar que vas a utilizar roxygen2 para la documentación. Esto se debe a que el uso de roxygen2 es puramente una cuestión de su flujo de trabajo de desarrollo. No tiene ningún efecto, por ejemplo, sobre cómo se comprueba o construye un paquete. Creemos que el enfoque de roxygen es la mejor manera de generar archivos .Rd, pero oficialmente R solo se preocupa por los archivos en sí, no por cómo surgieron.\nSu flujo de trabajo de documentación realmente comienza cuando comienza a agregar comentarios de roxygen encima de sus funciones. Las líneas de comentarios de Roxygen siempre comienzan con #', el # habitual para un comentario, seguido inmediatamente por una comilla simple ':\n\n#' Suma dos números\n#' \n#' @param x Un número.\n#' @param y Un número.\n#' @returns Un vector numéro.\n#' @examples\n#' add(1, 1)\n#' add(10, 1)\nadd &lt;- function(x, y) {\n  x + y\n}\n\n\n\n\n\n\n\nRStudio\n\n\n\nPor lo general, primero escribe su función y luego su documentación. Una vez que exista la definición de la función, coloque el cursor en algún lugar de ella y haga Código &gt; Insertar esqueleto de Roxygen para obtener una gran ventaja en el comentario de roxygen.\n\n\nUna vez que tenga al menos un comentario de roxygen, ejecute devtools::document() para generar (o actualizar) los archivos .Rd de su paquete3. En el fondo, esto finalmente se llama roxygen2::roxygenise(). El bloque roxygen anterior genera un archivo man/add.Rd que se ve así:\n% Generated by roxygen2: do not edit by hand\n% Please edit documentation in R/add.R\n\\name{add}\n\\alias{add}\n\\title{Suma dos números}\n\\usage{\nadd(x, y)\n}\n\\arguments{\n\\item{x}{Un número.}\n\n\\item{y}{Un número.}\n}\n\\value{\nUn vector numéro.\n}\n\\description{\nSuma dos números\n}\n\\examples{\nadd(1, 1)\nadd(10, 1)\n}\n\n\n\n\n\n\nRStudio\n\n\n\nTambién puede ejecutar devtools::document() con el método abreviado de teclado Ctrl/Cmd + Shift + D o mediante el menú o panel Construir.\n\n\nSi ha usado LaTeX antes, esto debería resultarle vagamente familiar ya que el formato .Rd se basa libremente en LaTeX. Si está interesado en el formato .Rd, puede leer más en Escribir extensiones R. Pero generalmente nunca necesitarás mirar archivos .Rd, excepto para enviarlos al repositorio Git de tu paquete.\n¿Cómo se corresponde este archivo .Rd con la documentación que ves en R? Cuando ejecuta ?add, help(\"add\") o example(\"add\"), R busca un archivo .Rd que contenga \\alias{add}. Luego analiza el archivo, lo convierte a HTML y lo muestra. Figura 16.1 muestra cómo se vería este tema de ayuda en RStudio:\n\n\n\n\n\n\n\nFigura 16.1: Tema de ayuda representado en HTML.\n\n\n\n\n\n\n\n\n\n\nR CMD check warning\n\n\n\nDebe documentar todas las funciones y conjuntos de datos exportados. De lo contrario, recibirá esta advertencia de R CMD check:\nW  checking for missing documentation entries (614ms)\n  Undocumented code objects:\n    ‘somefunction’\n  Undocumented data sets:\n    ‘somedata’\n  All user-level objects in a package should have documentation entries.\nPor el contrario, probablemente no desees documentar funciones no exportadas. Si desea utilizar comentarios de roxygen para la documentación interna, incluya la etiqueta @noRd para suprimir la creación del archivo .Rd.\n\n\nEste también es un buen momento para explicar algo que quizás hayas notado en tu archivo DESCRIPTION:\nRoxygen: list(markdown = TRUE)\ndevtools/usethis incluye esto de forma predeterminada al iniciar un archivo DESCRIPTION y le avisa a roxygen2 de que su paquete usa sintaxis de markdown en sus comentarios de roxygen.4\nEl proceso de búsqueda de ayuda predeterminado busca dentro de los paquetes instalados, por lo que para ver la documentación de su paquete durante el desarrollo, devtools anula las funciones de ayuda habituales con versiones modificadas que saben consultar el paquete fuente actual. Para activar estas anulaciones, necesitarás ejecutar devtools::load_all() al menos una vez. Si siente que sus ediciones en los comentarios de roxygen no están teniendo efecto, verifique que haya regenerado los archivos .Rd con devtools::document() y que haya cargado su paquete. Cuando llama a ?Función, debería ver “Representación de documentación de desarrollo …”.\nEn resumen, hay cuatro pasos en el flujo de trabajo básico de roxygen2:\n\nAgregue comentarios de roxygen2 a sus archivos .R.\nEjecute devtools::document() o presione Ctrl/Cmd + Shift + D para convertir los comentarios de roxygen2 en archivos .Rd.\nObtenga una vista previa de la documentación con ?función.\nEnjuague y repita hasta que la documentación tenga el aspecto deseado.\n\n16.1.2 comentarios, bloques y etiquetas de roxygen2\nAhora que comprende el flujo de trabajo básico, entraremos en más detalles sobre la sintaxis. Los comentarios de roxygen2 comienzan con #' y todos los comentarios de roxygen2 que preceden a una función se denominan colectivamente bloque. Los bloques se dividen en etiquetas, que se parecen a @tagName tagValue, y el contenido de una etiqueta se extiende desde el final del nombre de la etiqueta hasta el inicio de la siguiente etiqueta 5. Un bloque puede contener texto antes de la primera etiqueta que se denomina introducción. De forma predeterminada, cada bloque genera un único tema de documentación, es decir, un único archivo .Rd6 en el directorio man/.\nA lo largo de este capítulo, le mostraremos comentarios de roxygen2 de paquetes tidyverse reales, centrándonos en stringr, ya que las funciones allí tienden a ser bastante sencillas, lo que lleva a documentación comprensible con relativamente poco contexto. Adjuntamos stringr aquí para que sus funciones tengan un hipervínculo en el libro renderizado (más sobre esto en la sección Sección 16.1.3).\n\nlibrary(stringr)\n\nAquí hay un primer ejemplo simple: la documentación para str_unique().\n\n#' Remove duplicated strings\n#'\n#' `str_unique()` removes duplicated values, with optional control over\n#' how duplication is measured.\n#'\n#' @param string Input vector. Either a character vector, or something\n#'  coercible to one.\n#' @param ... Other options used to control matching behavior between duplicate\n#'   strings. Passed on to [stringi::stri_opts_collator()].\n#' @returns A character vector, usually shorter than `string`.\n#' @seealso [unique()], [stringi::stri_unique()] which this function wraps.\n#' @examples\n#' str_unique(c(\"a\", \"b\", \"c\", \"b\", \"a\"))\n#'\n#' # Use ... to pass additional arguments to stri_unique()\n#' str_unique(c(\"motley\", \"mötley\", \"pinguino\", \"pingüino\"))\n#' str_unique(c(\"motley\", \"mötley\", \"pinguino\", \"pingüino\"), strength = 1)\n#' @export\nstr_unique &lt;- function(string, ...) {\n  ...\n}\n\nAquí la introducción incluye el título (“Eliminar cadenas duplicadas”) y una descripción básica de lo que hace la función. La introducción va seguida de cinco etiquetas: dos @params, una @returns, una @seealso, una @examples y una @export.\nTenga en cuenta que el bloque tiene una longitud de línea intencional (generalmente la misma que se usa para el código R circundante) y la segunda línea y las siguientes de la etiqueta larga @param tienen sangría, lo que hace que todo el bloque sea más fácil de escanear. Puedes obtener más consejos de estilo de roxygen2 en la guía de estilo de tidyverse.\n\n\n\n\n\n\nRStudio\n\n\n\nPuede resultar molesto administrar manualmente la longitud de línea de los comentarios de roxygen, así que asegúrese de probar Code &gt; Reflow Comment (Ctrl/Cmd+Shift+/).\n\n\nTenga en cuenta también que el orden en que aparecen las etiquetas en sus comentarios de roxygen (o incluso en archivos .Rd escritos a mano) no dicta el orden en la documentación representada. El orden de presentación se determina mediante herramientas dentro de la base R.\nLas siguientes secciones profundizan en las etiquetas más importantes. Comenzamos con la introducción, que proporciona el título, la descripción y los detalles. Luego cubrimos las entradas (los argumentos de la función), las salidas (el valor de retorno) y los ejemplos. A continuación, analizamos enlaces y referencias cruzadas y terminamos con técnicas para compartir documentación entre temas.\n\n16.1.3 Funciones claves de markdown\nEn su mayor parte, el conocimiento general de Markdown y R Markdown es suficiente para aprovechar el Markdown en roxygen2. Pero hay algunas piezas de sintaxis que son tan importantes que queremos resaltarlas aquí. Los verá en muchos de los ejemplos de este capítulo.\nComillas invertidas para código en línea: utilice comillas invertidas para formatear un fragmento de texto como código, es decir, en una fuente de ancho fijo. Ejemplo:\n\n#' I like `thisfunction()`, because it's great.\n\nCorchetes para una función con enlace automático: incluya texto como alguna función() y algún paquete::alguna función() entre corchetes para obtener un enlace automático a la documentación de esa función. Asegúrese de incluir los paréntesis finales, porque tiene un buen estilo y hace que la función se formatee como código, es decir, no es necesario agregar comillas invertidas. Ejemplo:\n\n#' Es obvio que `thisfunction()` es mejor que [otherpkg::otherfunction()]\n#' o incluso nuestra propia [función anterior()].\n\nViñetas: si hace referencia a una viñeta con una llamada en línea a vignette(\"some-topic\"), tiene un doble propósito. Primero, este es literalmente el código R que ejecutaría para ver una viñeta localmente. ¡Pero espera hay mas! En muchos contextos renderizados, esto se convierte automáticamente en un hipervínculo a esa misma viñeta en un sitio web pkgdown. Aquí lo usamos para vincular algunas viñetas muy relevantes7:\n\nvignette(\"rd-formatting\", package = \"roxygen2\")\nvignette(\"reuse\", package = \"roxygen2\")\nvignette(\"linking\", package = \"pkgdown\")\n\nListas: Las listas con viñetas rompen el temido “muro de texto” y pueden hacer que su documentación sea más fácil de escanear. Puedes usarlos en la descripción de la función o de un argumento y también para el valor de retorno. No es necesario incluir una línea en blanco antes de la lista, pero eso también está permitido.\n\n#' Mejores características de `thisfunction()`:\n#' * Huele bien\n#' * Tiene buena vibra",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#título-descripción-detalles",
    "href": "man.html#título-descripción-detalles",
    "title": "16  Documentación de la función",
    "section": "\n16.2 Título, descripción, detalles",
    "text": "16.2 Título, descripción, detalles\nLa introducción proporciona un título, una descripción y, opcionalmente, detalles de la función. Si bien es posible utilizar etiquetas explícitas en la introducción, normalmente utilizamos etiquetas implícitas cuando es posible:\n\nEl título está tomado de la primera frase. Debe escribirse en mayúsculas y minúsculas, no terminar en punto y estar seguido de una línea en blanco. El título se muestra en varios índices de funciones (por ejemplo, help(package = \"algúnpaquete\")) y es lo que el usuario normalmente verá cuando explore múltiples funciones.\nLa descripción está tomada del siguiente párrafo. Se muestra en la parte superior de la documentación y debe describir brevemente las características más importantes de la función.\nDetalles adicionales son cualquier cosa después de la descripción. Los detalles son opcionales, pero pueden tener cualquier longitud, por lo que son útiles si desea profundizar en algún aspecto importante de la función. Tenga en cuenta que, aunque los detalles aparecen justo después de la descripción en la introducción, aparecen mucho más tarde en la documentación renderizada.\n\nLas siguientes secciones describen cada componente con más detalle y luego analizan algunas etiquetas relacionadas útiles.\n\n16.2.1 Título\nAl escribir el título, es útil pensar en cómo aparecerá en el índice de referencia. Cuando un usuario hojea el índice, ¿cómo sabrá qué funciones resolverán su problema actual? Esto requiere pensar en qué tienen en común sus funciones (que no es necesario repetir en cada título) y qué es exclusivo de esa función (que debe resaltarse en el título).\nCuando escribimos este capítulo, encontramos que los títulos de las funciones de stringr eran algo decepcionantes. Pero proporcionan un útil estudio de caso negativo:\n\n\nstr_detect(): Detecta la presencia o ausencia de un patrón en una cadena\n\nstr_extract(): Extrae patrones coincidentes de una cadena\n\nstr_locate(): Localiza la posición de los patrones en una cadena\n\nstr_match(): Extrae grupos coincidentes de una cadena\n\nHay mucha repetición (“pattern”, “from a string”) y el verbo usado para el nombre de la función se repite en el título, por lo que si aún no comprende la función, es poco probable que el título le ayude mucho. ¡Esperamos haber mejorado esos títulos cuando leas esto!\nEn cambio, estos títulos de dplyr son mucho mejores8:\n\n\nmutate(): Crear, modificar y eliminar columnas\n\nsummarise(): Resume cada grupo en una fila\n\nfiltro(): Mantiene las filas que coinciden con una condición\n\nselect(): Mantener o eliminar columnas usando sus nombres y tipos\n\narrange(): Ordena filas usando valores de columna\n\nAquí intentamos describir de manera sucinta lo que hace la función, asegurándonos de describir si afecta a filas, columnas o grupos. Hacemos nuestro mejor esfuerzo para usar sinónimos, en lugar de repetir el nombre de la función, para darle a la gente otra oportunidad de comprender la intención de la función.\n\n16.2.2 Descripción\nEl propósito de la descripción es resumir el objetivo de la función, generalmente en un solo párrafo. Esto puede ser un desafío para funciones simples, porque puede parecer que simplemente estás repitiendo el título de la función. Si puedes, intenta encontrar una redacción ligeramente diferente. Está bien si esto te parece un poco repetitivo; A menudo resulta útil para los usuarios ver lo mismo expresado de dos maneras diferentes. Es un poco de trabajo extra, pero el esfuerzo extra a menudo vale la pena. Aquí está la descripción de str_detect():\n\n#' Detect the presence/absence of a match\n#'\n#' `str_detect()` returns a logical vector with `TRUE` for each element of\n#' `string` that matches `pattern` and `FALSE` otherwise. It's equivalent to\n#' `grepl(pattern, string)`.\n\nSi desea más de un párrafo, debe usar una etiqueta @description explícita para evitar que el segundo párrafo (y los siguientes) se conviertan en @details. Aquí hay una @description de dos párrafos de str_view():\n\n#' View strings and matches\n#'\n#' @description\n#' `str_view()` is used to print the underlying representation of a string and\n#' to see how a `pattern` matches.\n#'\n#' Matches are surrounded by `&lt;&gt;` and unusual whitespace (i.e. all whitespace\n#' apart from `\" \"` and `\"\\n\"`) are surrounded by `{}` and escaped. Where\n#' possible, matches and unusual whitespace are coloured blue and `NA`s red.\n\nAquí hay otro ejemplo de str_like(), que tiene una lista con viñetas en @description:\n\n#' Detect a pattern in the same way as `SQL`'s `LIKE` operator\n#'\n#' @description\n#' `str_like()` follows the conventions of the SQL `LIKE` operator:\n#'\n#' * Must match the entire string.\n#' * `_` matches a single character (like `.`).\n#' * `%` matches any number of characters (like `.*`).\n#' * `\\%` and `\\_` match literal `%` and `_`.\n#' * The match is case insensitive by default.\n\nBásicamente, si vas a incluir una línea vacía en tu descripción, necesitarás usar una etiqueta @description explícita.\nFinalmente, a menudo es particularmente difícil escribir una buena descripción si acabas de escribir la función, porque el propósito a menudo parece muy obvio. Haz tu mejor esfuerzo y vuelve más tarde, cuando hayas olvidado exactamente qué hace la función. Una vez que haya vuelto a derivar lo que hace la función, podrá escribir una mejor descripción.\n\n16.2.3 Detalles\nLos @details son solo cualquier detalle o explicación adicional que crea que su función necesita. La mayoría de las funciones no necesitan detalles, pero algunas funciones necesitan muchos. Si tiene mucha información que transmitir, es una buena idea utilizar títulos de markdown informativos para dividir los detalles en secciones manejables9. Aquí hay un ejemplo de dplyr::mutate(). Hemos omitido algunos de los detalles para que este ejemplo sea breve, pero aún así deberías tener una idea de cómo usamos los títulos para dividir el contenido en partes que se pueden leer:\n\n#' Create, modify, and delete columns\n#'\n#' `mutate()` creates new columns that are functions of existing variables.\n#' It can also modify (if the name is the same as an existing\n#' column) and delete columns (by setting their value to `NULL`).\n#'\n#' @section Useful mutate functions:\n#'\n#' * [`+`], [`-`], [log()], etc., for their usual mathematical meanings\n#' \n#' ...\n#'\n#' @section Grouped tibbles:\n#'\n#' Because mutating expressions are computed within groups, they may\n#' yield different results on grouped tibbles. This will be the case\n#' as soon as an aggregating, lagging, or ranking function is\n#' involved. Compare this ungrouped mutate:\n#' \n#' ...\n\nEste es un buen momento para recordarnos que, aunque un título como “Funciones de mutación útiles” en el ejemplo anterior aparece inmediatamente después de la descripción en el bloque roxygen, el contenido aparece mucho más tarde en la documentación renderizada. Los detalles (ya sea que usen encabezados de sección o no) aparecen después del uso de la función, los argumentos y el valor de retorno.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#argumentos",
    "href": "man.html#argumentos",
    "title": "16  Documentación de la función",
    "section": "\n16.3 Argumentos",
    "text": "16.3 Argumentos\nPara la mayoría de las funciones, la mayor parte de su trabajo se destinará a documentar cómo cada argumento afecta el resultado de la función. Para este propósito, usará @param (abreviatura de parámetro, sinónimo de argumento) seguido del nombre del argumento y una descripción de su acción.\nLa máxima prioridad es proporcionar un resumen sucinto de las entradas permitidas y lo que hace el parámetro. Por ejemplo, así es como str_detect() documenta el string:\n\n#' @param string Input vector. Either a character vector, or something\n#'  coercible to one.\n\nY aquí están tres de los argumentos de str_flatten():\n\n#' @param collapse String to insert between each piece. Defaults to `\"\"`.\n#' @param last Optional string to use in place of the final separator.\n#' @param na.rm Remove missing values? If `FALSE` (the default), the result \n#'   will be `NA` if any element of `string` is `NA`.\n\nTenga en cuenta que @param collapse y @param na.rm describen sus argumentos predeterminados. Esta suele ser una buena práctica porque el uso de la función (que muestra los valores predeterminados) y la descripción del argumento suelen estar bastante separados en la documentación representada. Pero hay desventajas. La principal es que esta duplicación significa que necesitarás realizar actualizaciones en dos lugares si cambias el valor predeterminado; Creemos que esta pequeña cantidad de trabajo extra vale la pena para facilitar la vida del usuario.\nSi un argumento tiene un conjunto fijo de posibles parámetros, debes enumerarlos. Si son simples, puedes enumerarlos en una oración, como en str_trim():\n\n#' @param side Side on which to remove whitespace: `\"left\"`, `\"right\"`, or\n#'   `\"both\"` (the default).\n\nSi necesitan más explicaciones, puedes usar una lista con viñetas, como en str_wrap():\n\n#' @param whitespace_only A boolean.\n#'   * `TRUE` (the default): wrapping will only occur at whitespace.\n#'   * `FALSE`: can break on any non-word character (e.g. `/`, `-`).\n\nLa documentación para la mayoría de los argumentos será relativamente breve, a menudo una o dos oraciones. Pero debes ocupar todo el espacio que necesites y en breve verás algunos ejemplos de documentos con argumentos de varios párrafos.\n\n16.3.1 Múltiples argumentos\nSi el comportamiento de varios argumentos está estrechamente relacionado, puede documentarlos juntos separando los nombres con comas (sin espacios). Por ejemplo, x e y son intercambiables en str_equal(), por lo que se documentan juntos:\n\n#' @param x,y Un par de vectores de caracteres.\n\nEn str_sub(), start y end definen el rango de caracteres a reemplazar. Pero en lugar de proporcionar ambos, puede usar simplemente start si pasa una matriz de dos columnas. Por eso tiene sentido documentarlos juntos:\n\n#' @param start,end A pair of integer vectors defining the range of characters\n#'   to extract (inclusive).\n#'\n#'   Alternatively, instead of a pair of vectors, you can pass a matrix to\n#'   `start`. The matrix should have two columns, either labelled `start`\n#'   and `end`, or `start` and `length`.\n\nEn str_wrap(), indent y exdent definen la sangría para la primera línea y todas las líneas posteriores, respectivamente:\n\n#' @param indent,exdent A non-negative integer giving the indent for the\n#'   first line (`indent`) and all subsequent lines (`exdent`).\n\n\n16.3.2 Heredar argumentos\nSi su paquete contiene muchas funciones estrechamente relacionadas, es común que tengan argumentos que compartan el mismo nombre y significado. Sería molesto y propenso a errores copiar y pegar la misma documentación @param en cada función, por lo que roxygen2 proporciona @inheritParams que le permite heredar documentación de argumentos de otra función, posiblemente incluso en otro paquete.\nstringr usa @inheritParams ampliamente porque la mayoría de las funciones tienen argumentos string y pattern. La documentación detallada y definitiva pertenece a str_detect():\n\n#' @param string Input vector. Either a character vector, or something\n#'  coercible to one.\n#' @param pattern Pattern to look for.\n#'\n#'   The default interpretation is a regular expression, as described in\n#'   `vignette(\"regular-expressions\")`. Use [regex()] for finer control of the\n#'   matching behaviour.\n#'\n#'   Match a fixed string (i.e. by comparing only bytes), using\n#'   [fixed()]. This is fast, but approximate. Generally,\n#'   for matching human text, you'll want [coll()] which\n#'   respects character matching rules for the specified locale.\n#'\n#'   Match character, word, line and sentence boundaries with\n#'   [boundary()]. An empty pattern, \"\", is equivalent to\n#'   `boundary(\"character\")`.\n\nLuego, las otras funciones stringr usan @inheritParams str_detect para obtener esta documentación detallada para string y pattern sin tener que duplicar ese texto.\n@inheritParams solo hereda documentos para los argumentos que la función realmente usa y que aún no están documentados, por lo que puedes documentar algunos argumentos localmente y heredar otros. str_match() usa esto para heredar la documentación estándar de str_detect() para el argumento string, mientras proporciona su propia documentación especializada para pattern:\n\n#' @inheritParams str_detect\n#' @param pattern Unlike other stringr functions, `str_match()` only supports\n#'   regular expressions, as described `vignette(\"regular-expressions\")`. \n#'   The pattern should contain at least one capturing group.\n\nAhora que hemos analizado los valores predeterminados y la herencia, podemos plantear un dilema más. A veces existe tensión entre brindar información detallada sobre un argumento (valores aceptables, valor predeterminado, cómo se usa el argumento, etc.) y hacer que la documentación se pueda reutilizar en otras funciones (que pueden diferir en algunos detalles). Esto puede motivarlo a evaluar si realmente vale la pena que funciones relacionadas manejen la misma entrada de diferentes maneras o si la estandarización sería beneficiosa.\nPuede heredar documentación de una función en otro paquete usando la notación estándar ::, es decir, @inheritParams anotherpackage::function. Esto introduce una pequeña molestia: ahora la documentación de su paquete ya no es independiente y la versión de “otro paquete” puede afectar los documentos generados. Tenga cuidado con las diferencias falsas introducidas por los contribuyentes que ejecutan devtools::document() con una versión instalada diferente del paquete heredado.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#sec-man-returns",
    "href": "man.html#sec-man-returns",
    "title": "16  Documentación de la función",
    "section": "\n16.4 Valor de retorno",
    "text": "16.4 Valor de retorno\nLa salida de una función es tan importante como sus entradas. Documentar el resultado es el trabajo de la etiqueta @returns10. Aquí la prioridad es describir la “forma” general del resultado, es decir, qué tipo de objeto es y sus dimensiones (si eso tiene sentido). Por ejemplo, si su función devuelve un vector, puede describir su tipo y longitud, o si su función devuelve un marco de datos, puede describir los nombres y tipos de las columnas y el número esperado de filas.\nLa documentación @returns para funciones en stringr es sencilla porque casi todas las funciones devuelven algún tipo de vector con la misma longitud que una de las entradas. Por ejemplo, así es como str_like() describe su salida:\n\n#' @returns A logical vector the same length as `string`.\n\nUn caso más complicado es la documentación conjunta de str_locate() y str_locate_all()11. str_locate() devuelve una matriz de números enteros y str_locate_all() devuelve una lista de matrices, por lo que el texto necesita describir lo que determina las filas y columnas.\n\n#' @returns\n#' * `str_locate()` returns an integer matrix with two columns and\n#'   one row for each element of `string`. The first column, `start`,\n#'   gives the position at the start of the match, and the second column, `end`,\n#'   gives the position of the end.\n#'\n#'* `str_locate_all()` returns a list of integer matrices with the same\n#'   length as `string`/`pattern`. The matrices have columns `start` and `end`\n#'   as above, and one row for each match.\n#' @seealso\n#'   [str_extract()] for a convenient way of extracting matches,\n#'   [stringi::stri_locate()] for the underlying implementation.\n\nEn otros casos, puede ser más fácil descubrir qué resaltar pensando en el conjunto de funciones y en qué se diferencian. Por ejemplo, la mayoría de las funciones de dplyr devuelven un marco de datos, por lo que decir simplemente @returns Un marco de datos no es muy útil. En cambio, intentamos identificar exactamente qué hace que cada función sea diferente. Decidimos que tiene sentido describir cada función en términos de cómo afecta las filas, las columnas, los grupos y los atributos. Por ejemplo, esto describe el valor de retorno de dplyr::filter():\n\n#' @returns\n#' An object of the same type as `.data`. The output has the following properties:\n#'\n#' * Rows are a subset of the input, but appear in the same order.\n#' * Columns are not modified.\n#' * The number of groups may be reduced (if `.preserve` is not `TRUE`).\n#' * Data frame attributes are preserved.\n\n@returns también es un buen lugar para describir cualquier advertencia o error importante que el usuario pueda ver. Por ejemplo, readr::read_csv() menciona lo que sucede si hay algún problema de análisis:\n\n#' @returns A [tibble()]. If there are parsing problems, a warning will alert you.\n#'   You can retrieve the full details by calling [problems()] on your dataset.\n\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nPara su envío inicial de CRAN, todas las funciones deben documentar su valor de retorno. Si bien es posible que esto no se analice en presentaciones posteriores, sigue siendo una buena práctica. Actualmente no hay forma de verificar que haya documentado el valor de retorno de cada función (estamos trabajando en ello) y es por eso que Notarás que algunas funciones de tidyverse carecen de documentación de salida. Pero ciertamente aspiramos a proporcionar esta información en todos los ámbitos.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#sec-man-examples",
    "href": "man.html#sec-man-examples",
    "title": "16  Documentación de la función",
    "section": "\n16.5 Ejemplos",
    "text": "16.5 Ejemplos\nDescribir lo que hace una función es genial, pero mostrar cómo funciona es aún mejor. Esa es la función de la etiqueta @examples, que utiliza código R ejecutable para demostrar lo que puede hacer una función. A diferencia de otras partes de la documentación donde nos hemos centrado principalmente en lo que debes escribir, aquí daremos brevemente algunos consejos de contenido y luego nos centraremos principalmente en las mecánicas.\nEl principal dilema con los ejemplos es que debes cumplir conjuntamente dos requisitos:\n\nSu código de ejemplo debe ser legible y realista. Algunos ejemplos son la documentación que usted proporciona para el beneficio del usuario, es decir, un ser humano real, que trabaja interactivamente, tratando de realizar su trabajo real con su paquete.\nSu código de ejemplo debe ejecutarse sin errores y sin efectos secundarios en muchos contextos no interactivos sobre los cuales tiene control limitado o nulo, como cuando CRAN ejecuta R CMD check o cuando el sitio web de su paquete se crea a través de GitHub Actions.\n\nResulta que a menudo existe tensión entre estos objetivos y necesitará encontrar una manera de hacer que sus ejemplos sean lo más útiles posible para los usuarios, y al mismo tiempo satisfacer los requisitos de CRAN (si ese es su objetivo) u otra infraestructura automatizada.\nLa mecánica de los ejemplos es compleja porque nunca deben producir errores y se ejecutan en cuatro situaciones diferentes:\n\nUtilizando interactivamente la función ejemplo().\nDurante R CMD check su computadora u otra computadora que controle (por ejemplo, en GitHub Actions).\nDurante R CMD check ejecutada por CRAN.\nCuando se está creando su sitio web pkgdown, a menudo a través de GitHub Actions o similar.\n\nDespués de discutir qué poner en sus ejemplos, hablaremos sobre cómo mantener sus ejemplos autónomos, cómo mostrar errores si es necesario, manejar dependencias, ejecutar ejemplos condicionalmente y alternativas a la etiqueta @examples para incluir código de ejemplo.\n\n\n\n\n\n\nRStudio\n\n\n\nAl preparar scripts .R o informes .Rmd/.qmd, es útil usar Ctrl/Cmd + Enter o el botón Ejecutar para enviar una línea de código R a la consola para su ejecución. Afortunadamente, puedes usar el mismo flujo de trabajo para ejecutar y desarrollar los @examples en tus comentarios de roxygen. Recuerde hacer devtools::load_all() con frecuencia para permanecer sincronizado con el código fuente del paquete.\n\n\n\n16.5.1 Contenido\nUtilice ejemplos para mostrar primero el funcionamiento básico de la función y luego resaltar las propiedades particularmente importantes. Por ejemplo, str_detect() comienza mostrando algunas variaciones simples y luego resalta una característica que es fácil pasar por alto: además de pasar un vector de cadenas y un patrón, también puedes pasar una cadena y un vector de patrones.\n\n#' @examples\n#' fruit &lt;- c(\"apple\", \"banana\", \"pear\", \"pineapple\")\n#' str_detect(fruit, \"a\")\n#' str_detect(fruit, \"^a\")\n#' str_detect(fruit, \"a$\")\n#' \n#' # Also vectorised over pattern\n#' str_detect(\"aecfg\", letters)\n\nIntente concentrarse en las características más importantes sin meterse en los detalles de cada caso extremo: si hace que los ejemplos sean demasiado largos, al usuario le resultará difícil encontrar la aplicación clave que está buscando. Si te encuentras escribiendo ejemplos muy extensos, puede ser una señal de que deberías escribir una viñeta.\nNo existen formas formales de dividir los ejemplos en secciones, pero puede utilizar comentarios de sección que utilicen muchos --- para crear un desglose visual. Aquí hay un ejemplo de tidyr::chop():\n\n#' @examples\n#' # Chop ----------------------------------------------------------------------\n#' df &lt;- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)\n#' # Note that we get one row of output for each unique combination of\n#' # non-chopped variables\n#' df %&gt;% chop(c(y, z))\n#' # cf nest\n#' df %&gt;% nest(data = c(y, z))\n#'\n#' # Unchop --------------------------------------------------------------------\n#' df &lt;- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))\n#' df %&gt;% unchop(y)\n#' df %&gt;% unchop(y, keep_empty = TRUE)\n\nEsfuércese por mantener los ejemplos centrados en la función específica que está documentando. Si puede expresar su punto con un conjunto de datos integrado familiar, como mtcars, hágalo. Si necesita realizar muchas configuraciones para crear un conjunto de datos u objeto para usar en el ejemplo, puede ser una señal de que necesita crear un conjunto de datos de paquete o incluso una función auxiliar. Consulte Capítulo 7, Sección 7.3.2 y Sección 15.1.1 para obtener ideas. Facilitar la escritura (y lectura) de ejemplos mejorará enormemente la calidad de su documentación.\nAdemás, recuerde que los ejemplos no son pruebas. Los ejemplos deben centrarse en el uso auténtico y típico para el que ha diseñado y que desea fomentar. El conjunto de pruebas es el lugar más apropiado para ejercitar exhaustivamente todos los argumentos y explorar casos extremos extraños y patológicos.\n\n16.5.2 Deja el mundo como lo encontraste\nSus ejemplos deben ser autónomos. Por ejemplo, esto significa:\n\nSi modifica options(), restablezcalas al final del ejemplo.\nSi crea un archivo, créelo en algún lugar de tempdir() y asegúrese de eliminarlo al final del ejemplo.\nNo cambie el directorio de trabajo.\nNo escribir en el portapapeles (a menos que un usuario esté presente para dar algún tipo de consentimiento).\n\nEsto se superpone mucho con nuestras recomendaciones para pruebas (consulte la sección Sección 14.2.2) e incluso con las funciones de R en su paquete (consulte la sección Sección 6.5). Sin embargo, debido a la forma en que se ejecutan los ejemplos durante la “verificación R CMD”, las herramientas disponibles para hacer que los ejemplos sean autónomos son mucho más limitadas. Desafortunadamente, no puedes usar el paquete withr o incluso on.exit() para programar una limpieza, como restaurar opciones o eliminar un archivo. En su lugar, deberás hacerlo a mano. Si puede evitar hacer algo que luego debe deshacerse, esa es la mejor manera de hacerlo y esto es especialmente cierto en el caso de los ejemplos.\nEstas restricciones a menudo están en tensión con una buena documentación, si estás tratando de documentar una función que de alguna manera cambia el estado del mundo. Por ejemplo, tienes que “mostrar tu trabajo”, es decir, todo tu código, lo que significa que tus usuarios verán toda la configuración y el desmontaje, incluso si no es típico de un uso auténtico. Si le resulta difícil seguir las reglas, esta podría ser otra señal para cambiar a una viñeta (consulte Capítulo 17).\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nMuchas de estas restricciones también se mencionan en la [política del repositorio de CRAN] (https://cran.r-project.org/web/packages/policies.html), que debe cumplir al realizar envíos a CRAN. Utilice buscar en la página para localizar “malicioso o antisocial” y ver los detalles.\n\n\nAdemás, desea que sus ejemplos envíen al usuario a una caminata corta, no a una caminata larga. Los ejemplos deben ejecutarse relativamente rápido para que los usuarios puedan ver rápidamente los resultados, no lleva mucho tiempo crear su sitio web, las verificaciones automatizadas se realizan rápidamente y no consume recursos informáticos cuando se envían a CRAN.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nTodos los ejemplos deben ejecutarse en menos de 10 minutos.\n\n\n\n16.5.3 Errores\nSus ejemplos no pueden arrojar ningún error, así que no incluya código defectuoso que pueda fallar por razones fuera de su control. En particular, es mejor evitar el acceso a sitios web, porque la R CMD check fallará cada vez que el sitio web no funcione.\n¿Qué puede hacer si desea incluir código que cause un error con fines didácticos? Hay dos opciones básicas:\n\n\nPuedes ajustar el código en try() para que se muestre el error, pero no detenga la ejecución de los ejemplos. Por ejemplo, dplyr::bind_cols() usa try() para mostrarle lo que sucede si intenta vincular dos marcos de datos con diferentes números de filas:\n\n#' @examples\n#' ...\n#' # Row sizes must be compatible when column-binding\n#' try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))\n\n\n\nPuedes ajustar el código en \\dontrun{}12, de modo que nunca se ejecute mediante example(). El ejemplo anterior se vería así si usara \\dontrun{} en lugar de try().\n\n#' # Row sizes must be compatible when column-binding\n#' \\dontrun{\n#' bind_cols(tibble(x = 1:3), tibble(y = 1:2)))\n#' }\n\n\n\nGeneralmente recomendamos usar try() para que el lector pueda ver un ejemplo del error en acción.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nPara el envío CRAN inicial de su paquete, todas las funciones deben tener al menos un ejemplo y el código de ejemplo no puede estar incluido dentro de \\dontrun{}. Si el código solo se puede ejecutar bajo condiciones específicas, utilice las técnicas siguientes para expresar esas condiciones previas.\n\n\n\n16.5.4 Dependencias y ejecución condicional\nUna fuente adicional de errores en los ejemplos es el uso de dependencias externas: en sus ejemplos sólo puede usar paquetes de los que su paquete depende formalmente (es decir, que aparecen en Imports o Sugests). Además, el código de ejemplo se ejecuta en el entorno del usuario, no en el entorno del paquete, por lo que tendrás que adjuntar explícitamente la dependencia con library() o hacer referencia a cada función con ::. Por ejemplo, dbplyr es un paquete de extensión dplyr, por lo que todos sus ejemplos comienzan con library(dplyr):\n\n#' @examples\n#' library(dplyr)\n#' df &lt;- data.frame(x = 1, y = 2)\n#'\n#' df_sqlite &lt;- tbl_lazy(df, con = simulate_sqlite())\n#' df_sqlite %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()\n\nEn el pasado, recomendábamos usar únicamente código de paquetes sugeridos dentro de un bloque como este:\n\n#' @examples\n#' if (requireNamespace(\"suggestedpackage\", quietly = TRUE)) { \n#'   # some example code\n#' }\n\nYa no creemos que ese enfoque sea una buena idea porque:\n\nNuestra política es esperar que los paquetes sugeridos se instalen al ejecutar R CMD check13 y esto informa lo que hacemos en ejemplos, pruebas y viñetas.\nEl coste de poner código de ejemplo dentro de {… } es alto: ya no se pueden ver resultados intermedios, como cuando los ejemplos se muestran en el sitio web del paquete. El coste de no instalar un paquete es bajo: los usuarios normalmente pueden reconocer el error asociado y resolverlo ellos mismos, es decir, instalando el paquete que falta.\n\nEn otros casos, su código de ejemplo puede depender de algo más que un paquete. Por ejemplo, si sus ejemplos se refieren a una API web, probablemente solo desee ejecutarlos para un usuario autenticado y nunca desee que dicho código se ejecute en CRAN. En este caso, realmente necesitas una ejecución condicional. La solución básica es expresar esto explícitamente:\n\n#' @examples\n#' if (some_condition()) {\n#'   # some example code\n#' }\n\nLa condición podría ser bastante general, como interactive(), o muy específica, como una función de predicado personalizada proporcionada por su paquete. Pero este uso de if() todavía sufre el inconveniente resaltado anteriormente, donde los ejemplos renderizados no muestran claramente lo que sucede dentro del bloque {... }.\nLa etiqueta @examplesIf es una excelente alternativa a @examples en este caso:\n\n#' @examplesIf some_condition()\n#' some_other_function()\n#' some_more_functions()\n\nEsto se parece casi al fragmento de arriba, pero tiene varias ventajas:\n\nLos usuarios en realidad no verán la maquinaria if() {... } cuando lean su documentación desde R o en un sitio web de pkgdown. Los usuarios sólo ven código realista.\nEl código de ejemplo se muestra completamente en pkgdown.\nEl código de ejemplo se ejecuta cuando debería y no se ejecuta cuando no debería.\nEsto no va en contra de la prohibición de CRAN de poner todo el código de ejemplo dentro de \\dontrun{}.\n\nPor ejemplo, googledrive usa @examplesIf en casi todas las funciones, protegido por googledrive::drive_has_token(). Así es como comienzan los ejemplos de googledrive::drive_publish():\n\n#' @examplesIf drive_has_token()\n#' # Crea un archivo para publicar\n#' file &lt;- drive_example_remote(\"chicken_sheet\") %&gt;%\n#'   drive_cp()\n#'\n#' # Publica el archivo\n#' file &lt;- drive_publish(file)\n#' ...\n\nEl código de ejemplo no se ejecuta en CRAN porque no hay ningún token. Se ejecuta cuando se crea el sitio pkgdown, porque podemos configurar un token de forma segura. Y, si un usuario normal ejecuta este código, se le pedirá que inicie sesión en Google, si aún no lo ha hecho.\n\n16.5.5 Mezclar ejemplos y texto\nUna alternativa a los ejemplos es usar bloques de código R Markdown en otras partes de tus comentarios de roxygen, ya sea ```R si solo quieres mostrar algo de código, o ```{r} si desea que se ejecute el código. Estas pueden ser técnicas efectivas, pero cada una tiene sus desventajas:\n\nEl código en los bloques ```R nunca se ejecuta; esto significa que es fácil introducir accidentalmente errores de sintaxis u olvidarse de actualizarlo cuando cambia el paquete.\nEl código en los bloques ```{r} se ejecuta cada vez que documentas el paquete. Esto tiene la gran ventaja de incluir el resultado en la documentación (a diferencia de los ejemplos), pero el código no puede tardar mucho en ejecutarse o su flujo de trabajo de documentación iterativo se volverá bastante doloroso.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#reutilizar-documentación",
    "href": "man.html#reutilizar-documentación",
    "title": "16  Documentación de la función",
    "section": "\n16.6 Reutilizar documentación",
    "text": "16.6 Reutilizar documentación\nroxygen2 proporciona una serie de funciones que le permiten reutilizar la documentación en todos los temas. Están documentados en vignette(\"reuse\", package = \"roxygen2\"), por lo que aquí nos centraremos en los tres más importantes:\n\nDocumentar múltiples funciones en un solo tema.\nHeredar documentación de otro tema.\nUsar documentos secundarios para compartir prosa entre temas, o para compartir entre temas de documentación y viñetas.\n\n\n16.6.1 Múltiples funciones en un tema\nDe forma predeterminada, cada función tiene su propio tema de documentación, pero si dos funciones están muy relacionadas, puede combinar la documentación de varias funciones en un solo tema. Por ejemplo, tomemos str_length() y str_width(), que proporcionan dos formas diferentes de calcular el tamaño de una cadena. Como puede ver en la descripción, ambas funciones están documentadas juntas, porque esto hace que sea más fácil ver en qué se diferencian:\n\n#' The length/width of a string\n#'\n#' @description\n#' `str_length()` returns the number of codepoints in a string. These are\n#' the individual elements (which are often, but not always letters) that\n#' can be extracted with [str_sub()].\n#'\n#' `str_width()` returns how much space the string will occupy when printed\n#' in a fixed width font (i.e. when printed in the console).\n#'\n#' ...\nstr_length &lt;- function(string) {\n  ...\n}\n\nPara fusionar los dos temas, str_width() usa @rdname str_length para agregar su documentación a un tema existente:\n\n#' @rdname str_length\nstr_width &lt;- function(string) {\n  ...\n}\n\nEsta técnica funciona mejor para funciones que tienen mucho en común, es decir, valores de retorno y ejemplos similares, además de argumentos similares.\n\n16.6.2 Heredar documentación\nEn otros casos, las funciones de un paquete pueden compartir muchos comportamientos relacionados, pero no están lo suficientemente conectadas como para que desee documentarlas juntas. Hemos discutido @inheritParams arriba, pero hay tres variaciones que le permiten heredar otras cosas:\n\n@inherit source_function heredará todos los componentes compatibles de source_function().\n@inheritSection source_function Título de la sección heredará la sección única con el título “Título de la sección” de source_function().\n@inheritDotParams genera automáticamente documentación de parámetros para ... para el caso común en el que pasa ... a otra función.\n\nVer https://roxygen2.r-lib.org/articles/reuse.html#inheriting-documentation para más detalles.\n\n16.6.3 Documentos secundarios\nFinalmente, puede reutilizar el mismo documento .Rmd o .md en la documentación de la función, README.Rmd, y viñetas utilizando documentos secundarios de R Markdown. La sintaxis se ve así:\n\n#' ```{r child = \"man/rmd/filename.Rmd\"}\n#' ```\n\nEsta es una característica que usamos con moderación en tidyverse, pero un lugar donde sí la usamos es en dplyr, porque varias funciones usan la misma sintaxis que select() y queremos proporcionar toda la información en un solo lugar:\n\n#' # Descripción general de las funciones de selección\n#'\n#' ```{r, child = \"man/rmd/overview.Rmd\"}\n#' ```\n\nLuego man/rmd/overview.Rmd contiene la rebaja repetida:\nLas selecciones de Tidyverse implementan un dialecto de R donde los operadores hacen\nEs fácil seleccionar variables:\n\n- `:` para seleccionar un rango de variables consecutivas.\n- `!` para tomar el complemento de un conjunto de variables.\n- `&` y `|` para seleccionar la intersección o la unión de dos\n  conjuntos de variables.\n- `c()` para combinar selecciones.\n\n...\nSi el archivo Rmd contiene enlaces roxygen (estilo Markdown) a otros temas de ayuda, entonces se necesita algo de cuidado. Ver https://roxygen2.r-lib.org/dev/articles/reuse.html#child-documents para detalles.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#sec-man-package-doc",
    "href": "man.html#sec-man-package-doc",
    "title": "16  Documentación de la función",
    "section": "\n16.7 Tema de ayuda para el paquete",
    "text": "16.7 Tema de ayuda para el paquete\nEste capítulo se centra en la documentación de funciones, pero recuerde que puede documentar otras cosas, como se detalla en vignette(\"rd-other\", package = \"roxygen2\"). En particular, puede crear un tema de ayuda para el paquete en sí documentando el centinela especial \"_PACKAGE\". El archivo .Rd resultante extrae automáticamente información analizada de la DESCRIPTION, incluido el título, la descripción, la lista de autores y las URL útiles. Este tema de ayuda aparece junto con todos los demás temas y también se puede acceder a él con package?pkgname, por ejemplo, package?usethis, o incluso simplemente con ?usethis.\nRecomendamos llamar a usethis::use_package_doc() para configurar esta documentación a nivel de paquete en un archivo ficticio R/{pkgname}-package.R, cuyo contenido se verá así:\n\n#' @keywords internal \n\"_PACKAGE\"\n\nEl archivo R/{pkgname}-package.R es la razón principal por la que queríamos mencionar aquí use_package_doc() y la documentación a nivel de paquete. Resulta que hay algunas otras tareas de limpieza de todo el paquete para las cuales este archivo es un hogar muy natural. Por ejemplo, es una ubicación central sensata para directivas de importación, es decir, para importar funciones individuales desde sus dependencias o incluso espacios de nombres completos. En Sección 11.4.1, recomendamos importar funciones específicas a través de usethis::use_import_from() y esta función está diseñada para escribir las etiquetas roxygen asociadas en el paquete R/{pkgname}. Archivo R creado por use_package_doc(). Entonces, poniéndolo todo junto, este es un ejemplo mínimo de cómo podría verse el archivo R/{pkgname}-package.R:\n\n#' @keywords internal \n\"_PACKAGE\"\n\n# El siguiente bloque es utilizado por usethis para administrar automáticamente\n# etiquetas de espacio de nombres de roxygen. ¡Modifique con cuidado!\n## usethis namespace: start\n#' @importFrom glue glue_collapse\n## usethis namespace: end\nNULL",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "man.html#footnotes",
    "href": "man.html#footnotes",
    "title": "16  Documentación de la función",
    "section": "",
    "text": "El nombre “roxygen” es un guiño al generador de documentación Doxygen, que inspiró el desarrollo de un paquete R llamado roxygen. Luego, ese concepto original se reinició como roxygen2, similar a ggplot2.↩︎\nEl archivo NAMESPACE también se genera a partir de estos comentarios de roxygen. O, mejor dicho, puede serlo y ese es el flujo de trabajo preferido de devtools (Sección 11.3).↩︎\nLa ejecución de devtools::document() también afecta a otro campo en DESCRIPTION, que se ve así: RoxygenNote: 7.2.1. Esto registra qué versión de roxygen2 se usó por última vez en un paquete, lo que facilita que devtools (y sus paquetes subyacentes) hagan una suposición inteligente sobre cuándo volver a document() un paquete y cuándo dejarlo en paz. En un entorno colaborativo, esto también reduce los cambios molestos en los archivos .Rd, al hacer que la versión relevante de roxygen2 sea muy visible.↩︎\nEsto es parte de la explicación prometida en Sección 9.8, donde también aclaramos que, con nuestras convenciones actuales, este campo realmente debería llamarse Config/Needs/roxygen, en su lugar. de Roxigen. Le recomendamos encarecidamente que utilice Markdown en todos los paquetes nuevos y que migre los paquetes más antiguos pero que se mantienen activamente a la sintaxis Markdown. En este caso, puede llamar a usethis::use_roxygen_md() para actualizar DESCRIPTION y recibir un recordatorio sobre el paquete roxygen2md, que puede ayudar con la conversión.↩︎\nO el final del bloque, si es la última etiqueta.↩︎\nel nombre del archivo se deriva automáticamente del objeto que estás documentando.↩︎\nEstas llamadas incluyen una especificación explícita de package = \"algúnpaquete\", ya que no se puede inferir del contexto, es decir, el contexto es un libro en cuarto, no la documentación del paquete.↩︎\nComo todos los ejemplos, es posible que estos hayan cambiado un poco desde que escribimos este libro, porque nos esforzamos constantemente por hacerlo mejor. Podrías comparar lo que hay en el libro con lo que usamos ahora y considerar si crees que es una mejora.↩︎\nEn el código anterior, es posible que veas el uso de @section title: que se usaba para crear secciones antes de que roxygen2 tuviera soporte completo para markdown. Si los ha usado en el pasado, ahora puede convertirlos en títulos de markdown.↩︎\nPor razones históricas, también puedes usar @return, pero ahora preferimos @returns porque se lee de forma más natural.↩︎\nVolveremos sobre cómo documentar múltiples funciones en un tema en Sección 16.6.1.↩︎\nSolías poder usar \\donttest{} para un propósito similar, pero ya no lo recomendamos porque CRAN establece un indicador especial que hace que el código se ejecute de todos modos.↩︎\nEsto es ciertamente cierto para CRAN y es cierto en la mayoría de los otros escenarios de verificación automatizada, como nuestros flujos de trabajo de GitHub Actions.↩︎",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Documentación de la función</span>"
    ]
  },
  {
    "objectID": "vignettes.html",
    "href": "vignettes.html",
    "title": "17  Viñetas",
    "section": "",
    "text": "17.1 Flujo de trabajo para escribir una viñeta\nUna viñeta es una guía detallada de su paquete. La documentación de funciones es excelente si conoce el nombre de la función que necesita, pero de lo contrario es inútil. Por el contrario, una viñeta se puede enmarcar en torno a un problema objetivo que su paquete está diseñado para resolver. El formato de viñeta es perfecto para mostrar un flujo de trabajo que resuelve ese problema en particular, de principio a fin. Las viñetas le brindan diferentes oportunidades que los temas de ayuda: tiene mucho más control sobre la integración del código y la prosa y es una mejor configuración para mostrar cómo funcionan múltiples funciones juntas.\nMuchos paquetes existentes tienen viñetas y puede ver todas las viñetas asociadas con sus paquetes instalados con browseVignettes(). Para limitar eso a un paquete en particular, puede especificar el nombre del paquete así: browseVignettes(\"tidyr\"). Puede leer una viñeta específica con la función vignette(), por ejemplo, vignette(\"rectangle\", package = \"tidyr\"). Para ver viñetas de un paquete que no ha instalado, consulte la lista “Viñetas” en su página CRAN, por ejemplo. https://cran.r-project.org/web/packages/tidyr/index.html.\nSin embargo, preferimos descubrir y leer viñetas del sitio web de un paquete, que es el tema de Capítulo 191. Compare lo anterior con lo que se siente al acceder a las viñetas de tidyr desde su sitio web: https://tidyr.tidyverse.org/articles/index.html. Tenga en cuenta que pkgdown utiliza el término “artículo”, que parece el vocabulario adecuado para los usuarios del paquete. La distinción técnica entre una viñeta (que se envía con un paquete) y un artículo (que solo está disponible en el sitio web; consulte Sección 17.4.1) es algo en lo que el desarrollador del paquete debe pensar. Un sitio web pkgdown presenta toda la documentación de un paquete de una manera coherente e interconectada que lo hace más navegable y útil. Aparentemente, este capítulo trata sobre viñetas, pero la forma en que hacemos las cosas está fuertemente influenciada por cómo esas viñetas encajan en un sitio web pkgdown.\nEn este libro, usaremos R Markdown para escribir nuestras viñetas2, tal como lo hicimos para la documentación de funciones en Sección 16.1.3. Si aún no está familiarizado con R Markdown, necesitará aprender los conceptos básicos en otro lugar; un buen lugar para empezar es https://rmarkdown.rstudio.com/.\nEn general, adoptamos un flujo de trabajo de viñeta algo circunscrito, es decir, hay muchas cosas que la base R permite, en las que simplemente no participamos. Por ejemplo, tratamos inst/doc/3 de la misma manera que man/ y NAMESPACE, es decir, como algo semiopaco que se gestiona mediante herramientas automatizadas y que no modificamos. manualmente. El sistema de viñetas de Base R permite varias maniobras complicadas que simplemente intentamos evitar. En las viñetas, más que en cualquier otro lugar, la respuesta a “¿Pero cómo hago X?” suele ser “No hagas X”.\nPara crear su primera viñeta, ejecute:\nusethis::use_vignette(\"my-vignette\")\nEsto hace lo siguiente:\nEste borrador del documento tiene los elementos clave de una viñeta de R Markdown y le permite agregar su contenido. También llama a use_vignette() para crear su segunda viñeta y todas las siguientes; simplemente omitirá cualquier configuración que ya se haya realizado.\nUna vez que tenga el borrador de la viñeta, el flujo de trabajo es sencillo:\nSi revisa periódicamente todo su paquete (Sección 4.5), lo cual recomendamos encarecidamente, esto ayudará a mantener sus viñetas en buen estado de funcionamiento. En particular, esto le alertará si una viñeta utiliza un paquete que no es una dependencia formal. Volveremos a estos problemas de flujo de trabajo a nivel de paquete a continuación en Sección 17.5.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#sec-vignettes-workflow-writing",
    "href": "vignettes.html#sec-vignettes-workflow-writing",
    "title": "17  Viñetas",
    "section": "",
    "text": "Crea un directorio viñetas/.\nAgrega las dependencias necesarias a DESCRIPCIÓN, es decir, agrega knitr al campo VignetteBuilder y agrega knitr y rmarkdown a Suggests.\nRedacta una viñeta, vignettes/my-vignette.Rmd.\nAgrega algunos patrones a .gitignore para garantizar que los archivos creados como efecto secundario de la vista previa de sus viñetas se mantengan fuera del control de fuente (diremos más sobre esto más adelante).\n\n\n\n\nComience a agregar prosa y fragmentos de código a la viñeta. Utilice devtools::load_all() según sea necesario y utilice su flujo de trabajo interactivo habitual para desarrollar los fragmentos de código.\n\nRenderice periódicamente la viñeta completa.\nEsto requiere cierta intención, porque a diferencia de las pruebas, de forma predeterminada, una viñeta se representa usando la versión actualmente instalada de su paquete, no con el paquete fuente actual, gracias a la llamada inicial a library(supaquete).\nUna opción es instalar correctamente su paquete fuente actual con devtools::install() o, en RStudio, Ctrl/Cmd + Shift + B. Luego use su flujo de trabajo habitual para renderizar un archivo .Rmd. Por ejemplo, presione Ctrl/Cmd + Shift + K o haga clic en .\nO puede instalar correctamente su paquete y solicitar que se creen viñetas, con install(build_vignettes = TRUE), luego usar browseVignettes().\nOtra opción es usar devtools::build_rmd(\"vignettes/my-vignette.Rmd\") para representar la viñeta. Esto construye su viñeta contra una versión de desarrollo (instalada temporalmente) de su paquete.\nEs muy fácil pasar por alto este problema y quedar desconcertado cuando la vista previa de su viñeta no parece reflejar los desarrollos recientes en el paquete. ¡Comprueba que estás compilando con la versión actual!\n\nEnjuague y repita hasta que la viñeta luzca como desea.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#metadatos",
    "href": "vignettes.html#metadatos",
    "title": "17  Viñetas",
    "section": "\n17.2 Metadatos",
    "text": "17.2 Metadatos\nLas primeras líneas de la viñeta contienen metadatos importantes. La plantilla predeterminada contiene la siguiente información:\n---\ntitle: \"Título de viñeta\"\noutput: rmarkdown::html_vignette\nvignette: &gt;\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\nEstos metadatos están escritos en YAML, un formato diseñado para ser legible tanto por humanos como por computadoras. El frontmatter YAML es una característica común de los archivos R Markdown. La sintaxis es muy parecida a la del archivo DESCRIPTION, donde cada línea consta de un nombre de campo, dos puntos y luego el valor del campo. La única característica especial de YAML que estamos usando aquí es &gt;. Indica que las siguientes líneas de texto son texto sin formato y no deben utilizar ninguna característica especial de YAML.\nLa plantilla de viñeta predeterminada utiliza estos campos:\n\ntitle: este es el título que aparece en la viñeta. Si lo cambia, asegúrese de realizar el mismo cambio en VignetteIndexEntry{}. Deberían ser iguales, pero lamentablemente eso no es automático.\nsalida: esto especifica el formato de salida. Hay muchas opciones que son útiles para informes regulares (incluidos html, pdf, presentaciones de diapositivas, etc.), pero rmarkdown::html_vignette ha sido diseñado específicamente para este propósito exacto. Consulte ?rmarkdown::html_vignette para obtener más detalles.\nvignette: este es un bloque de metadatos especiales que necesita R. Aquí puede ver el legado de las viñetas de LaTeX: los metadatos parecen comentarios de LaTeX. La única entrada que quizás necesite modificar es \\VignetteIndexEntry{}. Así es como aparece la viñeta en el índice de viñetas y debe coincidir con el “título”. Deja las otras dos líneas en paz. Le dicen a R que use knitr para procesar el archivo y que el archivo esté codificado en UTF-8 (la única codificación que debería usar para una viñeta).\n\nGeneralmente no usamos estos campos, pero los verá en otros paquetes:\n\nautor: no usamos esto a menos que la viñeta esté escrita por alguien que aún no esté acreditado como autor del paquete.\ndate: creemos que esto suele hacer más daño que bien, ya que no está claro qué pretende transmitir la date. ¿Es la última vez que se actualizó la fuente de la viñeta? En ese caso, tendrás que administrarlo manualmente y es fácil olvidarte de actualizarlo. Si administra date programáticamente con Sys.date(), la fecha refleja cuándo se creó la viñeta, es decir, cuándo se creó el paquete, que no tiene nada que ver con cuándo se modificó por última vez la viñeta o el paquete. Hemos decidido que es mejor omitir la date.\n\nEl borrador de la viñeta también incluye dos fragmentos de R. El primero configura nuestra forma preferida de mostrar la salida del código y tiene este aspecto:\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\"\n)\n```\nEl segundo fragmento simplemente adjunta el paquete al que pertenece la viñeta.\n```{r setup}\nlibrary(yourpackage)\n```\nEs posible que tenga la tentación de reemplazar (temporalmente) esta llamada library() con load_all(), pero le recomendamos que no lo haga. En su lugar, utilice las técnicas proporcionadas en Sección 17.1 para ejercitar su código de viñeta con el paquete fuente actual.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#consejos-para-escribir-viñetas",
    "href": "vignettes.html#consejos-para-escribir-viñetas",
    "title": "17  Viñetas",
    "section": "\n17.3 Consejos para escribir viñetas",
    "text": "17.3 Consejos para escribir viñetas\n\nSi estás pensando sin escribir, sólo piensas que estás pensando. — Leslie Lamport\n\nAl escribir una viñeta, le estás enseñando a alguien cómo usar tu paquete. Debe ponerse en el lugar del lector y adoptar una “mente de principiante”. Esto puede resultar difícil porque es difícil olvidar todo el conocimiento que ya ha interiorizado. Por este motivo, consideramos que la enseñanza presencial es una forma realmente útil de obtener retroalimentación. Inmediatamente te enfrentas a lo que has olvidado y que sólo tú sabes.\nUn efecto secundario útil de este enfoque es que le ayuda a mejorar su código. Te obliga a volver a ver el proceso de incorporación inicial y a apreciar las partes que son difíciles. Nuestra experiencia es que explicar cómo funciona el código a menudo revela algunos problemas que deben solucionarse.\nDe hecho, una parte clave del proceso de lanzamiento del paquete tidyverse es escribir una publicación en el blog: ahora lo hacemos antes de enviarlo a CRAN, debido a la cantidad de veces que se revela algún problema sutil que requiere solución. También es justo decir que tidyverse y sus paquetes de soporte se beneficiarían de más guías prácticas, por lo que es un área en la que intentamos mejorar constantemente.\nEscribir una viñeta también supone un buen descanso de la codificación. La escritura parece utilizar una parte del cerebro diferente a la de la programación, así que si estás cansado de la programación, intenta escribir un poco.\nAquí hay algunos recursos que hemos encontrado útiles:\n\nLiteralmente cualquier cosa escrita por Kathy Sierra. No escribe activamente en este momento, pero su contenido es en su mayor parte atemporal y está lleno de consejos sobre programación, enseñanza y cómo crear herramientas valiosas. Vea su blog original, Creando usuarios apasionados, o el sitio posterior, Serious Pony.\n“Estilo: Lecciones de claridad y gracia” de Joseph M. Williams y Joseph Bizup. Este libro le ayuda a comprender la estructura de la escritura para que pueda reconocer y corregir mejor la mala escritura.\n\n\n17.3.1 Diagramas\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nTendrás que vigilar el tamaño del archivo. Si incluye muchos gráficos, es fácil crear un archivo muy grande. Esté atento a una “NOTA” que se queja de un directorio demasiado grande. Es posible que debas tomar medidas explícitas, como reducir la resolución, reducir el número de figuras o cambiar de una viñeta a un artículo (Sección 17.4.1).\n\n\n\n17.3.2 Enlaces\nNo existe una forma oficial de vincular temas de ayuda desde viñetas o viceversa o de una viñeta a otra.\nEste es un ejemplo concreto de por qué creemos que los sitios pkgdown son una excelente manera de presentar documentación de paquetes, porque pkgdown hace que sea fácil (literalmente sin esfuerzo, en muchos casos) obtener estas referencias cruzadas con hipervínculos. Esto está documentado en vignette(\"linking\", package = \"pkgdown\"). Si estás leyendo este libro en línea, la llamada en línea a vignette() en la oración anterior debe tener un hipervínculo a la viñeta correspondiente en pkgdown4, usando la misma cadena de herramientas que creará enlaces automáticos en tu pkgdown. sitios web! Discutimos esta sintaxis anteriormente en Sección 16.1.3, en el contexto de la documentación de funciones.\nSe generan enlaces automáticos para funciones en el paquete host, funciones calificadas para espacios de nombres en otro paquete, viñetas y más. Estos son los dos ejemplos más importantes de texto vinculado automáticamente:\n\n`some_function()`: Autoenlazado a la documentación de some_function(), dentro del sitio pkgdown de su paquete host. Tenga en cuenta el uso de comillas invertidas y paréntesis finales.\n`vignette(\"fascinating-topic\")`: Vinculado automáticamente al artículo “fascinating-topic” dentro del sitio pkgdown de su paquete host. Tenga en cuenta el uso de comillas invertidas.\n\n17.3.3 Rutas de archivos\nA veces es necesario hacer referencia a otro archivo de una viñeta. La mejor manera de hacerlo depende de la aplicación:\n\nUna figura creada por código evaluado en la viñeta: De forma predeterminada, en el flujo de trabajo .Rmd que recomendamos, esto se soluciona solo. Estas cifras se incrustan automáticamente en .html mediante URI de datos. No necesitas hacer nada. Ejemplo: vignette(\"extending-ggplot2\", package = \"ggplot2\") genera algunas cifras en fragmentos de código evaluados.\n\nUn archivo externo que podría ser útil para los usuarios o en cualquier otra parte del paquete (no solo en viñetas): coloque dicho archivo en inst/ (Sección 8.2), tal vez en inst/extdata/ (Sección 7.3), y consúltelo con system.file() o fs::path_package() (Sección 7.3.1). Ejemplo de vignette(\"sf2\", package = \"sf\"):\n````{r}\nlibrary(sf)\nfname &lt;- system.file(\"shape/nc.shp\", package=\"sf\")\nfname\nnc &lt;- st_read(fname)\n```\n\n\nUn archivo externo cuya utilidad se limita a sus viñetas: colóquelo junto a los archivos fuente de las viñetas en vignettes/ y consúltelo con una ruta de archivo relativa a vignettes/.\nEjemplo: la fuente de vignette(\"tidy-data\", package = \"tidyr\") se encuentra en vignettes/tidy-data.Rmd e incluye un fragmento que lee un archivo ubicado en vignettes/weather.csvasí:\n```{r}\nweather &lt;- as_tibble(read.csv(\"weather.csv\", stringsAsFactors = FALSE))\nweather\n```\n\n\nUn archivo de gráficos externo: colóquelo en vignettes/, consúltelo con una ruta de archivo relativa a vignettes/ y use knitr::include_graphics() dentro de un fragmento de código. Ejemplo de vignette(\"sheet-geometry\", package = \"readxl\"):\n```{r out.width = '70%', echo = FALSE}\nknitr::include_graphics(\"img/geometry.png\")\n```\n\n\n17.3.4 ¿Cuántas viñetas?\nPara paquetes más simples, una viñeta suele ser suficiente. Si su paquete se llama “algúnpaquete”, llame a esta viñeta algúnpaquete.Rmd. Esto aprovecha una convención pkgdown, donde la viñeta que lleva el nombre del paquete obtiene un enlace automático “Get started” en la barra de navegación superior.\nLos paquetes más complicados probablemente necesiten más de una viñeta. Puede resultar útil pensar en las viñetas como capítulos de un libro: deben ser independientes, pero aun así estar unidos formando un todo cohesivo.\n\n17.3.5 Publicación científica\nLas viñetas también pueden resultar útiles si desea explicar los detalles de su paquete. Por ejemplo, si ha implementado un algoritmo estadístico complejo, es posible que desee describir todos los detalles en una viñeta para que los usuarios de su paquete puedan entender lo que sucede bajo el capó y estar seguros de que ha implementado el algoritmo correctamente. En este caso, también podría considerar enviar su viñeta al Journal of Statistical Software o The R Journal. Ambas revistas son únicamente electrónicas y están revisadas por pares. Los comentarios de los revisores pueden ser muy útiles para mejorar su paquete y viñeta.\nSi solo desea proporcionar algo muy liviano para que la gente pueda citar fácilmente su paquete, considere el Journal of Open Source Software. Esta revista tiene un proceso de envío y revisión particularmente rápido, y es donde publicamos “Welcome to the Tidyverse”, un artículo que escribimos para que la gente pudiera tener un solo artículo para citar y todos los autores de tidyverse obtuvieran algún crédito académico.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#sec-vignettes-eval-option",
    "href": "vignettes.html#sec-vignettes-eval-option",
    "title": "17  Viñetas",
    "section": "\n17.4 Consideraciones especiales para el código de viñeta",
    "text": "17.4 Consideraciones especiales para el código de viñeta\nUn tema recurrente es que el código R dentro de un paquete debe escribirse de manera diferente al código en sus scripts e informes de análisis. Esto es cierto para sus funciones (Sección 6.4), pruebas (Sección 14.2) y ejemplos (Sección 16.5), y también es cierto para las viñetas. En términos de lo que puedes y no puedes hacer, las viñetas son bastante similares a los ejemplos, aunque algunas de las mecánicas difieren.\nCualquier paquete utilizado en una viñeta debe ser una dependencia formal, es decir, debe aparecer en Imports o Suggests en DESCRIPTION. De manera similar a nuestra postura en las pruebas (Sección 11.5.2), nuestra política es escribir viñetas bajo el supuesto de que los paquetes sugeridos se instalarán en cualquier contexto donde se esté creando la viñeta (Sección 11.5.3). Generalmente utilizamos paquetes sugeridos incondicionalmente en viñetas. Pero, al igual que con las pruebas, si un paquete es particularmente difícil de instalar, podríamos hacer una excepción y tomar medidas adicionales para proteger su uso.\nHay muchas otras razones por las que podría no ser posible evaluar todo el código en una viñeta en ciertos contextos, como en las máquinas de CRAN o en CI/CD. Estos incluyen todos los sospechosos habituales: falta de credenciales de autenticación, código de ejecución prolongada o código vulnerable a fallas intermitentes.\nEl método principal para controlar la evaluación en un documento .Rmd es la opción de fragmento de código eval, que puede ser TRUE (el valor predeterminado) o FALSE. Es importante destacar que el valor de eval puede ser el resultado de evaluar una expresión. A continuación se muestran algunos ejemplos relevantes:\n\neval = requireNamespace(\"algunadependencia\")\neval = !identical(Sys.getenv(\"ALGO_QUE_NECESITA\"), \"\")\neval = file.exists(\"credenciales-que-necesita\")\n\nLa opción eval se puede configurar para un fragmento individual, pero en una viñeta es probable que desees evaluar la mayoría o todos los fragmentos o prácticamente ninguno de ellos. En el último caso, querrás usar knitr::opts_chunk$set(eval = FALSE) en un fragmento inicial oculto para hacer que eval = FALSE sea el valor predeterminado para el resto de la viñeta. Aún puedes anular con eval = TRUE en fragmentos individuales.\nEn viñetas, usamos la opción eval de manera similar a @examplesIf en los ejemplos (Sección 16.5.4). Si el código solo se puede ejecutar bajo condiciones específicas, debe encontrar una manera de verificar esas condiciones previas mediante programación en tiempo de ejecución y usar el resultado para configurar la opción eval.\nEstos son los primeros fragmentos de una viñeta de googlesheets4, que engloba la API de Google Sheets. El código de viñeta solo se puede ejecutar si somos capaces de descifrar un token que nos permita autenticarnos con la API. Ese hecho se registra en can_decrypt, que luego se establece como el valor predeterminado de toda la viñeta para eval.\n```{r setup, include = FALSE}\ncan_decrypt &lt;- gargle:::secret_can_decrypt(\"googlesheets4\")\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\",\n  error = TRUE,\n  eval = can_decrypt\n)\n```\n\n```{r eval = !can_decrypt, echo = FALSE, comment = NA}\nmessage(\"No token available. Code chunks will not be evaluated.\")\n```\n\n```{r index-auth, include = FALSE}\ngooglesheets4:::gs4_auth_docs()\n```\n\n```{r}\nlibrary(googlesheets4)\n```\nObserve que el segundo fragmento usa eval = !can_decrypt, que imprime un mensaje explicativo para cualquiera que cree la viñeta sin las credenciales necesarias.\nEl ejemplo anterior muestra algunas opciones de fragmentos más útiles. Utilice include = FALSE para fragmentos que deben evaluarse pero no verse en la viñeta representada. La opción echo controla si se imprime el código, además de la salida. Finalmente, error = TRUE es lo que le permite ejecutar código intencionalmente que podría generar un error. El error aparecerá en la viñeta, tal como lo haría para su usuario, pero no impedirá la ejecución del resto del código de su viñeta, ni provocará que falle la R CMD check. Esto es algo que funciona mucho mejor en una viñeta que en un ejemplo.\nMuchas otras opciones se describen en https://yihui.name/knitr/options.\n\n17.4.1 Artículo en lugar de viñeta\nExiste una última técnica, si no desea que ningún código se ejecute en CRAN. En lugar de una viñeta, puede crear un artículo, que es un término utilizado por pkgdown para un documento .Rmd similar a una viñeta que no se envía con el paquete, pero que aparece sólo en el sitio web. Un artículo será menos accesible que una viñeta para ciertos usuarios, como aquellos con acceso limitado a Internet, porque no está presente en la instalación local. Pero ese podría ser un compromiso aceptable, por ejemplo, para un paquete que incluye una API web.\nPuede redactar un nuevo artículo con usethis::use_article(), lo que garantiza que el artículo será .Rbuildignored. Una buena razón para utilizar un artículo en lugar de una viñeta es mostrar que su paquete funciona en conjunto con otros paquetes de los que no desea depender formalmente. Otro caso de uso atractivo es cuando un artículo realmente exige muchos gráficos. Esto es problemático para una viñeta, porque el gran tamaño del paquete causa problemas con R CMD check (y, por lo tanto, CRAN) y también es una carga para todos los que lo instalan, especialmente aquellos con Internet limitado.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#sec-vignettes-how-built-checked",
    "href": "vignettes.html#sec-vignettes-how-built-checked",
    "title": "17  Viñetas",
    "section": "\n17.5 Cómo se construyen y verifican las viñetas",
    "text": "17.5 Cómo se construyen y verifican las viñetas\nCerramos este capítulo volviendo a algunos problemas de flujo de trabajo que no cubrimos en Sección 17.1: ¿Cómo se convierten los archivos .Rmd en viñetas consumidas por los usuarios de un paquete instalado? ¿Qué hace R CMD check con las viñetas? ¿Cuáles son las implicaciones para mantener sus viñetas?\nPuede resultar útil apreciar la gran diferencia entre el flujo de trabajo para la documentación de funciones y las viñetas. La fuente de la documentación de la función se almacena en los comentarios de roxygen en archivos .R debajo de R/. Usamos devtools::document() para generar archivos .Rd debajo de man/. Estos archivos man/*.Rd son parte del paquete fuente. La maquinaria oficial de R se preocupa sólo por los archivos .Rd.\nLas viñetas son muy diferentes porque la fuente .Rmd se considera parte del paquete fuente y la maquinaria oficial (R CMD build y check) interactúa con la fuente de la viñeta y las viñetas construidas de muchas maneras. El resultado es que el flujo de trabajo de viñetas se siente más restringido, ya que las herramientas oficiales básicamente tratan las viñetas como pruebas, en lugar de documentación.\n\n17.5.1 R CMD build y viñetas\nPrimero, es importante darse cuenta de que los archivos fuente vignettes/*.Rmd existen solo cuando un paquete está en formato fuente (Sección 3.2) o en formato empaquetado (Sección 3.3). Las viñetas se representan cuando un paquete fuente se convierte en un paquete mediante R CMD build o un contenedor conveniente como devtools::build(). Los productos renderizados (.html) se colocan en inst/doc/, junto con su fuente (.Rmd) y el código R extraído (.R; discutido en Sección 17.5.2) . Finalmente, cuando se crea un paquete binario (Sección 3.4), el directorio inst/doc/ se promueve a un directorio doc/ de nivel superior, como sucede con todo lo que está debajo de inst/.\n\nTLa conclusión clave de lo anterior es que resulta incómodo mantener viñetas renderizadas en un paquete fuente y esto tiene implicaciones para el flujo de trabajo de desarrollo de viñetas. Es tentador luchar contra esto (y muchos lo han intentado), pero basándose en años de experiencia y discusión, la filosofía de devtools es aceptar esta realidad.\nSuponiendo que no intenta mantener viñetas creadas de manera persistente en su paquete fuente, aquí están nuestras recomendaciones para varios escenarios:\n\nTrabajo activo e iterativo en sus viñetas: use su flujo de trabajo interactivo habitual .Rmd (como el botón ) o devtools::build_rmd(\"vignettes /my-vignette.Rmd\") para representar una viñeta en .html en el directorio vignettes/. Considere el .html como una vista previa desechable. (Si inicia viñetas con use_vignette(), este .html ya será ignorado).\n\nPoner a disposición del mundo el estado actual de las viñetas en una versión de desarrollo:\n\nOfrecer un sitio web pkgdown, preferiblemente con “construcción e implementación” automatizada, como el uso de GitHub Actions para implementar en GitHub Pages. Aquí están las viñetas de tidyr en la versión de desarrollo (tenga en cuenta “dev” en la URL): https://tidyr.tidyverse.org/dev/articles/index.html.\nTenga en cuenta que cualquiera que instale directamente desde GitHub deberá solicitar viñetas explícitamente, por ejemplo, con devtools::install_github(dependencies = TRUE, build_vignettes = TRUE).\n\n\n\nHacer que el estado actual de las viñetas en una versión de desarrollo esté disponible localmente:\n\nInstale su paquete localmente y solicite que se creen e instalen viñetas, por ejemplo, con devtools::install(dependencies = TRUE, build_vignettes = TRUE).\n\n\nPrepare viñetas creadas para un envío CRAN: no intente hacerlo a mano o con anticipación. Permita que la (re)compilación de viñetas se realice como parte de devtools::submit_cran() o devtools::release(), los cuales compilan el paquete.\n\nSi realmente desea crear viñetas de manera oficial de forma ad hoc, devtools::build_vignettes() lo hará. Pero hemos visto que esto genera frustración en los desarrolladores, porque deja el paquete en una forma peculiar que es una mezcla de un paquete fuente y un paquete desempaquetado. Esta situación atípica puede generar aún más confusión. Por ejemplo, no está claro cómo se debe acceder a estas viñetas que no están realmente instaladas. La mayoría de los desarrolladores deberían evitar el uso de build_vignettes() y, en su lugar, elegir uno de los enfoques descritos anteriormente.\n\n\n\n\n\n\nViñetas prediseñadas (or other documentation)\n\n\n\nRecomendamos encarecidamente tratar inst/doc/ como un directorio estrictamente editable por máquina para viñetas. Le recomendamos que no aproveche el hecho de que puede colocar documentación prediseñada arbitraria en inst/doc/. Esta opinión impregna el ecosistema devtools que, de forma predeterminada, limpia inst/doc/ durante diversas tareas de desarrollo, para combatir el problema de la documentación obsoleta.\nSin embargo, reconocemos que existen excepciones a cada regla. En algunos dominios, puede resultar poco práctico reconstruir viñetas con tanta frecuencia como implica nuestro flujo de trabajo recomendado. Aquí hay algunos consejos:\n\nPuedes evitar la limpieza de inst/doc/ con pkgbuild::build(clean_doc = FALSE). Puede poner Config/build/clean-inst-doc: FALSE en DESCRIPTION para evitar que pkgbuild y rcmdcheck limpien inst/doc/.\nLa nota técnica de rOpenSci Cómo precalcular viñetas de paquetes o artículos pkgdown describe una técnica inteligente y liviana para mantener una viñeta actualizada manualmente en viñetas/.\nEl paquete R.rsp ofrece soporte explícito para viñetas estáticas.\n\n\n\n\n17.5.2 R CMD check y viñetas\nConcluimos con una discusión sobre cómo las viñetas son tratadas por R CMD check. Este verificador oficial espera un paquete creado por R CMD build, como se describe anteriormente. En el flujo de trabajo de devtools, generalmente confiamos en devtools::check(), que realiza automáticamente este paso de compilación por nosotros, antes de verificar el paquete. R CMD check tiene varias opciones de línea de comando y también consulta muchas variables de entorno. Estamos adoptando un enfoque maximalista aquí, es decir, describimos todas las comprobaciones que podrían ocurrir.\nR CMD check realiza un análisis estático del código de viñeta y examina la existencia, el tamaño y los tiempos de modificación de varios archivos relacionados con viñetas. Si sus viñetas usan paquetes que no aparecen en DESCRIPTION, eso se recoge aquí. Si los archivos que deberían existir no existen o viceversa, eso se recoge aquí. Esto no debería suceder si utiliza el flujo de trabajo de viñeta estándar descrito en este capítulo y generalmente es el resultado de algún experimento que haya realizado, intencionalmente o no.\nLuego, el código de viñeta se extrae en un archivo .R, utilizando la función tangle del motor de viñeta correspondiente (knitr, en nuestro caso), y se ejecuta. El código que se origina a partir de fragmentos marcados como eval = FALSE se comentará en este archivo y, por lo tanto, no se ejecutará. Luego, las viñetas se reconstruyen desde la fuente, utilizando la función weave del motor de viñetas (knitr, para nosotros). Esto ejecuta todo el código de viñeta una vez más, excepto los fragmentos marcados como eval = FALSE.\n\n\n\n\n\n\nEnvío a CRAN\n\n\n\nLas comprobaciones entrantes y en curso de CRAN utilizan R CMD check que, como se describe anteriormente, ejercita el código de viñeta hasta dos veces. Por lo tanto, es importante suprimir condicionalmente la ejecución de código condenado a fallar en CRAN.\nSin embargo, es importante tener en cuenta que el paquete y los archivos binarios distribuidos por CRAN en realidad utilizan las viñetas integradas incluidas en su envío. Sí, CRAN intentará reconstruir sus viñetas periódicamente, pero esto es con fines de control de calidad. CRAN distribuye las viñetas que usted creó.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "vignettes.html#footnotes",
    "href": "vignettes.html#footnotes",
    "title": "17  Viñetas",
    "section": "",
    "text": "Esto obviamente depende de la calidad de la conexión a Internet, por lo que nos esforzamos en recomendar comportamientos que sean compatibles con las herramientas de base R en torno a las viñetas instaladas.↩︎\nSweave es el sistema original utilizado para crear viñetas (los archivos Sweave generalmente tienen la extensión .Rnw). De manera similar a nuestro consejo sobre cómo crear documentación de funciones (Capítulo 16), creemos que tiene más sentido usar una sintaxis basada en rebajas para viñetas que un formato único asociado a LaTeX. Esta elección también afecta la forma de las viñetas renderizadas: las viñetas Sweave se renderizan en PDF, mientras que las viñetas R Markdown se renderizan en HTML. Recomendamos convertir viñetas de Sweave a R Markdown.↩︎\nLa carpeta inst/doc/ es donde van las viñetas una vez creadas, cuando R CMD build crea el paquete.↩︎\nY, para cualquier otra persona, ejecutar este código en la consola R abrirá la viñeta, si el paquete host está instalado.↩︎",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Viñetas</span>"
    ]
  },
  {
    "objectID": "other-markdown.html",
    "href": "other-markdown.html",
    "title": "18  Otros archivos markdown",
    "section": "",
    "text": "18.1 README\nEn este capítulo destacamos dos archivos que se utilizan convencionalmente para proporcionar documentación a nivel de paquete. Estos dos son importantes porque aparecen tanto en la página de inicio de CRAN como en el sitio de pkgdown de un paquete:\nIncluso si su paquete está destinado a una audiencia muy limitada y es posible que nunca se publique en CRAN, estos archivos pueden resultar muy útiles. Estos dos archivos no tienen que estar escritos en Markdown, pero pueden estarlo. De acuerdo con nuestras prácticas para temas de ayuda y viñetas, es nuestra fuerte recomendación y es lo que describimos aquí.\nPrimero, hablaremos sobre la función del archivo README y dejaremos de lado la extensión del archivo, hasta que estemos listos para hablar sobre la mecánica.\nEl objetivo del README es responder las siguientes preguntas sobre su paquete:\nEl archivo README es una convención de software establecida desde hace décadas. Parte de su contenido tradicional se encuentra en otra parte de un paquete R; por ejemplo, usamos el archivo DESCRIPTION para documentar la autoría y la licencia.\nCuando escriba su README, intente ponerse en el lugar de alguien que se encontró con su paquete y está tratando de descubrir si resuelve un problema que tiene. Si deciden que su paquete parece prometedor, el README también debería mostrarles cómo instalarlo y cómo realizar una o dos tareas básicas. Aquí hay una buena plantilla para README:",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Otros archivos markdown</span>"
    ]
  },
  {
    "objectID": "other-markdown.html#sec-readme",
    "href": "other-markdown.html#sec-readme",
    "title": "18  Otros archivos markdown",
    "section": "",
    "text": "¿Por qué debería usarlo?\n¿Como lo uso?\n¿Como lo consigo?\n\n\n\n\nUn párrafo que describa el propósito de alto nivel del paquete.\nUn ejemplo que muestra cómo utilizar el paquete para resolver un problema sencillo.\nInstrucciones de instalación, con código que se puede copiar y pegar en R.\nUna descripción general que describe los componentes principales del paquete. Para paquetes más complejos, esto apuntará a viñetas para obtener más detalles. Este también es un buen lugar para describir cómo encaja su paquete en el ecosistema de su dominio de destino.\n\n\n18.1.1 README.Rmd y README.md\n\nComo se mencionó anteriormente, preferimos escribir README en Markdown, es decir, tener README.md. Esto se representará como HTML y se mostrará en varios contextos importantes:\n\n\nLa página de inicio del repositorio, si mantiene su paquete en GitHub (o un host similar).\n\nhttps://github.com/tidyverse/dplyr\n\n\n\nEn CRAN, si libera su paquete allí.\n\n\nhttps://cran.r-project.org/web/packages/dplyr/index.html\nObserve el hipervínculo “README” en “Materials”.\n\n\n\n\nComo página de inicio de su sitio pkgdown, si tiene uno.\n\nhttps://dplyr.tidyverse.org\n\n\n\nDado que es mejor incluir un par de ejemplos en README.md, lo ideal sería generarlo con R Markdown. Es decir, funciona bien tener README.Rmd como archivo fuente principal, que luego se representa en README.md.\nLa forma más sencilla de empezar es utilizar usethis::use_readme_rmd().1 Esto crea una plantilla README.Rmd y la agrega a .Rbuildignore, ya que solo se debe incluir README.md en el paquete. La plantilla se ve así:\n---\noutput: github_document\n---\n\n&lt;!-- README.md is generated from README.Rmd. Please edit that file --&gt;\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#&gt;\",\n  fig.path = \"man/figures/README-\",\n  out.width = \"100%\"\n)\n```\n\n# algunpaquete\n\n&lt;!-- badges: start --&gt;\n\n&lt;!-- badges: end --&gt;\n\nEl objetivo de algún paquete es...\n\n## Instalación\n\nPuedes instalar la versión de desarrollo de algún paquete desde [GitHub](https://github.com/) con:\n\n``` r\n# install.packages(\"devtools\")\ndevtools::install_github(\"jane/algunpaquete\")\n```\n\n## Ejemplo\n\nEste es un ejemplo básico que muestra cómo resolver un problema común:\n\n```{r example}\nlibrary(somepackage)\n## código de ejemplo básico\n```\n\n¿Qué tiene de especial usar `README.Rmd` en lugar de simplemente `README.md`?\nPuedes incluir fragmentos de R así:\n\n```{r cars}\nsummary(cars)\n```\n\nAún necesitarás renderizar `README.Rmd` regularmente para mantener `README.md` actualizado.\n`devtools::build_readme()` es útil para esto.\n\nTambién puedes incrustar gráficos, por ejemplo:\n\n```{r pressure, echo = FALSE}\nplot(pressure)\n```\n\nEn ese caso, no olvide confirmar y enviar los archivos de figuras resultantes para que se muestren en GitHub y CRAN.\nAlgunas cosas a tener en cuenta sobre este iniciador README.Rmd:\n\nSe representa en [GitHub Flavored Markdown] (https://github.github.com/gfm/).\nIncluye un comentario para recordarle que debe editar README.Rmd, no README.md.\nConfigura nuestras opciones de knitr recomendadas, incluido guardar imágenes en man/figures/README-, lo que garantiza que estén incluidas en su paquete creado. Esto es importante para que su README funcione cuando CRAN lo muestre.\n\nCrea un lugar para futuras insignias, como los resultados de las comprobaciones automáticas de integración continua (Sección 20.2). Ejemplos de funciones que insertan insignias de desarrollo:\n\nusethis::use_cran_badge() informa la versión actual de su paquete en CRAN.\nusethis::use_coverage() informa la cobertura de la prueba.\nusethis::use_github_action(\"check-standard\") y amigos informan el estado de R CMD check de su paquete de desarrollo.\n\n\nIncluye marcadores de posición donde debes proporcionar código para la instalación del paquete y para algunos usos básicos.\nLe recuerda datos clave sobre el mantenimiento de su README.\n\nDeberá recordar volver a renderizar README.Rmd periódicamente y, sobre todo, antes del lanzamiento. La mejor función para usar para esto es devtools::build_readme(), porque se garantiza que renderizará README.Rmd con el código fuente actual de su paquete.\nEl ecosistema devtools intenta ayudarle a mantener actualizado README.Rmd de dos maneras:\n\n\nSi su paquete también es un repositorio de Git, use_readme_rmd() agrega automáticamente el siguiente gancho de confirmación previa:\n#!/bin/bash\nif [[ README.Rmd -nt README.md ]]; then\n  echo \"README.md is out of date; please re-knit README.Rmd\"\n  exit 1\nfi \nEsto evita un git commit si README.Rmd se modificó más recientemente que README.md. Si el gancho impide una confirmación que realmente desea realizar, puede anularla con git commit --no-verify. Tenga en cuenta que los enlaces de confirmación de Git no se almacenan en el repositorio, por lo que este enlace debe agregarse a cualquier clon nuevo. Por ejemplo, podría volver a ejecutar usethis::use_readme_rmd() y descartar los cambios en README.Rmd.\n\nLa lista de verificación de lanzamiento colocada por usethis::use_release_issue() incluye un recordatorio para llamar a devtools::build_readme().",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Otros archivos markdown</span>"
    ]
  },
  {
    "objectID": "other-markdown.html#sec-news",
    "href": "other-markdown.html#sec-news",
    "title": "18  Otros archivos markdown",
    "section": "\n18.2 NEWS\n",
    "text": "18.2 NEWS\n\nEl archivo “README” está dirigido a nuevos usuarios, mientras que el archivo “NEWS” está dirigido a usuarios existentes: debe enumerar todos los cambios en cada versión que un usuario podría notar o sobre los que desearía obtener más información. Al igual que con README, es una convención bien establecida para que el software de código abierto tenga un archivo NEWS, que a veces también se denomina registro de cambios.\nAl igual que con README, las herramientas base R no requieren que NEWS sea un archivo Markdown, pero sí lo permite y es nuestra fuerte preferencia. Es agradable leer un archivo NEWS.md en GitHub, en su sitio pkgdown, y se puede acceder a él desde la página de inicio de CRAN de su paquete. Demostramos esto nuevamente con dplyr:\n\n\nNEWS.md en el repositorio de GitHub de dplyr:\n\nhttps://github.com/tidyverse/dplyr/blob/main/NEWS.md\n\n\n\nEn CRAN, si libera su paquete allí.\n\n\nhttps://cran.r-project.org/web/packages/dplyr/index.html\nObserve el hipervínculo “NOTICIAS” en “Materiales”.\n\n\n\n\nEn el sitio de su paquete, disponible como “Registro de cambios” en el menú desplegable “Noticias” en la barra de navegación principal:\n\nhttps://dplyr.tidyverse.org/news/index.html\n\n\n\nPuede utilizar usethis::use_news_md() para iniciar el archivo NEWS.md; Muchas otras funciones relacionadas con el ciclo de vida y el lanzamiento en el ecosistema devtools realizarán los cambios apropiados en NEWS.md a medida que su paquete evolucione.\nAquí hay un archivo hipotético NEWS.md:Puede utilizar usethis::use_news_md() para iniciar el archivo NEWS.md; Muchas otras funciones relacionadas con el ciclo de vida y el lanzamiento en el ecosistema devtools realizarán los cambios apropiados en NEWS.md a medida que su paquete evolucione.\nAquí hay un archivo hipotético NEWS.md:\n# foofy (versión de desarrollo)\n\n* Mejor mensaje de error al ranurar un grobble no válido (#206).\n\n# foofy 1.0.0\n\n## Cambios principales\n\n* ¡Ahora puede funcionar con todos los grobbles ranurables!\n\n## Mejoras menores y correcciones de errores\n\n*  La impresión de scrobbles ya no produce errores (@githubusername, #100).\n\n*  Los Wibbles ahora son un 55 % menos jibbly (#200).\nEl ejemplo anterior demuestra algunos principios de organización para NEWS.md:\n\nUtilice un encabezado de nivel superior para cada versión: por ejemplo, # algún paquete 1.0.0. La versión más reciente debería ir en la parte superior. Normalmente, la entrada superior en NEWS.md de su paquete fuente dirá # algún paquete (versión de desarrollo).2\n\nCada cambio debe formar parte de una lista con viñetas. Si tiene muchos cambios, es posible que desee dividirlos usando subtítulos, ## Cambios importantes, ## Corrección de errores, etc.\nPor lo general, nos atenemos a una lista simple hasta que nos acercamos al lanzamiento, momento en el que nos organizamos en secciones y refinamos el texto. Es difícil saber de antemano exactamente qué secciones necesitará. La lista de verificación de lanzamiento colocada por usethis::use_release_issue() incluye un recordatorio para pulir el archivo NEWS.md. En esa fase, puede ser útil recordar que NEWS.md es un registro de cambios de cara al usuario, a diferencia de, por ejemplo, los mensajes de confirmación, que están de cara al desarrollador.\n\nSi un elemento está relacionado con un problema en GitHub, incluya el número del problema entre paréntesis, por ejemplo, (#​10). Si un elemento está relacionado con una solicitud de extracción, incluya el número de la solicitud de extracción y el autor, por ejemplo, (#​101, @hadley). Esto ayuda a un lector interesado a encontrar contexto relevante en GitHub y, en su sitio pkgdown, estos números de problemas y solicitudes de extracción y nombres de usuario serán hipervínculos. Generalmente omitimos el nombre de usuario si el colaborador ya está registrado en DESCRIPTION.\n\nEl principal desafío con NEWS.md es adquirir el hábito de notar cualquier cambio visible para el usuario cuando lo realiza. Es especialmente fácil olvidar esto al aceptar contribuciones externas. Antes del lanzamiento, puede resultar útil utilizar las herramientas de control de versiones para comparar el origen de la versión candidata con la versión anterior. Esto a menudo muestra elementos de NEWS que faltan.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Otros archivos markdown</span>"
    ]
  },
  {
    "objectID": "other-markdown.html#footnotes",
    "href": "other-markdown.html#footnotes",
    "title": "18  Otros archivos markdown",
    "section": "",
    "text": "Si realmente no tiene sentido incluir fragmentos de código ejecutable, usethis::use_readme_md() es similar, excepto que le proporciona un archivo README.md básico.↩︎\npkgdown admite algunas otras opciones de redacción para estos títulos; consulte más información en https://pkgdown.r-lib.org/reference/build_news.html.↩︎",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Otros archivos markdown</span>"
    ]
  },
  {
    "objectID": "website.html",
    "href": "website.html",
    "title": "19  Sitio web",
    "section": "",
    "text": "19.1 Iniciar un sitio\nHasta este punto, hemos analizado muchas formas de documentar su paquete:\n¿No sería divino si todo eso de alguna manera se reuniera en un hermoso sitio web para su paquete? El paquete pkgdown está destinado a proporcionar exactamente esta magia y ese es el tema de este capítulo.\nSuponiendo que su paquete tiene una estructura válida, pkgdown debería poder crear un sitio web para él. Obviamente, ese sitio web será más sustancial si su paquete tiene más elementos de documentación enumerados anteriormente. Pero algo razonable debería suceder con cualquier paquete R válido.\nusethis::use_pkgdown() es una función que se ejecuta una vez y realiza la configuración inicial mínima necesaria para comenzar a usar pkgdown:\nusethis::use_pkgdown()\n#&gt; ✔ Setting active project to '/tmp/RtmpAa7sYn/mypackage'\n#&gt; ✔ Adding '^_pkgdown\\\\.yml$', '^docs$', '^pkgdown$' to '.Rbuildignore'\n#&gt; ✔ Adding 'docs' to '.gitignore'\n#&gt; ✔ Writing '_pkgdown.yml'\n#&gt; • Edit '_pkgdown.yml'\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\nEsto es lo que hace use_pkgdown():\npkgdown::build_site() es una función que llamará repetidamente para volver a representar su sitio localmente. En un paquete extremadamente básico, verá algo como esto:\npkgdown::build_site()\n#&gt; ✔ Setting active project to '/tmp/RtmpAa7sYn/mypackage'\n#&gt; ── Installing package mypackage into temporary library ─────────────\n#&gt; ── Building pkgdown site for package mypackage ─────────────────────────────────\n#&gt; Reading from: /tmp/RtmpAa7sYn/mypackage\n#&gt; Writing to: /tmp/RtmpAa7sYn/mypackage/docs\n#&gt; ── Initialising site ───────────────────────────────────────────────────────────\n#&gt; Copying\n#&gt; ../../../home/runner/work/_temp/renv/cache/v5/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/pkgdown/2.0.9/8bf1151ed1a48328d71b937e651117a6/pkgdown/BS5/assets/link.svg\n#&gt; and\n#&gt; ../../../home/runner/work/_temp/renv/cache/v5/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu/pkgdown/2.0.9/8bf1151ed1a48328d71b937e651117a6/pkgdown/BS5/assets/pkgdown.js\n#&gt; to link.svg and pkgdown.js\n#&gt; ── Building home ───────────────────────────────────────────────────────────────\n#&gt; Writing `authors.html`\n#&gt; Writing `404.html`\n#&gt; ── Building function reference ─────────────────────────────────────────────────\n#&gt; Writing `reference/index.html`\n#&gt; Writing sitemap.xml\n#&gt; ── Building search index ───────────────────────────────────────────────────────\n#&gt; ── Finished building pkgdown site for package mypackage ────────────────────────\n#&gt; ── Finished building pkgdown site for package mypackage ────────────\n#&gt; ✔ Setting active project to '&lt;no active project&gt;'\nIn an interactive session your newly rendered site should appear in your default web browser.\nPuede buscar en el directorio local docs/ para ver los archivos que constituyen el sitio web de su paquete. Para navegar manualmente por el sitio, abra docs/index.html en su navegador preferido.\nEsto es casi todo lo que realmente necesitas saber sobre pkgdown. Sin duda, es un gran comienzo y, a medida que su paquete y sus ambiciones crezcan, el mejor lugar para obtener más información es el sitio web creado por pkgdown para el paquete pkgdown en sí: https://pkgdown.r-lib.org.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#iniciar-un-sitio",
    "href": "website.html#iniciar-un-sitio",
    "title": "19  Sitio web",
    "section": "",
    "text": "Tip\n\n\n\nEscuchamos que algunas personas posponen el “aprendizaje de pkgdown” porque creen que les supondrá mucho trabajo. ¡Pero finalmente ejecutan los dos comandos que mostramos a continuación y tienen un sitio web decente en menos de cinco minutos!\n\n\n\n\n\n\n\nCrea _pkgdown.yml, que es el archivo de configuración principal para pkgdown. En una sesión interactiva, se abrirá _pkgdown.yml para su inspección y edición. Pero no hay necesidad inmediata de cambiar o agregar nada aquí.\nAgrega varios patrones a .Rbuildignore, para evitar que archivos y directorios específicos de pkgdown se incluyan en su paquete.\nAgrega docs, el destino predeterminado para un sitio renderizado, a .gitignore. Esto es inofensivo para quienes no usan Git. Para aquellos que lo hacen, esto los habilita para nuestro estilo de vida recomendado, donde la fuente definitiva para su sitio pkgdown se crea y se implementa en otro lugar (probablemente a través de GitHub Actions and Pages; más sobre esto pronto). Esto significa que el sitio web renderizado en docs/ solo sirve como vista previa local.\n\n\n\n\n\n\n\n\n\n\n\nRStudio\n\n\n\nOtro buen gesto para construir su sitio es a través de Addins &gt; pkgdown &gt; Build pkgdown.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#sec-website-deployment",
    "href": "website.html#sec-website-deployment",
    "title": "19  Sitio web",
    "section": "\n19.2 Despliegue",
    "text": "19.2 Despliegue\nSu próxima tarea es desplegar su sitio pkgdown en algún lugar de la web, para que sus usuarios puedan visitarlo. El camino de menor resistencia se ve así:\n\nUtilice Git y aloje su paquete en GitHub. Las razones para hacer esto van mucho más allá de ofrecer un paquete de sitio web, pero este será uno de los principales beneficios de adoptar Git y GitHub, si no está seguro.\nUtilice GitHub Actions (GHA) para crear su sitio web, es decir, para ejecutar pkgdown::build_site(). GHA es una plataforma donde puedes configurar ciertas acciones para que sucedan automáticamente cuando ocurre algún evento. Lo usaremos para reconstruir su sitio web cada vez que acceda a GitHub.\nUtilice GitHub Pages para servir su sitio web, es decir, los archivos que ve debajo de docs/ localmente. GitHub Pages es un servicio de alojamiento de sitios web estáticos que crea un sitio a partir de archivos que se encuentran en un repositorio de GitHub.\n\nLos consejos para usar GitHub Action y Pages se implementan en la función usethis::use_pkgdown_github_pages(). No es una tarea especialmente difícil, pero hay varios pasos y sería fácil pasar por alto alguno o fallar. La salida de use_pkgdown_github_pages() debería verse así:\n\nusethis::use_pkgdown_github_pages()\n#&gt; ✔ Initializing empty, orphan 'gh-pages' branch in GitHub repo 'jane/mypackage'\n#&gt; ✔ GitHub Pages is publishing from:\n#&gt; • URL: 'https://jane.github.io/mypackage/'\n#&gt; • Branch: 'gh-pages'\n#&gt; • Path: '/'\n#&gt; ✔ Creating '.github/'\n#&gt; ✔ Adding '^\\\\.github$' to '.Rbuildignore'\n#&gt; ✔ Adding '*.html' to '.github/.gitignore'\n#&gt; ✔ Creating '.github/workflows/'\n#&gt; ✔ Saving 'r-lib/actions/examples/pkgdown.yaml@v2' to '.github/workflows/pkgdown.yaml'\n#&gt; • Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\n#&gt; ✔ Recording 'https://jane.github.io/mypackage/' as site's url in '_pkgdown.yml'\n#&gt; ✔ Adding 'https://jane.github.io/mypackage/' to URL field in DESCRIPTION\n#&gt; ✔ Setting 'https:/jane.github.io/mypackage/' as homepage of GitHub repo 'jane/mypackage'\n\nAl igual que use_pkgdown(), esta es una función que básicamente llamas una vez, cuando configuras un nuevo sitio. De hecho, lo primero que hace es llamar a use_pkgdown() (está bien si ya has llamado a use_pkgdown()), por lo que normalmente saltamos directamente a use_pkgdown_github_pages() cuando configuramos un sitio nuevo.\nVeamos qué hace realmente use_pkgdown_github_pages():\n\nInicializa una rama vacía y “huérfana” en tu repositorio de GitHub, denominada gh-pages (para “Páginas de GitHub”). La rama gh-pages solo vivirá en GitHub (no hay razón para buscarla en su computadora local) y representa un universo paralelo separado de la fuente real de su paquete. Los únicos archivos rastreados en gh-pages son aquellos que constituyen el sitio web de su paquete (los archivos que ve localmente debajo de docs/).\nActiva GitHub Pages para tu repositorio y le indica que proporcione un sitio web a partir de los archivos que se encuentran en la rama gh-pages.\nCopia el archivo de configuración para un flujo de trabajo de GHA que realiza pkgdown “compilado e implementado”. El archivo aparece en su paquete como .github/workflows/pkgdown.yaml. Si es necesario, se realizan algunas adiciones relacionadas a .gitignore y .Rbuildignore.\nAgrega la URL de su sitio como página de inicio de su repositorio de GitHub.\nAgrega la URL de su sitio a DESCRIPCIÓN y _pkgdown.yml. El comportamiento de enlace automático que hemos promocionado en otros lugares depende de que su paquete incluya su URL en estos dos lugares, por lo que esta es una configuración de alto valor.\n\nDespués de la ejecución exitosa de use_pkgdown_github_pages(), debería poder visitar su nuevo sitio en la URL que se muestra en el resultado anterior.1 Por defecto, la URL tiene esta forma general: https://USERNAME.github.io/REPONAME/.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#ahora-qué",
    "href": "website.html#ahora-qué",
    "title": "19  Sitio web",
    "section": "\n19.3 ¿Ahora qué?",
    "text": "19.3 ¿Ahora qué?\nPara un paquete típico, podría detenerse aquí, después de crear un sitio de pkgdown básico y organizar su reconstrucción e implementación con regularidad — y las personas que usen (o consideren usar) su paquete se beneficiarían enormemente. Todo lo que pase más allá de este punto es “un placer tenerlo”.\nEn general, recomendamos vignette(\"pkgdown\", package = \"pkgdown\") como un buen lugar para comenzar, si cree que quiere ir más allá de los valores predeterminados básicos.\nEn las secciones siguientes, destacamos algunas áreas que están conectadas con otros temas del libro o personalizaciones que son particularmente gratificantes.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#logotipo",
    "href": "website.html#logotipo",
    "title": "19  Sitio web",
    "section": "\n19.4 Logotipo",
    "text": "19.4 Logotipo\n¡Es divertido tener un logotipo de paquete! En la comunidad R, tenemos una fuerte tradición de pegatinas hexagonales, por lo que puede ser bueno unirte con tu propio logotipo hexagonal. La usuaria de Keen R, Amelia McNamara, se hizo un vestido con tela con logotipo hexagonal personalizado y useR! 2018 presentó un espectacular muro de fotografías hexagonales.\nAquí hay algunos recursos para guiar sus esfuerzos de logotipo:\n\nLa convención es orientar el logo con un vértice en la parte superior e inferior, con lados verticales planos.\n\nSi cree que podría imprimir pegatinas, asegúrese de cumplir con el estándar de facto para el tamaño de las pegatinas. hexb.in es una fuente confiable para las dimensiones y también proporciona una lista de proveedores potenciales de pegatinas impresas.\n\n\n\n\n\n\n\nFigura 19.1: Dimensiones estándar de una pegatina hexagonal.\n\n\n\n\n\nEl paquete hexSticker te ayuda a crear tu logotipo desde la comodidad de R.\n\nUna vez que tenga su logotipo, la función usethis::use_logo() coloca una copia a escala adecuada del archivo de imagen en man/figures/logo.png y también proporciona un fragmento de descuento que se puede copiar y pegar para incluir su logotipo. en su README. pkgdown también descubrirá un logotipo colocado en la ubicación estándar y lo incorporará a su sitio.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#índice-de-referencia",
    "href": "website.html#índice-de-referencia",
    "title": "19  Sitio web",
    "section": "\n19.5 Índice de referencia",
    "text": "19.5 Índice de referencia\npkgdown crea una referencia de función en reference/ que incluye una página para cada tema de ayuda .Rd en man/. Esta es una de las primeras páginas que debes admirar en tu nuevo sitio. Al mirar a su alrededor, hay algunas cosas que considerar, que repasamos a continuación.\n\n19.5.1 Ejemplos renderizados\npkgdown ejecuta todos sus ejemplos (Sección 16.5) e inserta los resultados renderizados. Creemos que esto es una mejora fantástica con respecto a mostrar simplemente el código fuente. Esta vista de sus ejemplos puede resultar reveladora y, a menudo, notará cosas que desea agregar, omitir o cambiar. Si no está satisfecho con la apariencia de sus ejemplos, este es un buen momento para revisar técnicas para incluir código que se espera que dé error (Sección 16.5.3) o que solo se puede ejecutar bajo ciertas condiciones (Sección 16.5.4).\n\n19.5.2 Vinculación\nEstos temas de ayuda estarán vinculados desde muchas ubicaciones dentro y, potencialmente, más allá de su sitio pkgdown. De esto es de lo que estamos hablando en Sección 16.1.3 cuando recomendamos poner funciones entre corchetes al mencionarlas en un comentario de roxygen:\n\n#' Soy un gran admirador de [estaduncion()] en mi paquete. I\n#' también tengo algo que decir sobre [otropqt::otrafuncion()]\n#' en el paquete de otra persona.\n\nEn los sitios de pkgdown, esas funciones entre corchetes se convierten en hipervínculos a las páginas relevantes de su sitio de pkgdown. Esto es automático dentro de su paquete. Pero los enlaces entrantes de paquetes de otras personas (y sitios web, etc.) requieren dos cosas2:\n\n\nEl campo URL de su archivo DESCRIPTION debe incluir la URL de su sitio pkgdown (preferiblemente seguida de la URL de su repositorio de GitHub):\nURL: https://dplyr.tidyverse.org, https://github.com/tidyverse/dplyr\n\n\nSu archivo _pkgdown.yml debe incluir la URL de su sitio:\nURL: https://dplyr.tidyverse.org\n\n\ndevtools aprovecha cada oportunidad que tiene para realizar este tipo de configuración por usted. Pero si elige hacer las cosas manualmente, esto es algo que podría pasar por alto. Un recurso general sobre el enlace automático en pkgdown es vignette(\"linking\", package = \"pkgdown\").\n\n19.5.3 Organización del índice\nDe forma predeterminada, el índice de referencia es solo una lista de funciones ordenada alfabéticamente. Para paquetes con más de un puñado de funciones, a menudo vale la pena seleccionar el índice y organizar las funciones en grupos. Por ejemplo, dplyr utiliza esta técnica: https://dplyr.tidyverse.org/reference/index.html.\nEsto se logra proporcionando un campo de reference en _pkgdown.yml. Aquí hay un extracto redactado del archivo _pkgdown.yml de dplyr que le da una idea de lo que implica:\nreference:\n- title: Data frame verbs\n\n- subtitle: Rows\n  desc: &gt;\n    Verbs that principally operate on rows.\n  contents:\n  - arrange\n  - distinct\n  ...\n\n- subtitle: Columns\n  desc: &gt;\n    Verbs that principally operate on columns.\n  contents:\n  - glimpse\n  - mutate\n  ...\n\n- title: Vector functions\n  desc: &gt;\n    Unlike other dplyr functions, these functions work on individual vectors,\n    not data frames.\n  contents:\n  - between\n  - case_match\n  ...\n\n- title: Built in datasets\n  contents:\n  - band_members\n  - starwars\n  - storms\n  ...\n\n- title: Superseded\n  desc: &gt;\n    Superseded functions have been replaced by new approaches that we believe\n    to be superior, but we don't want to force you to change until you're\n    ready, so the existing functions will stay around for several years.\n  contents:\n  - sample_frac\n  - top_n\n  ...\nPara obtener más información, consulte ?pkgdown::build_reference.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#viñetas-y-artículos",
    "href": "website.html#viñetas-y-artículos",
    "title": "19  Sitio web",
    "section": "\n19.6 Viñetas y artículos",
    "text": "19.6 Viñetas y artículos\nCapítulo 17 trata sobre viñetas, que son guías detalladas para un paquete. Ofrecen varias oportunidades más allá de lo que es posible en la documentación de funciones. Por ejemplo, tienes mucho más control sobre la integración de la prosa y el código y sobre la presentación del código en sí; por ejemplo, el código puede ejecutarse pero no verse, verse pero no ejecutarse, etc. Es mucho más fácil crear la experiencia de lectura que mejor prepare a sus usuarios para el uso auténtico de su paquete.\nLas viñetas de un paquete aparecen, en formato renderizado, en su sitio web, en el menú desplegable Articles. “Viñeta” parece un término técnico que no esperamos que todos los usuarios de R conozcan, razón por la cual pkgdown utiliza el término “artículos” aquí. Para ser claros, el menú Articles enumera las viñetas oficiales de su paquete (las que están incluidas en su paquete) y, opcionalmente, otros artículos que no son viñetas (Sección 17.4.1), que solo están disponibles en el sitio web. .\n\n19.6.1 Vinculación\nAl igual que la documentación de funciones, las viñetas también pueden ser el objetivo de enlaces entrantes automáticos desde dentro de su paquete y, potencialmente, más allá. Hemos hablado de esto en otra parte del libro. En Sección 16.1.3, introdujimos la idea de hacer referencia a una viñeta con una llamada en línea como vignette(\"some-topic\"). La razón detrás de esta sintaxis es que el código se puede literalmente copiar, pegar y ejecutar para ver la viñeta local. Por tanto, “funciona” en cualquier contexto, incluso sin enlaces automáticos. Pero, en contextos donde la maquinaria de enlace automático está disponible, sabe buscar esta sintaxis exacta y convertirla en un hipervínculo a la viñeta asociada, dentro de un sitio pkgdown.\nLa necesidad de especificar el paquete de host depende del contexto:\n\nvignette(\"some-topic\"): utilice este formulario en sus propios comentarios, viñetas y artículos de roxygen para hacer referencia a una viñeta en su paquete. El paquete de host está implícito.\nvignette(\"some-topic\", package = \"somepackage\"): Utilice esta forma para hacer referencia a una viñeta en algún otro paquete. El paquete de host debe ser explícito.\n\nTenga en cuenta que esta abreviatura no funciona para vincular a artículos que no son viñetas. Dado que la sintaxis se apoya tanto en la función vignette(), sería demasiado confuso, es decir, evaluar el código en la consola fallaría porque R no podrá encontrar dicha viñeta. Los artículos que no sean viñetas deben vincularse como cualquier otra URL.\nCuando haga referencia a una función en su paquete, en sus viñetas y artículos, asegúrese de ponerla entre comillas invertidas e incluir paréntesis. Califica funciones de otros paquetes con su espacio de nombres. A continuación se muestra un ejemplo de prosa en una de sus propias viñetas o artículos:\nSoy un gran admirador de `thisfunction()` en mi paquete. yo también tengo algo que\ndecir sobre `otherpkg::otherfunction()` en el paquete de otra persona.\nRecuerde que los enlaces entrantes automáticos de paquetes de otras personas (y sitios web, etc.) requieren que su paquete anuncie la URL de su sitio web en DESCRIPTION y _pkgdown.yaml, según lo configurado por usethis:: use_pkgdown_github_pages() y como se describe en Sección 19.5.2.\n\n19.6.2 Organización del índice\nAl igual que con el índice de referencia, la lista predeterminada de los artículos (definidos en sentido amplio) en un paquete es alfabética. Pero si su paquete tiene varios artículos, puede valer la pena brindarle una organización adicional. Por ejemplo, puede presentar los artículos dirigidos al usuario típico y colocar aquellos destinados a usuarios avanzados o desarrolladores detrás de “Más artículos …”. Puede obtener más información sobre esto en ?pkgdown::build_articles.\n\n19.6.3 Artículos que no son viñetas\nEn general, Capítulo 17 es nuestra principal fuente de consejos sobre cómo abordar las viñetas y eso también incluye cierta cobertura de artículos que no son viñetas (Sección 17.4.1). Aquí revisamos algunas razones para utilizar un artículo que no sea una viñeta y damos algunos ejemplos.\nUn artículo es moralmente como una viñeta (por ejemplo, cuenta una historia que involucra múltiples funciones y está escrita con R Markdown), excepto que no se envía con el paquete. usethis::use_article() es la forma más sencilla de crear un artículo. La razón principal para utilizar un artículo es cuando desea mostrar código que es imposible o muy doloroso de incluir en una viñeta o ejemplo oficial. Posibles causas fundamentales de este dolor:\n\n\nUso de un paquete del que no desea depender formalmente. En viñetas y ejemplos, está prohibido mostrar su paquete funcionando con un paquete que no incluye en DESCRIPTION, por ejemplo, en Imports o Suggests.\nHay un ejemplo detallado de esto en Sección 11.7.2, que presenta un artículo readxl que utiliza el metapaquete tidyverse. La idea clave es enumerar dicha dependencia en el campo Configuración/Necesidades/sitio web de DESCRIPTION. Esto mantiene a tidyverse fuera de las dependencias de readxl, pero garantiza que se instale cuando se crea el sitio web.\n\n\nCódigo que requiere autenticación o acceso a activos, herramientas o secretos específicos que no están disponibles en CRAN.\nEl paquete googledrive no tiene viñetas verdaderas, solo artículos que no son viñetas, porque es esencialmente imposible demostrar su uso sin autenticación. Es posible acceder a variables de entorno seguras en GitHub Actions, donde se crea e implementa el sitio pkgdown, pero esto es imposible de hacer en CRAN.\n\n\nContenido que involucra muchas cifras, lo que hace que su paquete choque con las limitaciones de tamaño de CRAN.\nEl paquete ggplot2 presenta varias preguntas frecuentes como artículos por este motivo.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#modo-de-desarrollo",
    "href": "website.html#modo-de-desarrollo",
    "title": "19  Sitio web",
    "section": "\n19.7 Modo de desarrollo",
    "text": "19.7 Modo de desarrollo\nCada sitio de pkgdown tiene un llamado modo de desarrollo, que se puede especificar a través del campo development en _pkgdown.yml. Si no se especifica, el valor predeterminado es “mode: release”, lo que da como resultado un único sitio pkgdown. A pesar del nombre, este sitio único refleja el estado del paquete fuente actual, que podría ser un estado publicado o un estado de desarrollo. El siguiente diagrama muestra la evolución de un paquete hipotético que está en CRAN y que tiene un sitio pkgdown en modo “release”.\n...\n |\n V\nTweaks before release     v0.1.9000\n |\n V\nIncrement version number  v0.2.0     &lt;-- install.packages() selecciona esta\n |\n V\nIncrement version number  v0.2.9000  \n |\n V\nImprove error message     v0.2.9000  &lt;-- site documenta esta\n |\n V\n...\nLos usuarios que instalan desde CRAN obtienen la versión 0.2.0. Pero el sitio pkgdown se construye a partir de la versión de desarrollo del paquete.\nEsto crea la posibilidad de que los usuarios lean sobre alguna característica nueva en el sitio web que no está presente en la versión del paquete que han instalado con install.packages(). Descubrimos que la simplicidad de esta configuración supera las desventajas, hasta que un paquete tiene una base de usuarios amplia, es decir, muchos usuarios de distintos niveles de sofisticación. Probablemente sea seguro permanecer en el modo “liberar” hasta que escuche a un usuario confundido.\nLos paquetes con una base de usuarios sustancial deben utilizar el modo de desarrollo “auto”:\ndevelopment:\n  mode: auto\nEsto indica a pkgdown que genere un sitio de nivel superior a partir de la versión publicada y que documente la versión de desarrollo en un subdirectorio dev/. Revisamos el mismo paquete hipotético que el anterior, pero asumiendo que el sitio pkdown está en modo “auto”.\n...\n |\n V\nTweaks before release     v0.1.9000\n |\n V\nIncrement version number  v0.2.0     &lt;-- install.packages() selecciona esta\n |                                       main/ site documenta esta\n V\nIncrement version number  v0.2.9000  \n |\n V\nImprove error message     v0.2.9000  &lt;-- dev/ site documenta esta\n |\n V\n...\nTodos los paquetes principales de tidyverse utilizan el modo “auto”. Por ejemplo, considere el sitio web del paquete readr:\n\nreadr.tidyverse.org documenta la versión publicada, es decir, lo que ofrece install.packages(\"readr\").\nreadr.tidyverse.org/dev/ documenta la versión de desarrollo, es decir, lo que ofrece install_github(\"tidyverse/readr\").\n\nSe recomienda el modo de desarrollo automático para paquetes con una amplia base de usuarios, porque maximiza la posibilidad de que un usuario lea documentación basada en web que refleje la versión del paquete que está instalada localmente.",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "website.html#footnotes",
    "href": "website.html#footnotes",
    "title": "19  Sitio web",
    "section": "",
    "text": "A veces hay un pequeño retraso, así que espere un par de minutos para implementarlo.↩︎\nOtro requisito previo es que su paquete haya sido publicado en CRAN, porque la maquinaria de enlace automático tiene que buscar la DESCRIPTION en alguna parte. Es posible permitir que los paquetes instalados localmente se vinculen entre sí, lo cual se describe en vignette(\"linking\", package = \"pkgdown\").↩︎",
    "crumbs": [
      "Documentación",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Sitio web</span>"
    ]
  },
  {
    "objectID": "software-development-practices.html",
    "href": "software-development-practices.html",
    "title": "20  Prácticas de desarrollo de software",
    "section": "",
    "text": "20.1 Git y GitHub\nEn esta última parte del libro, nos alejamos para considerar prácticas de desarrollo que pueden hacerlo más productivo y elevar la calidad de su trabajo. Aquí discutiremos el uso del control de versiones y la integración continua. En Capítulo 21 analizamos cómo varía la naturaleza del mantenimiento del paquete a lo largo del ciclo de vida de un paquete.\nNotarás que recomendamos utilizar ciertas herramientas:\nSe podría pensar que estas herramientas de estilo profesional son excesivas para alguien que no se gana la vida desarrollando software. Si bien no recomendamos obligarse a hacer todo lo anterior el primer día de su primer proyecto de “hola mundo”, en realidad creemos que estas herramientas son ampliamente aplicables para el desarrollo de paquetes R.\nLa razón principal es que estas herramientas hacen que sea mucho más fácil hacer lo correcto, por ejemplo, experimentar, documentar, probar, verificar y colaborar. Al adoptar un conjunto de herramientas compartido, los desarrolladores de paquetes nuevos y a tiempo parcial obtienen acceso a los mismos flujos de trabajo utilizados por los expertos. Esto requiere cierta fe e inversión inicial, pero creemos que vale la pena.\nGit es un sistema de control de versiones que se creó originalmente para coordinar el trabajo de un grupo global de desarrolladores que trabajan en el kernel de Linux. Git gestiona la evolución de un conjunto de archivos — llamado repositorio — de una manera altamente estructurada y recomendamos que cada paquete R también sea un repositorio Git (y también, probablemente, un proyecto RStudio; Sección 4.2).\nUn desarrollador independiente que trabaje en una sola computadora se beneficiará al adoptar el control de versiones. Pero, para la mayoría de nosotros, ese beneficio no es lo suficientemente grande como para compensar el dolor de instalar y usar Git. En nuestra opinión, para la mayoría de las personas, las ventajas de Git solo superan las desventajas una vez que das el paso adicional de conectar tu repositorio local a un host remoto como GitHub. El uso conjunto de Git y GitHub ofrece muchos beneficios que justifican con creces la curva de aprendizaje.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Prácticas de desarrollo de software</span>"
    ]
  },
  {
    "objectID": "software-development-practices.html#sec-sw-dev-practices-git-github",
    "href": "software-development-practices.html#sec-sw-dev-practices-git-github",
    "title": "20  Prácticas de desarrollo de software",
    "section": "",
    "text": "20.1.1 Práctica estándar\nEsta recomendación está bien alineada con las prácticas generales actuales en el desarrollo de software. A continuación se muestran algunos datos relevantes de la encuesta para desarrolladores de Stack Overflow de 2022, que se basa en aproximadamente 70.000 respuestas.\n\nEl 94% reporta usar Git. El segundo sistema de control de versiones más utilizado fue SVN, utilizado por el 5% de los encuestados.\nPara proyectos personales, el 87% de los encuestados afirma utilizar GitHub, seguido de GitLab (21%) y Bitbucket (11%). La clasificación es la misma, aunque menos sesgada para el trabajo profesional: GitHub sigue dominando con un 56%, seguido de GitLab (29%) y Bitbucket (18%).\n\nIncluso podemos aprender un poco sobre los hábitos de los desarrolladores de paquetes R, basándonos en las URL que se encuentran en los archivos DESCRIPTION de los paquetes CRAN. En marzo de 2023, hay alrededor de 19.000 paquetes en CRAN, de los cuales aproximadamente el 55 % tienen un campo “URL” no vacío (más de 10.000). De ellos, el 80% tiene una URL de GitHub (más de 8K), seguido de GitLab (poco más del 1%) y Bitbucket (alrededor del 0,5%).\nLa prevalencia de Git/GitHub, tanto dentro de la comunidad R como más allá, debería ayudarle a sentirse seguro de que la adopción tendrá beneficios tangibles. Además, la gran popularidad de estas herramientas significa que hay muchos recursos disponibles para aprender a usar Git y GitHub y para despegarse1.\nDos recursos específicos que abordan la intersección de Git/GitHub y el mundo R son el sitio web Happy Git y GitHub para el usuarioR y el artículo “Disculpe, ¿tiene ¿Un momento para hablar sobre el control de versiones?” (Bryan 2018).\nConcluimos esta sección con algunos ejemplos de por qué Git/GitHub puede ser valioso específicamente para el desarrollo de paquetes R:\n\nComunicación con los usuarios: los problemas de GitHub son adecuados para recibir informes de errores y solicitudes de funciones. A diferencia del correo electrónico enviado al responsable, otras personas pueden acceder a estas conversaciones y realizar búsquedas.\nColaboración: las solicitudes de extracción de GitHub son una forma muy sencilla para que los contribuyentes externos ayuden a corregir errores y agregar funciones.\nDistribución: Funciones como devtools::install_github(\"r-lib/devtools\") y pak::pak(\"r-lib/devtools\") permiten a las personas instalar fácilmente la versión de desarrollo de su paquete, según un repositorio de fuentes. De manera más general, cualquiera puede instalar su paquete desde cualquier referencia de Git válida, como una rama, un SHA específico, una solicitud de extracción o una etiqueta.\nSitio web: GitHub Pages es una de las formas más sencillas de ofrecer un sitio web para su paquete (Sección 19.2).\nIntegración continua: este es en realidad el tema de la siguiente sección, así que sigue leyendo para obtener más información.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Prácticas de desarrollo de software</span>"
    ]
  },
  {
    "objectID": "software-development-practices.html#sec-sw-dev-practices-ci",
    "href": "software-development-practices.html#sec-sw-dev-practices-ci",
    "title": "20  Prácticas de desarrollo de software",
    "section": "\n20.2 Integración continua",
    "text": "20.2 Integración continua\nComo dijimos en la introducción, la integración y el despliegue continuos se abrevian comúnmente como CI/CD o simplemente CI. Para el desarrollo de paquetes R, lo que esto significa en la práctica es:\n\nAlojas tu paquete fuente en una plataforma como GitHub. El punto clave es que el repositorio alojado proporciona la estructura formal para integrar el trabajo de múltiples contribuyentes. A veces, varios desarrolladores tienen permiso para enviar (así es como se administran los paquetes tidyverse y r-lib). En otros casos, sólo el responsable principal tiene permiso de inserción. En cualquiera de los modelos, los contribuyentes externos pueden proponer cambios mediante una solicitud de extracción.\nConfigura una o más tareas de desarrollo para que se ejecuten automáticamente cuando ocurren ciertos eventos en el repositorio alojado, como una solicitud de inserción o extracción. Por ejemplo, para un paquete R, es extremadamente valioso configurar una ejecución automática de R CMD check. Esto le ayuda a descubrir roturas rápidamente, cuando es más fácil de diagnosticar y reparar, y es de gran ayuda para evaluar si acepta una contribución externa.\n\nEn general, el uso del control de versiones alojado y la integración continua pueden hacer que el desarrollo avance más fluida y rápidamente.\nIncluso para un desarrollador en solitario, ejecutar “R CMD check” de forma remota, posiblemente en un par de sistemas operativos diferentes, es un arma poderosa contra el temido problema de “funciona en mi máquina”. Especialmente para los paquetes destinados a CRAN, el uso de CI disminuye la posibilidad de sorpresas desagradables justo antes del lanzamiento.\n\n20.2.1 Acciones de GitHub\nTLa forma más sencilla de empezar a utilizar CI es alojar su paquete en GitHub y utilizar su servicio complementario, GitHub Actions (GHA). Luego puede utilizar varias funciones de usethis para configurar los llamados flujos de trabajo GHA. usethis copia los archivos de configuración del flujo de trabajo de r-lib/actions, que es donde el equipo de tidyverse mantiene la infraestructura de GHA útil para la comunidad R.\n\n20.2.2 R CMD check a través de GHA\nSi solo usa CI para una cosa, debería ser ejecutar “R CMD check”. Si llama a usethis::use_github_action() sin argumentos, puede elegir entre algunos de los flujos de trabajo más útiles. Así es como se ve ese menú al momento de escribir este artículo:\n\n&gt; use_github_action()\nWhich action do you want to add? (0 to exit)\n(See &lt;https://github.com/r-lib/actions/tree/v2/examples&gt; for other options) \n\n1: check-standard: Run `R CMD check` on Linux, macOS, and Windows\n2: test-coverage: Compute test coverage and report to https://about.codecov.io\n3: pr-commands: Add /document and /style commands for pull requests\n\nSelection: \n\ncheck-standard es muy recomendable, especialmente para cualquier paquete que esté (o aspire a estar) en CRAN. Ejecuta R CMD check en algunas combinaciones de sistema operativo y versión R. Esto aumenta sus posibilidades de detectar rápidamente código que depende de las idiosincrasias de una plataforma específica, al tiempo que sigue siendo fácil hacer que el código sea más portátil.\nDespués de hacer esa selección, verá algunos mensajes como este:\n#&gt; ✔ Creating '.github/'\n#&gt; ✔ Adding '*.html' to '.github/.gitignore'\n#&gt; ✔ Creating '.github/workflows/'\n#&gt; ✔ Saving 'r-lib/actions/examples/check-standard.yaml@v2' to .github/workflows/R-CMD-check.yaml'\n#&gt; • Learn more at &lt;https://github.com/r-lib/actions/blob/v2/examples/README.md&gt;.\n#&gt; ✔ Adding R-CMD-check badge to 'README.md'\nLas cosas clave que suceden aquí son:\n\nSe escribe un nuevo archivo de flujo de trabajo de GHA en .github/workflows/R-CMD-check.yaml. Los flujos de trabajo de GHA se especifican mediante archivos YAML. El mensaje revela la fuente de YAML y ofrece un enlace para obtener más información.\nSe pueden realizar algunas adiciones útiles a varios archivos “ignorados”.\nSe agrega una insignia que informa el resultado de R CMD check a su archivo README, si se creó con usethis y tiene una insignia identificable “área de estacionamiento”. De lo contrario, se le proporcionará un texto que podrá copiar y pegar.\n\nConfirme estos cambios de archivos y envíelos a GitHub. Si visita la sección “Acciones” de su repositorio, debería ver que se ha iniciado una ejecución de flujo de trabajo de GHA. A su debido tiempo, su éxito (o fracaso) se informará allí, en su insignia README y en sus notificaciones de GitHub (dependiendo de su configuración personal).\n¡Felicidades! Su paquete ahora se beneficiará de controles aún más regulares.\n\n20.2.3 Otros usos de GHA\nComo lo sugiere el menú interactivo, usethis::use_github_action() le brinda acceso a flujos de trabajo prediseñados distintos de R CMD check. Además de las opciones destacadas, puede usarlo para configurar cualquiera de los flujos de trabajo de ejemplo en r-lib/actions pasando el nombre del flujo de trabajo. Por ejemplo:\n\n\nuse_github_action(\"test-coverage\") configura un flujo de trabajo para rastrear la cobertura de prueba de su paquete, como se describe en Sección 14.1.1.\n\nDado que GHA le permite ejecutar código arbitrario, hay muchas otras cosas para las que puede usarlo:\n\nConstruir el sitio web de su paquete e implementar el sitio renderizado en GitHub Pages, como se describe en Sección 19.2. Véase también ?usethis::use_pkgdown_github_pages().\nVolver a publicar el sitio web de un libro cada vez que se realiza un cambio en la fuente. (¡Como lo hacemos con este libro!).\n\nSi los flujos de trabajo de ejemplo no cubren su caso de uso exacto, también puede desarrollar su propio flujo de trabajo. Incluso en este caso, los flujos de trabajo de ejemplo suelen resultar útiles como inspiración. El repositorio r-lib/actions también contiene importantes bloques de construcción de nivel inferior, como acciones para instalar R o instalar todos los dependencias indicadas en un archivo DESCRIPTION.\n\n\n\n\nBryan, Jennifer. 2018. «Excuse Me, Do You Have a Moment to Talk About Version Control?» The American Statistician 72 (1): 20-27. https://doi.org/10.1080/00031305.2017.1399928.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Prácticas de desarrollo de software</span>"
    ]
  },
  {
    "objectID": "software-development-practices.html#footnotes",
    "href": "software-development-practices.html#footnotes",
    "title": "20  Prácticas de desarrollo de software",
    "section": "",
    "text": "Presentamos GitHub aquí, para el control de versiones alojadas, porque es lo que usamos y lo que tiene el mejor soporte en devtools. Sin embargo, todos los principios generales e incluso algunos detalles son válidos para plataformas alternativas, como Gitlab y Bitbucket.↩︎",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Prácticas de desarrollo de software</span>"
    ]
  },
  {
    "objectID": "lifecycle.html",
    "href": "lifecycle.html",
    "title": "21  Ciclo de vida",
    "section": "",
    "text": "21.1 Evolución del paquete\nEste capítulo trata sobre la gestión de la evolución de su paquete. La parte más complicada de gestionar el cambio es equilibrar los intereses de varias partes interesadas:\nEs imposible optimizar para todas estas personas, todo el tiempo y al mismo tiempo. Así que describiremos cómo pensamos acerca de varias compensaciones. Incluso si tus prioridades difieren de las del equipo de tidyverse, este capítulo debería ayudarte a identificar los problemas que deseas considerar.\nMuy pocos usuarios se quejan cuando un paquete gana funciones o se corrige un error. En cambio, hablaremos principalmente de los llamados cambios importantes, como eliminar una función o reducir las entradas aceptables para una función. En Sección 21.4, exploramos cómo determinar si algo es un cambio importante o, de manera más realista, medir dónde se encuentra en un espectro de “ruptura”. Aunque puede ser doloroso, a veces un cambio importante es beneficioso para la salud a largo plazo de un paquete (Sección 21.6).\nDado que el cambio es inevitable, lo mejor que puede hacer por sus usuarios es comunicarse con claridad y ayudarlos a adaptarse al cambio. Varias prácticas trabajan juntas para lograr esto:\nPrimero debemos establecer una definición funcional de lo que significa que su paquete cambie. Técnicamente, se podría decir que el paquete ha cambiado cada vez que cambia cualquier archivo en su fuente. Sin embargo, este nivel de pedantería no es muy útil. El incremento más pequeño de cambio que sea significativo probablemente sea una confirmación de Git. Esto representa un estado específico del paquete fuente del que se puede hablar, instalar, comparar, someter a R CMD check, revertir, etc. En realidad, este nivel de granularidad sólo interesa a los desarrolladores. Pero los estados del paquete accesibles a través del historial de Git son realmente útiles para el mantenedor, por lo que si necesita algún estímulo para ser más intencional con sus confirmaciones, que sea así.\nLa señal principal de un cambio significativo es incrementar el número de versión del paquete y publicarlo, para alguna definición de lanzamiento, como publicar en CRAN (Capítulo 22). Recuerde que esta importante pieza de metadatos se encuentra en el campo Version del archivo DESCRIPTION:\nSi visita la página de inicio de CRAN para usar esto, puede acceder a su historial a través de Downloads &gt; Old sources &gt; [use este archivo] (https://cran.r-project.org/src/contrib/Archive/usethis/) . Eso enlaza a una carpeta de paquetes (Sección 3.3), que refleja la fuente de usethis para cada versión lanzada en CRAN, presentada en Tabla 21.1:\nTabla 21.1: Versiones del paquete usethis.\n\n\n\n\nVersion\nDate\n\n\n\n1.0.0\n2017-10-22 17:36:29 UTC\n\n\n1.1.0\n2017-11-17 22:52:07 UTC\n\n\n1.2.0\n2018-01-19 18:23:54 UTC\n\n\n1.3.0\n2018-02-24 21:53:51 UTC\n\n\n1.4.0\n2018-08-14 12:10:02 UTC\n\n\n1.5.0\n2019-04-07 10:50:44 UTC\n\n\n1.5.1\n2019-07-04 11:00:05 UTC\n\n\n1.6.0\n2020-04-09 04:50:02 UTC\n\n\n1.6.1\n2020-04-29 05:50:02 UTC\n\n\n1.6.3\n2020-09-17 17:00:03 UTC\n\n\n2.0.0\n2020-12-10 09:00:02 UTC\n\n\n2.0.1\n2021-02-10 10:40:06 UTC\n\n\n2.1.0\n2021-10-16 23:30:02 UTC\n\n\n2.1.2\n2021-10-25 07:30:02 UTC\n\n\n2.1.3\n2021-10-27 15:00:02 UTC\n\n\n2.1.5\n2021-12-09 23:00:02 UTC\n\n\n2.1.6\n2022-05-25 20:50:02 UTC\n\n\n2.2.0\n2023-06-06 09:30:02 UTC\n\n\n2.2.1\n2023-06-23 23:50:02 UTC\n\n\n2.2.2\n2023-07-06 00:20:02 UTC\n\n\n2.2.3\n2024-02-19 16:00:02 UTC\n\n\n3.0.0\n2024-07-29 07:20:02 UTC\n\n\n3.1.0\n2024-11-26 10:20:02 UTC\nEste es el tipo de evolución de paquetes que abordaremos en este capítulo. En Sección 21.2, profundizaremos en el mundo de los números de versión de software, que es un tema más rico de lo que cabría esperar. R también tiene algunas reglas y herramientas específicas sobre los números de versión de los paquetes. Finalmente, explicaremos las convenciones que usamos para los números de versión de los paquetes tidyverse (Sección 21.3).\nPero primero, este es un buen momento para revisar un recurso que señalamos por primera vez en Sección 3.2, al presentar los diferentes estados de un paquete R. Recuerde que la organización (no oficial) “cran” en GitHub proporciona un historial de solo lectura de todos los paquetes CRAN. Por ejemplo, puede obtener una vista diferente de las versiones publicadas de usethis en https://github.com/cran/usethis/.\nEl archivo proporcionado por CRAN le permite descargar versiones anteriores de usethis como archivos .tar.gz, lo cual es útil si realmente desea tener en sus manos el código fuente de una versión anterior. Sin embargo, si solo desea verificar algo rápidamente sobre una versión o comparar dos versiones de usethis, el espejo de solo lectura de GitHub es mucho más útil. Cada confirmación en el historial de este repositorio representa una versión de CRAN, lo que facilita ver exactamente qué cambió: https://github.com/cran/usethis/commits/HEAD. Además, puede explorar el estado de todos los archivos fuente del paquete en cualquier versión específica, como use la versión inicial de este en la versión 1.0.0[^lifecycle-1].\nEsta información está técnicamente disponible en el repositorio donde realmente se desarrolla usethis (https://github.com/r-lib/usethis). BPero hay que trabajar mucho más para acercarse al nivel de las versiones de CRAN, en medio del desorden de los pequeños pasos incrementales en los que realmente se desarrolla el desarrollo. Estas tres vistas diferentes de la evolución de usethis son útiles para diferentes propósitos:",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-evolution",
    "href": "lifecycle.html#sec-lifecycle-evolution",
    "title": "21  Ciclo de vida",
    "section": "",
    "text": "Package: usethis\nTitle: Automate Package and Project Setup\nVersion: 2.1.6\n...\n\n\n\n\n\n\n\nhttps://cran.r-project.org/src/contrib/Archive/usethis/: los paquetes empaquetados oficiales de CRAN.\nhttps://github.com/cran/usethis/commits/HEAD: el espejo CRAN no oficial de solo lectura, que se obtiene al desempaquetar los empaquetados de CRAN.\nhttps://github.com/r-lib/usethis/commits/HEAD: el sitio de desarrollo oficial para usethis.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number",
    "href": "lifecycle.html#sec-lifecycle-version-number",
    "title": "21  Ciclo de vida",
    "section": "\n21.2 Número de versión del paquete",
    "text": "21.2 Número de versión del paquete\nFormalmente, una versión de un paquete R es una secuencia de al menos dos números enteros separados por . o -. Por ejemplo, “1.0” y “0.9.1-10” son versiones válidas, pero “1” y “1.0-devel” no lo son. Base R ofrece la función package_version() para analizar una cadena de versión de paquete en una clase S3 adecuada con el mismo nombre. Esta clase facilita hacer cosas como comparar versiones.\n\npackage_version(c(\"1.0\", \"0.9.1-10\"))\n#&gt; [1] '1.0'      '0.9.1.10'\nclass(package_version(\"1.0\"))\n#&gt; [1] \"package_version\" \"numeric_version\"\n\n# estas versiones no están permitidas para un paquete R\npackage_version(\"1\")\n#&gt; Error: invalid version specification '1'\npackage_version(\"1.0-devel\")\n#&gt; Error: invalid version specification '1.0-devel'\n\n# comparando versiones de paquetes\npackage_version(\"1.9\") == package_version(\"1.9.0\")\n#&gt; [1] TRUE\npackage_version(\"1.9\") &lt; package_version(\"1.9.2\")\n#&gt; [1] TRUE\npackage_version(c(\"1.9\", \"1.9.2\")) &lt; package_version(\"1.10\")\n#&gt; [1] TRUE TRUE\n\nLos últimos ejemplos anteriores dejan en claro que R considera que la versión “1.9” es igual a “1.9.0” y menor que “1.9.2”. Y tanto “1.9” como “1.9.2” son menores que “1.10”, que debería considerar como la versión “uno punto diez”, no “un punto uno cero”.\nSi no estás seguro de que la clase package_version sea realmente necesaria, consulta este ejemplo:\n\n\"2.0\" &gt; \"10.0\"\n#&gt; [1] TRUE\npackage_version(\"2.0\") &gt; package_version(\"10.0\")\n#&gt; [1] FALSE\n\nLa cadena 2.0 se considera mayor que la cadena 10.0, porque el carácter 2 viene después del carácter 1. Al analizar las cadenas de versión en objetos package_version adecuados, obtenemos la comparación correcta, es decir, que la versión 2.0 es menor que la versión 10.0.\nR ofrece este soporte para trabajar con versiones de paquetes, porque es necesario, por ejemplo, determinar si se cumplen las dependencias del paquete (Sección 9.6.1). Debajo del capó, esta herramienta se utiliza para hacer cumplir las versiones mínimas registradas así en DESCRIPTION:\nImports:\n    dplyr (&gt;= 1.0.0),\n    tidyr (&gt;= 1.1.0)\nEn su propio código, si necesita determinar qué versión de un paquete está instalada, use utils::packageVersion()1:\n\npackageVersion(\"usethis\")\n#&gt; [1] '2.2.3'\nstr(packageVersion(\"usethis\"))\n#&gt; Classes 'package_version', 'numeric_version'  hidden list of 1\n#&gt;  $ : int [1:3] 2 2 3\n\npackageVersion(\"usethis\") &gt; package_version(\"10.0\")\n#&gt; [1] FALSE\npackageVersion(\"usethis\") &gt; \"10.0\"\n#&gt; [1] FALSE\n\nEl valor de retorno de packageVersion() tiene la clase package_version y, por lo tanto, está listo para compararse con otros números de versión. Tenga en cuenta el último ejemplo en el que parece que estamos comparando un número de versión con una cadena. ¿Cómo podemos obtener el resultado correcto sin convertir explícitamente 10.0 a una versión de paquete? Resulta que esta conversión es automática siempre que uno de los comparadores tenga la clase package_version.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "href": "lifecycle.html#sec-lifecycle-version-number-tidyverse",
    "title": "21  Ciclo de vida",
    "section": "\n21.3 Convenciones de versión del paquete Tidyverse",
    "text": "21.3 Convenciones de versión del paquete Tidyverse\nR considera que 0.9.1-10 es una versión válida del paquete, pero nunca verás un número de versión como ese para un paquete tidyverse. Aquí está nuestro marco recomendado para administrar el número de versión del paquete:\n\nUtilice siempre . como separador, nunca -.\nUn número de versión publicada consta de tres números, &lt;principal&gt;.&lt;menor&gt;.&lt;parche&gt;. Para el número de versión “1.9.2”, “1” es el número principal, “9” es el número menor y “2” es el número de parche. Nunca utilice versiones como 1.0. Explique siempre los tres componentes, “1.0.0”.\n\nUn paquete en desarrollo tiene un cuarto componente: la versión de desarrollo. Esto debería comenzar en 9000. El número 9000 es arbitrario, pero proporciona una señal clara de que hay algo diferente en este número de versión. Hay dos razones para esta práctica: primero, la presencia de un cuarto componente hace que sea fácil saber si se trata de una versión publicada o en desarrollo. Además, el uso del cuarto lugar significa que no estás limitado a cuál será la próxima versión lanzada. 0.0.1, 0.1.0 y 1.0.0 son todos mayores que 0.0.0.9000.\nIncrementar la versión de desarrollo, p.e. de 9000 a 9001, si ha agregado una característica importante y usted (u otros) necesita poder detectar o requerir la presencia de esta característica. Por ejemplo, esto puede suceder cuando dos paquetes se desarrollan en conjunto. Generalmente esta es la única razón por la que nos molestamos en incrementar la versión de desarrollo. Esto hace que las versiones en desarrollo sean especiales y, en cierto sentido, degeneradas. Dado que no incrementamos el componente de desarrollo con cada confirmación de Git, el mismo número de versión del paquete se asocia con muchos estados diferentes del origen del paquete, entre versiones.\n\n\nEl consejo anterior está inspirado en parte en Semantic Versioning y en X.Org esquemas de control de versiones. Léalos si desea comprender más sobre los estándares de control de versiones utilizados por muchos proyectos de código abierto. Pero debemos subrayar que nuestras prácticas están inspiradas en estos esquemas y están algo menos reglamentadas. Finalmente, sepa que otros mantenedores siguen diferentes filosofías sobre cómo administrar el número de versión del paquete.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-definition",
    "title": "21  Ciclo de vida",
    "section": "\n21.4 Compatibilidad con versiones anteriores y cambios importantes",
    "text": "21.4 Compatibilidad con versiones anteriores y cambios importantes\nEl número de versión de su paquete siempre aumenta, pero es más que un simple contador incremental: la forma en que el número cambia con cada versión puede transmitir información sobre la naturaleza de los cambios. La transición de 0.3.1 a 0.3.2, que es una versión de parche, tiene una vibra muy diferente de la transición de 0.3.2 a 1.0.0, que es una versión importante. Un número de versión de paquete también puede transmitir información sobre dónde se encuentra el paquete en su ciclo de vida. Por ejemplo, la versión 1.0.0 a menudo indica que la interfaz pública de un paquete se considera estable.\n¿Cómo se decide qué tipo de lanzamiento realizar, es decir, qué componente(s) de la versión debería incrementar? Un concepto clave es si los cambios asociados son compatibles con versiones anteriores, lo que significa que el código preexistente seguirá “funcionando” con la nueva versión. Ponemos “trabajo” entre comillas, porque esta designación está abierta a cierta interpretación. Un intransigente podría entender que esto significa “el código funciona exactamente de la misma manera, en todos los contextos, para todas las entradas”. Una interpretación más pragmática es que “el código todavía funciona, pero podría producir un resultado diferente en algunos casos extremos”. Un cambio que no es compatible con versiones anteriores a menudo se describe como un cambio importante. Aquí vamos a hablar sobre cómo evaluar si un cambio se está rompiendo. En Sección 21.6 hablaremos sobre cómo decidir si un cambio importante vale la pena.\nEn la práctica, la compatibilidad con versiones anteriores no es una distinción clara. Es típico evaluar el impacto de un cambio desde varios ángulos:\n\nGrado de cambio en el comportamiento. El más extremo es convertir algo que solía ser posible en un error, es decir, imposible.\nCómo encajan los cambios en el diseño del paquete. Un cambio en una infraestructura de bajo nivel, como una utilidad a la que se llama en todas las funciones de cara al usuario, es más complicado que un cambio que sólo afecta a un parámetro de una única función.\nCuánto se ve afectado el uso existente. Esta es una combinación de cuántos de sus usuarios percibirán el cambio y cuántos usuarios existentes hay para empezar.\n\nA continuación se muestran algunos ejemplos concretos de cambios radicales:\n\nEliminar una función\nEliminar un argumento\nReducir el conjunto de entradas válidas a una función\n\nPor el contrario, normalmente no se consideran rotos:\n\nAgregar una función. Advertencia: existe una pequeña posibilidad de que esto introduzca un conflicto en el código de usuario.\nAgregar un argumento. Advertencia: esto podría fallar por algún uso, p. si un usuario confía en la coincidencia de argumentos basada en la posición. Esto también requiere cierto cuidado en una función que acepta “…”.\nIncrementar el conjunto de entradas válidas.\nCambiar el texto de un método de impresión o error. Advertencia: esto puede resultar problemático si otros paquetes dependen del suyo de manera frágil, como la creación de lógica o una prueba que se basa en un mensaje de error de su paquete.\nArreglando un error. Advertencia: Realmente puede suceder que los usuarios escriban código que “depende” de un error. A veces, dicho código tenía fallas desde el principio, pero el problema no se detectaba hasta que se solucionaba el error. Otras veces esto muestra código que usa su paquete de una manera inesperada, es decir, no es necesariamente incorrecto, pero tampoco es correcto.\n\nSi el razonamiento sobre el código fuera una forma confiable de evaluar cómo funcionará en la vida real, el mundo no tendría tanto software con errores. La mejor manera de evaluar las consecuencias de un cambio en su paquete es probarlo y ver qué sucede. Además de ejecutar sus propias pruebas, también puede ejecutar las pruebas de sus dependencias inversas y ver si el cambio propuesto rompe algo. El equipo de tidyverse tiene un conjunto bastante extenso de herramientas para ejecutar las llamadas comprobaciones de dependencia inversa (Sección 22.5), donde ejecutamos R CMD check en todos los paquetes que dependen del nuestro. A veces utilizamos esta infraestructura para estudiar el impacto de un cambio potencial, es decir, las comprobaciones de dependencia inversa se pueden utilizar para guiar el desarrollo, no solo como una comprobación previa al lanzamiento de último minuto. Esto lleva a otra definición, profundamente pragmática, de un cambio radical:\n\nUn cambio se interrumpe si hace que un paquete CRAN que anteriormente pasaba la “verificación R CMD” ahora falle Y el uso y comportamiento originales del paquete son correctos.\n\nObviamente, esta es una definición estrecha e incompleta de cambio radical, pero al menos es relativamente fácil obtener datos sólidos.\nEsperemos que hayamos dejado claro que la compatibilidad con versiones anteriores no siempre es una distinción clara. Pero es de esperar que también hayamos proporcionado muchos criterios concretos a considerar al pensar si un cambio podría alterar el código de otra persona.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-release-type",
    "href": "lifecycle.html#sec-lifecycle-release-type",
    "title": "21  Ciclo de vida",
    "section": "\n21.5 Lanzamiento mayor, menor o parche",
    "text": "21.5 Lanzamiento mayor, menor o parche\nRecuerde que un número de versión tendrá una de estas formas, si sigue las convenciones descritas en Sección 21.3:\n&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;        # released version\n&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;.&lt;dev&gt;  # in-development version\nSi la versión actual del paquete es 0.8.1.9000, estos son nuestros consejos sobre cómo elegir el número de versión para la próxima versión:\n\nIncrementar parche, p.e. 0.8.2 para una versión de parche: ha corregido errores, pero no ha agregado ninguna característica nueva significativa y no hay cambios importantes. Por ejemplo, si descubrimos un error que detiene el espectáculo poco después de un lanzamiento, realizaríamos un lanzamiento rápido de parche con la solución. La mayoría de las versiones tendrán un número de parche 0.\nIncremento menor, p.e. 0.9.0, para una versión menor. Una versión menor puede incluir correcciones de errores, nuevas funciones y cambios que sean compatibles con versiones anteriores2. Este es el tipo de liberación más común. Está perfectamente bien tener tantas versiones menores que necesites usar dos (¡o incluso tres!) dígitos, p. 1.17.0.\nIncremento mayor, p.e. 1.0.0, para una versión principal. Este es el momento más adecuado para realizar cambios que no sean compatibles con versiones anteriores y que probablemente afecten a muchos usuarios. La versión 1.0.0 tiene un significado especial y generalmente indica que su paquete tiene funciones completas con una API estable.\n\nLa decisión más complicada que probablemente enfrentará es si un cambio está lo suficientemente “roto” como para merecer una versión importante. Por ejemplo, si realiza un cambio incompatible con API en una parte de su código que rara vez se usa, puede que no tenga sentido aumentar el número principal. Pero si corrige un error del que dependen muchas personas (¡sucede!), esas personas lo sentirán como un cambio radical. Es posible que una corrección de errores de este tipo merezca una versión importante.\nNos centramos principalmente en los cambios importantes, pero no olvidemos que a veces también agregas funciones nuevas e interesantes a tu paquete. Desde una perspectiva de marketing, probablemente desee guardarlos para un lanzamiento importante, porque es más probable que sus usuarios conozcan las novedades al leer una publicación de blog o “NOTICIAS”.\nA continuación se muestran algunas publicaciones del blog de tidyverse que han acompañado a diferentes tipos de lanzamientos de paquetes:\n\nLanzamiento importante: dplyr 1.0.0, purrr 1.0.0, pkgdown 2.0.0, readr 2.0.0\nLanzamiento menor: stringr 1.5.0, ggplot2 3.4.0\nLanzamiento del parche: These are usually not considered worthy of a blog post.\n\n\n21.5.1 Mecánica de la versión del paquete\nSu paquete debería comenzar con el número de versión 0.0.0.9000. usethis::create_package() comienza con esta versión, de forma predeterminada.\nA partir de ese momento, puede usar usethis::use_version() para incrementar la versión del paquete. Cuando se llama de forma interactiva, sin argumentos, presenta un menú útil:\n\nusethis::use_version()\n#&gt; Current version is 0.1.\n#&gt; What should the new version be? (0 to exit) \n#&gt; \n#&gt; 1: major --&gt; 1.0\n#&gt; 2: minor --&gt; 0.2\n#&gt; 3: patch --&gt; 0.1.1\n#&gt; 4:   dev --&gt; 0.1.0.9000\n#&gt; \n#&gt; Selection: \n\nAdemás de incrementar Version en DESCRIPTION (Capítulo 9), use_version() también agrega un nuevo encabezado en NEWS.md (Sección 18.2).",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "href": "lifecycle.html#sec-lifecycle-breaking-change-pros-cons",
    "title": "21  Ciclo de vida",
    "section": "\n21.6 Pros y contras del cambio radical",
    "text": "21.6 Pros y contras del cambio radical\nLa gran diferencia entre las versiones principales y menores es si el código es compatible con versiones anteriores o no. En el mundo del software en general, la idea es que una versión importante indique a los usuarios que puede contener cambios importantes y que solo deben actualizar cuando tengan la capacidad de abordar cualquier problema que surja.\nLa realidad es un poco diferente en la comunidad R, debido a la forma en que la mayoría de los usuarios gestionan la instalación de paquetes. Si somos honestos, la mayoría de los usuarios de R no administran las versiones de los paquetes de una manera muy intencional. Dada la forma en que funcionan update.packages() e install.packages(), es bastante fácil actualizar un paquete a una nueva versión principal sin quererlo, especialmente para las dependencias del paquete de destino. Esto, a su vez, puede provocar una exposición inesperada a cambios importantes en el código que anteriormente funcionaba. Este malestar tiene implicaciones tanto para los usuarios como para los mantenedores.\nSi es importante proteger un producto de datos contra cambios en las dependencias de su paquete R, recomendamos el uso de una biblioteca de paquetes específica del proyecto. En particular, nos gusta implementar este enfoque utilizando el paquete renv. Esto respalda un estilo de vida en el que la biblioteca de paquetes predeterminada de un usuario se administra de la forma habitual, algo desordenada. Pero cualquier proyecto que tenga un requisito específico y más alto de reproducibilidad se gestiona con renv. Esto evita que las actualizaciones de paquetes activadas por el trabajo en el proyecto A rompan el código del proyecto B y también ayuda con la colaboración y la implementación.\nSospechamos que las bibliotecas y herramientas específicas de proyectos como renv están actualmente infrautilizadas en el mundo R. Es decir, muchos usuarios de R todavía usan una sola biblioteca de paquetes. Por lo tanto, los mantenedores de paquetes aún deben tener mucha precaución y cuidado cuando introducen cambios importantes, independientemente de lo que esté sucediendo con el número de versión. En Sección 21.7, describimos cómo los paquetes tidyverse abordan esto, respaldados por herramientas en el paquete de ciclo de vida.\nAl igual que con las dependencias (Sección 10.1), encontramos que el extremismo no es una postura muy productiva. La resistencia extrema a los cambios radicales supone un obstáculo importante para el desarrollo y el mantenimiento continuos. El código compatible con versiones anteriores tiende a ser más difícil de trabajar debido a la necesidad de mantener múltiples rutas para admitir la funcionalidad de versiones anteriores. Cuanto más se esfuerce por mantener la compatibilidad con versiones anteriores, más difícil será desarrollar nuevas funciones o corregir viejos errores. Esto, a su vez, puede desalentar la adopción por parte de nuevos usuarios y dificultar la contratación de nuevos contribuyentes. Por otro lado, si realiza cambios importantes constantemente, los usuarios se sentirán muy frustrados con su paquete y decidirán que están mejor sin él. Encuentra un punto medio feliz. Preocúpate por la compatibilidad con versiones anteriores, pero no dejes que eso te paralice.\nLa importancia de la compatibilidad con versiones anteriores es directamente proporcional a la cantidad de personas que utilizan su paquete: está intercambiando su tiempo y dolor por el de sus usuarios. Hay buenas razones para realizar cambios incompatibles con versiones anteriores. Una vez que haya decidido que es necesario, su principal prioridad es utilizar un proceso humano que respete a sus usuarios.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#sec-lifecycle-stages-and-package",
    "href": "lifecycle.html#sec-lifecycle-stages-and-package",
    "title": "21  Ciclo de vida",
    "section": "\n21.7 Etapas del ciclo de vida y herramientas de soporte",
    "text": "21.7 Etapas del ciclo de vida y herramientas de soporte\nEl enfoque del equipo de tidyverse para la evolución de paquetes se ha vuelto más estructurado y deliberado a lo largo de los años. Las herramientas y la documentación asociadas se encuentran en el paquete del ciclo de vida (lifecycle.r-lib.org). El enfoque se basa en dos componentes principales:\n\nEtapas del ciclo de vida, que se pueden aplicar en diferentes niveles, es decir, a un argumento o función individual o a un paquete completo.\nConvenciones y funciones a utilizar al realizar la transición de una función de una etapa del ciclo de vida a otra. El proceso de desaprobación es el que exige mayor cuidado.\n\nNo duplicaremos demasiada documentación del ciclo de vida aquí. En lugar de ello, destacamos los principios generales de la gestión del ciclo de vida y presentamos ejemplos específicos de “movimientos” exitosos del ciclo de vida.\n\n21.7.1 Etapas del ciclo de vida e insignias\n\n\n\n\n\n\n\nFigura 21.1: Las cuatro etapas principales del ciclo de vida de tidyverse: estable, obsoleta, reemplazada y experimental.\n\n\n\n\nLas cuatro etapas del ciclo de vida son:\n\nEstable. Esta es la etapa predeterminada e indica que los usuarios deben sentirse cómodos confiando en una función o paquete. Los cambios importantes deberían ser poco frecuentes y deberían ocurrir gradualmente, dando a los usuarios suficiente tiempo y orientación para adaptar su uso.\nExperimentales. Esto es apropiado cuando se introduce una función por primera vez y el mantenedor se reserva el derecho de cambiarla sin mucho proceso de desaprobación. Esta es la etapa implícita para cualquier paquete con una versión principal de “0”, es decir, que aún no ha tenido una versión “1.0.0”.\nObsoleto. Esto se aplica a la funcionalidad cuya eliminación está prevista. Inicialmente, todavía funciona, pero activa una advertencia de desactivación con información sobre las alternativas preferidas. Después de un período de tiempo adecuado y con un cambio de versión adecuado, estas funciones normalmente se eliminan.\nReemplazado. Esta es una versión más suave de obsoleta, donde la funcionalidad heredada se conserva como en una cápsula del tiempo. Las funciones reemplazadas reciben solo un mantenimiento mínimo, como correcciones de errores críticos.\n\nPuedes obtener mucho más detalle en vignette(\"stages\", package = \"lifecycle\").\nLa etapa del ciclo de vida suele comunicarse mediante una insignia. Si desea utilizar insignias de ciclo de vida, llame a usethis::use_lifecycle() para realizar una configuración única:\n\nusethis::use_lifecycle()\n#&gt; ✔ Adding 'lifecycle' to Imports field in DESCRIPTION\n#&gt; • Refer to functions with `lifecycle::fun()`\n#&gt; ✔ Adding '@importFrom lifecycle deprecated' to 'R/somepackage-package.R'\n#&gt; ✔ Writing 'NAMESPACE'\n#&gt; ✔ Creating 'man/figures/'\n#&gt; ✔ Copied SVG badges to 'man/figures/'\n#&gt; • Add badges in documentation topics by inserting one of:\n#&gt;   #' `r lifecycle::badge('experimental')`\n#&gt;   #' `r lifecycle::badge('superseded')`\n#&gt;   #' `r lifecycle::badge('deprecated')`\n\nEsto le permite utilizar insignias de ciclo de vida en temas de ayuda y funciones de ciclo de vida, como se describe en el resto de esta sección.\nPara una función, incluya la insignia en su bloque @description. Así es como indicamos que dplyr::top_n() está reemplazado:\n\n#' Select top (or bottom) n rows (by value)\n#'\n#' @description\n#' `r lifecycle::badge(\"superseded\")`\n#' `top_n()` has been superseded in favour of ...\n\nPara un argumento de función, incluya la insignia en la etiqueta @param. Así es como se documenta la obsolescencia de readr::write_file(path =):\n\n#' @param path `r lifecycle::badge(\"deprecated\")` Utilice el argumento `archivo`\n#'   instead.\n\nLlame a usethis::use_lifecycle_badge() si desea utilizar una insignia en README para indicar el ciclo de vida de un paquete completo (Sección 18.1).\nSi el ciclo de vida de un paquete es estable, no es realmente necesario utilizar una insignia, ya que se supone que esa es la etapa predeterminada. De manera similar, normalmente solo usamos una insignia para una función si su etapa difiere de la del paquete asociado y de la misma manera para un argumento y la función asociada.\n\n21.7.2 Desuso de una función\nSi va a eliminar o realizar cambios importantes en una función, normalmente es mejor hacerlo en fases. Desuso es un término general para la situación en la que algo se desaconseja explícitamente, pero aún no se ha eliminado. Se exploran varios escenarios de desaprobación en vignette(\"communicate\", package = \"lifecycle\"); Aquí solo vamos a cubrir la idea principal.\nLa función lifecycle::deprecate_warn() se puede usar dentro de una función para informar al usuario que está usando una característica obsoleta e, idealmente, para informarle sobre la alternativa preferida. En este ejemplo, la función plus3() está siendo reemplazada por add3():\n\n# función nueva\nadd3 &lt;- function(x, y, z) {\n  x + y + z\n}\n\n# función vieja\nplus3 &lt;- function(x, y, z) {\n  lifecycle::deprecate_warn(\"1.0.0\", \"plus3()\", \"add3()\")\n  add3(x, y, z)\n}\n\nplus3(1, 2, 3)\n#&gt; Warning: `plus3()` was deprecated in somepackage 1.0.0.\n#&gt; ℹ Please use `add3()` instead.\n#&gt; [1] 6\n\nEn este punto, un usuario que llama a plus3() ve una advertencia que explica que la función tiene un nuevo nombre, pero seguimos adelante y llamamos a add3() con sus entradas. El código preexistente todavía “funciona”. En alguna versión importante futura, plus3() podría eliminarse por completo.\nlifecycle::deprecate_warn() y sus amigos tienen algunas características que vale la pena destacar:\n\nEl mensaje de advertencia se crea a partir de entradas como “cuándo”, “qué”, “con” y “detalles”, lo que proporciona a las advertencias de obsolescencia una forma predecible en diferentes funciones, paquetes y tiempos. La intención es reducir la carga cognitiva de los usuarios que ya pueden estar algo estresados.\nDe forma predeterminada, solo se emite una advertencia específica una vez cada 8 horas, en un esfuerzo por causar la cantidad justa de molestia. El objetivo es ser lo suficientemente molesto como para motivar al usuario a actualizar su código antes de que la función o el argumento desaparezca, pero no tan molesto como para arrojar su computadora al mar. Cerca del final del proceso de desaprobación, el argumento “siempre” se puede establecer en “VERDADERO” para advertir en cada llamada.\nSi usa lifecycle::deprecate_soft() (en lugar de deprecate_warn()), solo se emite una advertencia si la persona que lo lee es la que realmente puede hacer algo al respecto, es decir, actualizar el código infractor. Si un usuario llama indirectamente a una función obsoleta, es decir, porque está usando un paquete que usa una función obsoleta, de forma predeterminada ese usuario no recibe una advertencia. (Pero el mantenedor del paquete culpable verá estas advertencias en los resultados de sus pruebas).\n\nAquí hay un cronograma hipotético para eliminar una función fun():\n\nVersión del paquete 1.5.0: fun() existe. La etapa del ciclo de vida del paquete es estable, como lo indica su número de versión posterior a 1.0.0 y, tal vez, una insignia a nivel de paquete. La etapa del ciclo de vida de fun() también es estable, por extensión, ya que no ha sido marcada específicamente como experimental.\n\nVersión del paquete 1.6.0: Comienza el proceso de desuso de fun(). Insertamos una insignia en su tema de ayuda:\n\n#' @description\n#' `r lifecycle::badge(\"deprecated\")`\n\nEn el cuerpo de fun(), agregamos una llamada a lifecycle::deprecate_warn() para informar a los usuarios sobre la situación. De lo contrario, fun() sigue funcionando como siempre.\n\nVersión del paquete 1.7.0 o 2.0.0: fun() se elimina. Si esto sucede en una versión menor o mayor dependerá del contexto, es decir, qué tan ampliamente se usa este paquete y función.\n\nSi está utilizando base R únicamente, las funciones .Deprecated() y .Defunct() son los sustitutos más cercanos de lifecycle::deprecate_warn() y sus amigas.\n\n21.7.3 Desuso de un argumento\nlifecycle::deprecate_warn() también es útil cuando se desaprueba un argumento. En este caso, también es útil utilizar lifecycle::deprecated() como valor predeterminado para el argumento obsoleto. Aquí continuamos con un ejemplo anterior, es decir, el cambio de ruta a archivo en readr::write_file():\n\nwrite_file &lt;- function(x,\n                       file,\n                       append = FALSE,\n                       path = deprecated()) {\n  if (is_present(path)) {\n    lifecycle::deprecate_warn(\"1.4.0\", \"write_file(path)\", \"write_file(file)\")\n    file &lt;- path\n  }\n  ...\n}\n\nEsto es lo que ve un usuario si usa el argumento obsoleto:\n\nreadr::write_file(\"hi\", path = tempfile(\"lifecycle-demo-\"))\n#&gt; Warning: The `path` argument of `write_file()` is deprecated as of readr\n#&gt; 1.4.0.\n#&gt; ℹ Please use the `file` argument instead.\n\nEl uso de deprecated() como predeterminado logra dos cosas. Primero, si el usuario lee la documentación, esto es una fuerte señal de que un argumento está obsoleto. Pero deprecated() también tiene beneficios para el mantenedor del paquete. Dentro de la función afectada, puede usar lifecycle::is_present() para determinar si el usuario ha especificado el argumento obsoleto y proceder en consecuencia, como se muestra arriba.\nSi está utilizando base R únicamente, la función missing() tiene una superposición sustancial con lifecycle::is_present(), aunque puede ser más complicado solucionar problemas relacionados con los valores predeterminados.\n\n21.7.4 Ayudantes de desuso\nA veces, una desaprobación afecta el código en varios lugares y es complicado incorporar la lógica completa en todas partes. En este caso, puede crear un asistente interno para centralizar la lógica de desaprobación.\nEsto sucedió en GoogleDrive, cuando cambiamos la forma de controlar la detalle del paquete. El diseño original permitía al usuario especificar esto en cada función, mediante el argumento verbose = TRUE/FALSE. Más tarde, decidimos que tenía más sentido utilizar una opción global para controlar la verbosidad a nivel de paquete. Este es un caso en el que (eventualmente) se elimina un argumento, pero afecta prácticamente a todas las funciones del paquete. Así es como se ve una función típica después de iniciar el proceso de desusar:\n\ndrive_publish &lt;- function(file, ..., verbose = deprecated()) {\n  warn_for_verbose(verbose)\n  # rest of the function ...\n}\n\nTenga en cuenta el uso de verbose = obsoleto(). Aquí hay una versión ligeramente simplificada de warn_for_verbose():\n\nwarn_for_verbose &lt;- function(verbose = TRUE,\n                             env = rlang::caller_env(),\n                             user_env = rlang::caller_env(2)) {\n  # This function is not meant to be called directly, so don't worry about its\n  # default of `verbose = TRUE`.\n  # In authentic, indirect usage of this helper, this picks up on whether\n  # `verbose` was present in the **user's** call to the calling function.\n  if (!lifecycle::is_present(verbose) || isTRUE(verbose)) {\n    return(invisible())\n  }\n\n  lifecycle::deprecate_warn(\n    when = \"2.0.0\",\n    what = I(\"The `verbose` argument\"),\n    details = c(\n      \"Set `options(googledrive_quiet = TRUE)` to suppress all googledrive messages.\",\n      \"For finer control, use `local_drive_quiet()` or `with_drive_quiet()`.\",\n      \"googledrive's `verbose` argument will be removed in the future.\"\n    ),\n    user_env = user_env\n  )\n  # only set the option during authentic, indirect usage\n  if (!identical(env, global_env())) {\n    local_drive_quiet(env = env)\n  }\n  invisible()\n}\n\nEl usuario llama a una función, como drive_publish(), que luego llama a warn_for_verbose(). Si el usuario deja verbose sin especificar o si solicita detallado = TRUE (comportamiento predeterminado), warn_for_verbose() no hace nada. Pero si solicitan explícitamente verbose = FALSE, lanzamos una advertencia con consejos sobre la forma preferida de suprimir los mensajes de Googledrive. También seguimos adelante y honramos sus deseos por el momento, a través de la llamada a googledrive::local_drive_quiet(). En la próxima versión principal, el argumento “detallado” se puede eliminar en todas partes y este asistente se puede eliminar.\n\n21.7.5 Cómo afrontar el cambio en una dependencia\n¿Qué sucede si desea utilizar la funcionalidad en una nueva versión de otro paquete? O la versión menos feliz: ¿qué pasa si los cambios en otro paquete van a romper el suyo? Hay algunos escenarios posibles, dependiendo de si se lanzó el otro paquete y de la experiencia que desea para sus usuarios. Comenzaremos con el caso simple y feliz de usar funciones recientemente disponibles en una dependencia.\nSi el otro paquete ya se lanzó, puede aumentar la versión mínima que declara en DESCRIPTION y usar la nueva funcionalidad incondicionalmente. Esto también significa que los usuarios que actualicen su paquete se verán obligados a actualizar el otro paquete, lo cual al menos debería considerar. Tenga en cuenta también que esto solo funciona para una dependencia en “Importaciones”. Si bien es una buena idea registrar una versión mínima para un paquete sugerido, generalmente no se aplica de la misma manera que para las “Importaciones”.\nSi no desea exigir a sus usuarios que actualicen este otro paquete, puede hacer que su paquete funcione tanto con versiones nuevas como antiguas. Esto significa que comprobará su versión en tiempo de ejecución y procederá en consecuencia. Aquí hay un bosquejo de cómo podría verse eso en el contexto de una función nueva o existente:\n\nyour_existing_function &lt;- function(..., cool_new_feature = FALSE) {\n  if (isTRUE(cool_new_feature) && packageVersion(\"otherpkg\") &lt; \"1.0.0\") {\n    message(\"otherpkg &gt;= 1.0.0 is needed for cool_new_feature\")\n    cool_new_feature &lt;- FALSE\n  }\n  # the rest of the function\n}\n\nyour_new_function &lt;- function(...) {\n  if (packageVersion(\"otherpkg\") &lt; \"1.0.0\") {\n    stop(\"otherpkg &gt;= 1.0.0 needed for this function.\")\n  }\n  # the rest of the function\n}\n\nAlternativamente, este también sería un excelente lugar para usar rlang::is_installed() y rlang::check_installed() con el argumento version (ver ejemplos de uso en Sección 11.5.1).\nEste enfoque también se puede adaptar si está respondiendo a cambios aún no publicados que llegarán pronto en una de sus dependencias. Es útil tener una versión de su paquete que funcione antes y después del cambio. Esto le permite liberar su paquete en cualquier momento, incluso antes que el otro paquete. A veces puedes refactorizar tu código para que funcione con cualquiera de las versiones del otro paquete, en cuyo caso no necesitas condicionar en absoluto la versión del otro paquete. Pero a veces es posible que necesites un código diferente para las dos versiones. Considere este ejemplo:\n\nyour_function &lt;- function(...) {\n  if (packageVersion(\"otherpkg\") &gt;= \"1.3.9000\") {\n    otherpkg::their_new_function()\n  } else {\n    otherpkg::their_old_function()\n  }\n  # the rest of the function\n}\n\nLa versión mínima hipotética de 1.3.9000 sugiere un caso en el que la versión de desarrollo de otherpkg ya tiene el cambio al que estás respondiendo, que es una función nueva en este caso. Suponiendo que their_new_function() no existe en la última versión de otherpkg, recibirá una nota de R CMD check indicando que ir_new_function() no existe en el espacio de nombres de otherpkg. Si envía una versión de este tipo a CRAN, puede explicar que lo hace por motivos de compatibilidad hacia atrás y hacia adelante con otros paquetes y es probable que queden satisfechos.\n\n21.7.6 Reemplazar una función\nSe reemplaza la última etapa del ciclo de vida de la que hablaremos. Esto es apropiado cuando siente que una función ya no es la solución preferida a un problema, pero tiene suficiente uso e historial como para no querer iniciar el proceso de eliminarla. Buenos ejemplos de esto son tidyr::spread() y tidyr::gather(). Esas funciones han sido reemplazadas por tidyr::pivot_wider() y tidyr::pivot_longer(). Pero algunos usuarios todavía prefieren las funciones más antiguas y es probable que se hayan utilizado mucho en proyectos que no están en desarrollo activo. Por lo tanto, spread() y gather() están marcados como reemplazados, no reciben ninguna innovación nueva, pero no corren riesgo de ser eliminados.\nUn fenómeno relacionado es cuando desea cambiar algún aspecto de un paquete, pero también desea brindarles a los usuarios existentes una forma de optar por el comportamiento heredado. La idea es proporcionar a los usuarios una curita que puedan aplicar para que el código antiguo funcione rápidamente, hasta que tengan el ancho de banda para realizar una actualización más exhaustiva (lo que, en algunos casos, es posible que nunca suceda). A continuación se muestran algunos ejemplos en los que se conservó el comportamiento heredado para los usuarios que optaron por participar:\n\nEn tidyr 1.0.0, la interfaz de tidyr::nest() y tidyr::unnest() cambió. El uso más auténtico se puede traducir a la nueva sintaxis, lo que tidyr hace automáticamente, además de transmitir la sintaxis moderna preferida mediante una advertencia. Pero la antigua interfaz sigue estando disponible a través de tidyr::nest_legacy() y tidyr::unnest_legacy(), que se marcaron como reemplazadas en el momento de su creación.\ndplyr 1.1.0 aprovecha un algoritmo mucho más rápido para grupos informáticos. Pero este método más rápido también ordena los grupos con respecto a la configuración regional C, mientras que anteriormente se usaba la configuración regional del sistema. La opción global dplyr.legacy_locale permite a un usuario solicitar explícitamente el comportamiento heredado.3\nLos paquetes tidyverse se han estandarizado en un enfoque común para la reparación de nombres, que se implementa en vctrs::vec_as_names(). El paquete vctrs también ofrece vctrs::vec_as_names_legacy(), lo que facilita la reparación de nombres con estrategias más antiguas utilizadas anteriormente en paquetes como tibble, tidyr y readxl.\nreadr 2.0.0 introdujo la llamada segunda edición, que marca el cambio a un backend proporcionado por el paquete vroom. Funciones como readr::with_edition(1, ...) y readr::local_edition(1) facilitan que un usuario solicite el comportamiento de la primera edición para un fragmento de código específico o para un script específico.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "lifecycle.html#footnotes",
    "href": "lifecycle.html#footnotes",
    "title": "21  Ciclo de vida",
    "section": "",
    "text": "Al igual que con package_version(), en el código del paquete, debes usar el formulario utils::packageVersion() y enumerar el paquete de utilidades en Imports.↩︎\nPara obtener una definición adecuadamente pragmática de “compatible con versiones anteriores”.↩︎\npuede obtener más información sobre el análisis que condujo a este cambio en https://github.com/tidyverse/tidyups/blob/main/006-dplyr-group-by-ordering.md.↩︎",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Ciclo de vida</span>"
    ]
  },
  {
    "objectID": "release.html",
    "href": "release.html",
    "title": "22  Subiendo a CRAN",
    "section": "",
    "text": "22.1 Decidir el tipo de lanzamiento\nHemos estado señalando inquietudes específicas de CRAN a lo largo del libro, en nuestro recorrido por las distintas partes de un paquete, como pruebas y ejemplos. En este capítulo, nos centramos en el proceso real de publicar un paquete en CRAN, por primera vez o como una actualización.\nLa expresión más concreta de nuestro proceso de lanzamiento es la lista de verificación producida por usethis::use_release_issue(), que abre una edición de GitHub que contiene una lista de tareas pendientes. Esta lista de verificación evoluciona constantemente y responde a algunas características del paquete, así que no se sorprenda si ve algo un poco diferente de lo que mostramos aquí. Las preocupaciones principales son bastante eternas y usaremos esta lista de verificación para ayudar a estructurar este capítulo.\nPero primero: tenga en cuenta que se arrepentirá profundamente si aborda la preparación de su paquete para CRAN como una actividad separada que realiza después de completar el desarrollo planificado para una versión. Este consejo es extremadamente relevante aquí:\nEn el contexto actual, interprete que esto significa que debe ejecutar R CMD check con regularidad, preferiblemente en múltiples plataformas, y abordar rápidamente cualquier problema que surja. Recuerde que nuestra forma preferida de hacer esto es a través de devtools::check() (Sección 4.5).\n¿Por qué querrías hacer algo que te resulta doloroso con más frecuencia? Porque conduce a menos dolor en general. Primero, resolver 5 problemas es más de 5 veces más difícil que resolver 1. Es desmoralizador verse bloqueado por varios errores y la posibilidad de que se produzcan interacciones desagradables entre ellos hace que cada uno de ellos sea más difícil de aislar y corregir. En segundo lugar, la retroalimentación rápida tiende a reducir el número total de errores. Una vez que aprenda alguna lección de la manera más difícil, es poco probable que cometa el mismo error docenas de veces en otras partes de su paquete. ¡Finalmente, la práctica hace la perfección! Con una mayor exposición, mejorará en la interpretación y respuesta a los problemas que surjan en R CMD check.\nOtra reacción natural es: ¿por qué no elimino este dolor por completo al no publicar mi paquete en CRAN? Para ciertos tipos de paquetes, esta puede ser la decisión correcta. Un ejemplo de ello es un paquete personal de funciones auxiliares. Otro ejemplo es un paquete que admite una organización específica, siempre que también tenga un método razonable para distribuir ese paquete a sus usuarios. La razón principal para tener su paquete en CRAN es darle mayor alcance. La gran mayoría de los usuarios de R sólo instalan paquetes de CRAN, ya sea por política personal o de la empresa o simplemente por falta de conocimiento sobre las alternativas. CRAN proporciona visibilidad, facilidad de instalación y un sello de autenticidad. El proceso de envío de CRAN puede ser frustrante, pero tiene muchas ventajas y este capítulo pretende hacerlo lo más sencillo posible.\nEl proceso de liberación que describimos aquí se utiliza mejor como una lista de verificación previa al vuelo, que complementa sus esfuerzos continuos para mantener su paquete pasando la R CMD check de manera limpia y compatible con CRAN. Hay dos grandes descubrimientos que a menudo surgen con el proceso de lanzamiento de CRAN:\nEstos son los pasos principales en el proceso de liberación:\nCuando llame a use_release_issue(), se le preguntará qué tipo de lanzamiento desea realizar.\n&gt; use_release_issue()\n✔ Setting active project to '/Users/jenny/rrr/usethis'\nCurrent version is 2.1.6.9000.\nWhat should the release version be? (0 to exit) \n\n1: major --&gt; 3.0.0\n2: minor --&gt; 2.2.0\n3: patch --&gt; 2.1.7\n\nSelection:\nLa pregunta inmediata parece bastante mecánica: ¿qué componente del número de versión desea incrementar? Pero recuerde que analizamos las diferencias sustanciales en los tipos de lanzamiento en Sección 21.5.\nEn nuestro flujo de trabajo, este número de versión planificada se registra en la edición de GitHub que contiene la lista de verificación de lanzamiento, pero en realidad no incrementamos la versión en DESCRIPTION hasta más adelante en el proceso (Sección 22.7). Sin embargo, es importante declarar el tipo de versión por adelantado, porque el proceso (y, por lo tanto, la lista de verificación) se ve diferente, por ejemplo, para una versión de parche versus una versión principal.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#sec-release-initial",
    "href": "release.html#sec-release-initial",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.2 Lanzamiento inicial de CRAN: consideraciones especiales",
    "text": "22.2 Lanzamiento inicial de CRAN: consideraciones especiales\nCada nuevo paquete recibe un mayor nivel de escrutinio por parte de CRAN. Además de las habituales comprobaciones automatizadas, los nuevos paquetes también son revisados por un humano, lo que inevitablemente introduce cierta subjetividad y aleatoriedad. Hay muchos paquetes en CRAN que no serían aceptados en su forma actual si se presentaran hoy como un paquete completamente nuevo. Esto no pretende desanimarte. Pero debe tener en cuenta que, sólo porque vea algo de práctica en un paquete establecido (o incluso en base R), no significa que pueda hacer lo mismo en su nuevo paquete.\nAfortunadamente, la comunidad mantiene listas de “errores” comunes para los nuevos paquetes. Si su paquete aún no está en CRAN, la lista de verificación comienza con una sección especial que refleja esta sabiduría colectiva reciente. Prestar atención a estos elementos de la lista de verificación ha mejorado drásticamente la tasa de éxito de nuestro equipo en los envíos iniciales.\nPrimer lanzamiento\n\nusethis::use_news_md()\nusethis::use_cran_comments()\nActualice (aspiracional) de las instrucciones de instalación en README\nRevisar Title: y Description:\nVerifique que todas las funciones exportadas tengan @returns y @examples\nCompruebe que Authors@R: incluya un titular de derechos de autor (rol ‘cph’)\nVerifique la licencia de los archivos incluidos\nRevisar https://github.com/DavisVaughan/extrachecks\n\nSi aún no tiene un archivo NEWS.md, le recomendamos que cree uno ahora con usethis::use_news_md(). Eventualmente querrás este archivo y esto anticipa el hecho de que la descripción de tu eventual versión de GitHub (Sección 22.9) se extrae de NEWS.md.\nusethis::use_cran_comments() inicia un archivo para contener los comentarios de envío de su paquete. Al principio es muy básico, por ejemplo:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* This is a new release.\nEn versiones posteriores, este archivo deja de tener sentido; por ejemplo, es donde informamos los resultados de las comprobaciones de dependencia inversa. Este no es un lugar para extenderse con largas explicaciones sobre su envío. En general, debería eliminar la necesidad de tales explicaciones, especialmente para una presentación inicial.\nRecomendamos encarecidamente que su paquete tenga un archivo README (Sección 18.1). Si es así, este es un buen momento para consultar las instrucciones de instalación que se proporcionan allí. Es posible que deba cambiar las instrucciones para instalarlo desde GitHub a instalarlo desde CRAN, en anticipación a la aceptación de su paquete.\nLos campos Title y Description de DESCRIPTION son verdaderos puntos críticos durante la revisión humana de CRAN. Revise detenidamente los consejos proporcionados en Sección 9.2. Compruebe también que Authors@R incluya un titular de derechos de autor, indicado por la función ‘cph’. Los dos escenarios más comunes son que agrega ‘cph’ a sus otros roles (probablemente ‘cre’ y ‘aut’) o que agrega su empleador a Authors@R: con ‘cph’ y, tal vez, ‘fnd’ role. (Cuando acredita a un financiador a través del rol ‘fnd’, se reconoce en el pie de página de su sitio web pkgdown). Este también es un buen momento para asegurarse de que la dirección de correo electrónico del mantenedor sea apropiada. Ésta es la única manera en que CRAN puede comunicarse con usted. Si hay problemas y no pueden comunicarse con usted, eliminarán su paquete de CRAN. Asegúrese de que esta dirección de correo electrónico esté disponible por un tiempo y que no esté muy filtrada.\nVerifique que cada una de sus funciones exportadas documente su valor de retorno (con la etiqueta @returns, Sección 16.4) y tenga una sección @examples (Sección 16.5). Si tiene ejemplos que no se pueden ejecutar en CRAN, es absolutamente necesario utilizar las técnicas en Sección 16.5.4 para expresar las condiciones previas relevantes correctamente. No tome atajos, como no tener ejemplos, comentar sus ejemplos o poner todos sus ejemplos dentro de \\dontrun{}.\nSi tiene código de terceros incrustado en su paquete, verifique que cumple y declara correctamente su licencia (Sección 12.4).\nFinalmente, aproveche cualquier lista de comprobaciones ad hoc que otros desarrolladores de paquetes hayan experimentado recientemente con CRAN. En el momento de escribir, https://github.com/DavisVaughan/extrachecks es un buen lugar para encontrar este tipo de informes de primera mano. Leer dicha lista y modificar preventivamente su paquete a menudo puede marcar la diferencia entre una aceptación sin problemas y un proceso frustrante que requiere múltiples intentos.\n\n22.2.1 Políticas de CRAN\nLe alertamos sobre políticas CRAN específicas a lo largo de este libro y, especialmente, a través de este capítulo. Sin embargo, se trata de un objetivo en movimiento, por lo que vale la pena hacer un esfuerzo para mantenerse informado sobre los cambios futuros en la política de CRAN.\nEl hogar oficial de la política CRAN es https://cran.r-project.org/web/packages/policies.html. Sin embargo, no es muy práctico leer este documento, por ejemplo, una vez a la semana y simplemente esperar notar algún cambio. El repositorio de GitHub eddelbuettel/crp monitorea la Política del repositorio de CRAN al rastrear la evolución de los archivos subyacentes en la fuente del sitio web de CRAN. Por lo tanto, el historial de confirmaciones de ese repositorio hace que los cambios de políticas sean mucho más fáciles de navegar. Es posible que también desee seguir la cuenta de CRAN Policy Watch Mastodon, que suena cada vez que se detecta un cambio.2\nLa lista de correo de R-package-devel es otro buen recurso para aprender más sobre el desarrollo de paquetes. Puede suscribirse para estar al tanto de lo que hablan otros mantenedores. Incluso si no está suscrito, puede resultar útil buscar en esta lista cuando esté investigando un tema específico.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#mantenerse-al-día-con-el-cambio",
    "href": "release.html#mantenerse-al-día-con-el-cambio",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.3 Mantenerse al día con el cambio",
    "text": "22.3 Mantenerse al día con el cambio\nAhora pasamos a los elementos principales de la lista de verificación para una versión menor o mayor de un paquete que ya está en CRAN. Muchos de estos elementos también aparecen en la lista de verificación de un parche o lanzamiento inicial.\n\nVerifique los resultados actuales de la verificación CRAN\nCompruebe si se debe avanzar algún proceso de desaprobación, como se describe en Desaprobación gradual\nPulir NEWS\nurlchecker::url_check()\ndevtools::build_readme()\n\nEstos primeros elementos confirman que su paquete se mantiene al día con su entorno y consigo mismo. El primer elemento, “Verificar los resultados actuales de la verificación de CRAN”, será un hipervínculo a los resultados de la verificación de CRAN para la versión del paquete que se encuentra actualmente en CRAN. Si hay ADVERTENCIAS, ERRORES o NOTAS allí, debe investigar y determinar qué está pasando. Ocasionalmente puede haber un problema intermitente en CRAN, pero en términos generales, cualquier resultado que no sea “OK” es algo que debe abordar con la versión que está preparando. Es posible que descubra que su paquete se encuentra en un estado disfuncional debido a cambios en la base R, las políticas de CRAN, las herramientas de CRAN o los paquetes de los que depende.\nSi está en el proceso de desaprobar una función o un argumento, una versión menor o mayor es un buen momento para considerar avanzar ese proceso como se describe en Sección 21.7. Este también es un buen momento para mirar todas las viñetas de NEWS que se han acumulado desde el último lanzamiento (“Pulir noticias”). Incluso si ha sido diligente al anotar todos los cambios dignos de noticia, es probable que estas viñetas se beneficien de alguna reorganización y edición para lograr coherencia y claridad (Sección 18.2).\nOtra comprobación muy importante es ejecutar urlchecker::url_check(). Las comprobaciones de URL de CRAN se describen en https://cran.r-project.org/web/packages/URL_checks.html y se implementan mediante código que se incluye con el propio R. Sin embargo, estos controles no se exponen de una manera muy útil. El paquete urlchecker se creó para solucionar este problema y expone la lógica de verificación de URL de CRAN en la función url_check(). Los principales problemas que surgen tienden a ser las URL que ya no funcionan o las URL que utilizan la redirección. Obviamente, deberás actualizar o eliminar cualquier URL que ya no exista. La redirección, sin embargo, es más complicada. Si el código de estado es “301 movido permanentemente”, la opinión de CRAN es que su paquete debe usar la URL redirigida. El problema es que muchas personas no siguen RFC7231 al pie de la letra y utilizan este tipo de redirección incluso cuando tienen una intención diferente, es decir, su intención es proporcionar una URL estable y fácil de usar que luego redirige a algo menos fácil de usar o más volátil. Si una URL legítima que desea utilizar no cumple con las comprobaciones de CRAN, tendrá que elegir entre un par de opciones poco atractivas. Podría intentar explicar la situación a CRAN, pero esto requiere una revisión humana y, por lo tanto, no se recomienda. O puede convertir dichas URL en texto textual sin hipervínculos. Tenga en cuenta también que aunque urlchecker utiliza el mismo código que CRAN, sus resultados locales aún pueden diferir de los de CRAN, debido a diferencias en otras condiciones ambientales, como variables de entorno y capacidades del sistema.\nSi tiene un archivo README.Rmd, también querrá reconstruir el archivo estático README.md con la versión actual de su paquete. La mejor función para usar para esto es devtools::build_readme(), porque se garantiza que renderizará README.Rmd contra el código fuente actual de su paquete.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#doble-r-cmd-check",
    "href": "release.html#doble-r-cmd-check",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.4 Doble R CMD check\n",
    "text": "22.4 Doble R CMD check\n\nA continuación vienen un par de elementos relacionados con la R CMD check. Recuerde que esta no debería ser la primera vez que ejecuta R CMD check desde la versión anterior. Con suerte, está ejecutando R CMD check con frecuencia durante el desarrollo local y está utilizando un servicio de integración continua, como GitHub Actions. Este pretende ser un recordatorio final de último momento para comprobar que todo sigue bien:\n\ndevtools::check(remote = TRUE, manual = TRUE). Esto sucede en su máquina de desarrollo principal, presumiblemente con la versión actual de R, y con algunas comprobaciones adicionales que generalmente se desactivan para acelerar el desarrollo diario.\ndevtools::check_win_devel(). Esto envía su paquete para que lo verifiquen con el servicio win-builder de CRAN, con la última versión de desarrollo de R (también conocido como r-devel). Debería recibir un correo electrónico en unos 30 minutos con un enlace a los resultados de la verificación. Es una buena idea verificar su paquete con r-devel, porque la base R y R CMD check están en constante evolución. La política de CRAN exige la verificación con r-devel y se realizará como parte de las verificaciones entrantes de CRAN. No tiene sentido saltarse este paso y esperar lo mejor.\n\nTenga en cuenta que la brevedad de esta lista refleja implícitamente que los paquetes de tidyverse se verifican después de cada envío a través de GitHub Actions, en múltiples sistemas operativos y versiones de R (incluida la versión de desarrollo), y que la mayor parte del equipo de tidyverse desarrolla principalmente en macOS. CRAN espera que usted “haga todos los esfuerzos razonables” para que su paquete funcione en todas las principales plataformas R y los paquetes que no funcionan en al menos dos normalmente no serán aceptados.\nLa siguiente subsección (Sección 22.4.1) es de lectura opcional con más detalles sobre todas las plataformas que le interesan a CRAN y cómo puede acceder a ellas. Si sus controles continuos son más limitados que los nuestros, es posible que desee compensarlo con controles previos al envío más exhaustivos. También puede necesitar este conocimiento para solucionar un problema concreto que surja en las comprobaciones de CRAN, ya sea para un envío entrante o para un paquete que ya está en CRAN.\nAl ejecutar R CMD check para un envío CRAN, debe solucionar cualquier problema que aparezca:\n\nDebe corregir todos los “ERRORES” y “ADVERTENCIAS”. CRAN no aceptará un paquete que contenga errores o advertencias.\nEliminar tantas NOTAS como sea posible. Cada “NOTA” requiere supervisión humana, lo que crea fricciones tanto para usted como para CRAN. Si hay notas que no cree que sean importantes, casi siempre es más fácil arreglarlas (incluso si la solución es un poco complicada) que persuadir a CRAN de que están bien. Consulte nuestra guía solo en línea sobre R CMD check para obtener detalles sobre cómo solucionar problemas individuales.\n\nSi no puede eliminar una NOTA, inclúyala en cran-comments.md y explique por qué cree que es falsa. Analizaremos este archivo con más detalle en Sección 22.6.\nTenga en cuenta que siempre habrá una “NOTA” cuando envíe su paquete por primera vez. Esto le recuerda a CRAN que se trata de un envío nuevo y que necesitarán realizar algunas comprobaciones adicionales. No puede eliminar esta “NOTA”, así que simplemente mencione en “cran-comments.md” que este es su primer envío.\n\n\n\n22.4.1 CRAN consulta sabores y servicios relacionados\nCRAN ejecuta R CMD check en todos los paquetes contribuidos al momento del envío y de forma regular, en múltiples plataformas o lo que ellos llaman “sabores”. Puede ver los tipos de cheques actuales de CRAN aquí: https://cran.r-project.org/web/checks/check_flavors.html. Hay varias combinaciones de:\n\nSistema operativo y CPU: Windows, macOS (x86_64, arm64), Linux (varias distribuciones)\nVersión R: r-devel, r-release, r-oldrel\nCompiladores C, C++, FORTRAN\nConfiguración regional, en el sentido de la variable de entorno LC_CTYPE (se trata de qué lenguaje humano está en uso y codificación de caracteres)\n\nEs casi seguro que los tipos de verificación de CRAN incluyen plataformas distintas a su(s) entorno(s) de desarrollo preferido, por lo que eventualmente necesitará hacer un esfuerzo explícito para verificar y, tal vez, solucionar problemas de su paquete en estos otros tipos.\nNo sería práctico que los desarrolladores de paquetes individuales mantuvieran personalmente todas estas plataformas de prueba. En lugar de eso, recurrimos a varios recursos mantenidos por la comunidad y por CRAN para esto. Aquí hay una selección, en orden de cuán centrales son para nuestras prácticas actuales:\n\nGitHub Actions (GHA) es nuestro medio principal para probar paquetes en múltiples versiones, como se describe en Sección 20.2.1.\n\nConstructor de R-hub (R-hub). Este es un servicio respaldado por R Consortium donde los desarrolladores de paquetes pueden enviar su paquete para verificaciones que repliquen varios tipos de verificación CRAN.\nPuede utilizar R-hub a través de una interfaz web (https://builder.r-hub.io) o, como recomendamos, a través del paquete Rhub R.\nrhub::check_for_cran() es una buena opción para un paquete CRAN típico y es moralmente similar al flujo de trabajo de GHA configurado por usethis::use_github_action(\"check-standard\"). Sin embargo, a diferencia de GHA, R-hub actualmente no cubre macOS, sólo Windows y Linux.\nRhub también le ayuda a acceder a algunos de los tipos de cheques más exóticos y ofrece controles especializados relevantes para paquetes con código compilado, como rhub::check_with_sanitizers().\n\n\nEl generador de macOS es un servicio mantenido por el personal de CRAN que crea los archivos binarios de macOS para los paquetes de CRAN. Esta es una adición relativamente nueva a la lista y verifica paquetes con “la misma configuración y paquetes disponibles que la máquina de compilación CRAN M1”.\nPuede enviar su paquete usando la interfaz web (https://mac.r-project.org/macbuilder/submit.html) o con devtools::check_mac_release().",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#sec-release-revdep-checks",
    "href": "release.html#sec-release-revdep-checks",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.5 Comprobaciones de dependencia inversa",
    "text": "22.5 Comprobaciones de dependencia inversa\n\nrevdepcheck::revdep_check(num_workers = 4)\n\nEste elemento inofensivo de la lista de verificación puede representar en realidad una cantidad considerable de esfuerzo. En un nivel alto, la verificación de sus dependencias inversas (“revdeps”) se divide en:\n\nForme una lista de sus dependencias inversas. Estos son paquetes CRAN que enumeran su paquete en sus campos Depends, Imports, Suggests o LinkingTo.\nEjecute R CMD check en cada uno.\nAsegúrese de no haber roto el paquete de otra persona con los cambios planificados en su paquete.\n\nCada uno de estos pasos puede requerir mucho trabajo y juicio. Por lo tanto, si no tiene dependencias inversas, debería alegrarse de poder omitir este paso. Si solo tiene un par de dependencias inversas, probablemente pueda hacerlo “a mano”, es decir, descargar el código fuente de cada paquete y ejecutar R CMD check.\nAquí explicamos formas de realizar comprobaciones de dependencia inversa a escala, que es el problema al que nos enfrentamos. Algunos de los paquetes mantenidos por nuestro equipo tienen miles de dependencias inversas e incluso algunos de los paquetes de nivel inferior tienen cientos. Tenemos que abordar esto de forma automatizada y esta sección será de gran utilidad para otros mantenedores en el mismo barco.\nTodas nuestras herramientas de dependencia inversa se concentran en el paquete revdepcheck (https://revdepcheck.r-lib.org/). Tenga en cuenta que, al menos en el momento de escribir este artículo, el paquete revdepcheck no está en CRAN. Puedes instalarlo desde Github a través de devtools::install_github(\"r-lib/revdepcheck\") o pak::pak(\"r-lib/revdepcheck\").\nHaga esto cuando esté listo para realizar comprobaciones de revdep por primera vez:\n\nusethis::use_revdep()\n\nEsto realiza una configuración única en los archivos .gitignore y .Rbuildignore de su paquete. La comprobación de Revdep creará algunas carpetas bastante grandes debajo de revdep/, por lo que definitivamente querrás configurar estos archivos ignorados. También verá este recordatorio para realizar verificaciones de revdep de esta manera, como sugiere el elemento de la lista de verificación:\n\nrevdepcheck::revdep_check(num_workers = 4)\n\nEsto ejecuta ⁠R CMD check⁠ en todas sus dependencias inversas, con nuestra recomendación de utilizar 4 trabajadores paralelos para acelerar las cosas. La salida se parece a esto:\n&gt; revdepcheck::revdep_check(num_workers = 4)\n── INIT ───────────────────────────────────── Computing revdeps ──\n── INSTALL ───────────────────────────────────────── 2 versions ──\nInstalling CRAN version of cellranger\nalso installing the dependencies 'cli', 'glue', 'utf8', 'fansi', 'lifecycle', 'magrittr', 'pillar', 'pkgconfig', 'rlang', 'vctrs', 'rematch', 'tibble'\n\nInstalling DEV version of cellranger\nInstalling 13 packages: rlang, lifecycle, glue, cli, vctrs, utf8, fansi, pkgconfig, pillar, magrittr, tibble, rematch2, rematch\n── CHECK ─────────────────────────────────────────── 8 packages ──\n✔ AOV1R 0.1.0                     ── E: 0     | W: 0     | N: 0\n✔ mschart 0.4.0                   ── E: 0     | W: 0     | N: 0\n✔ googlesheets4 1.0.1             ── E: 0     | W: 0     | N: 1\n✔ readODS 1.8.0                   ── E: 0     | W: 0     | N: 0\n✔ readxl 1.4.2                    ── E: 0     | W: 0     | N: 0\n✔ readxlsb 0.1.6                  ── E: 0     | W: 0     | N: 0\n✔ unpivotr 0.6.3                  ── E: 0     | W: 0     | N: 0\n✔ tidyxl 1.0.8                    ── E: 0     | W: 0     | N: 0                  \nOK: 8                                                                                 \nBROKEN: 0\nTotal time: 6 min\n── REPORT ────────────────────────────────────────────────────────\nWriting summary to 'revdep/README.md'\nWriting problems to 'revdep/problems.md'\nWriting failures to 'revdep/failures.md'\nWriting CRAN report to 'revdep/cran.md'\nPara minimizar los falsos positivos, revdep_check() ejecuta ⁠R CMD check⁠ dos veces por revdep: una vez con la versión publicada de su paquete actualmente en CRAN y otra vez con la versión de desarrollo local, es decir, con su versión candidata. ¿Por qué dos cheques? Porque a veces el revdep ya está fallando en la R CMD check y sería incorrecto culpar a la versión planificada por la falla. revdep_check() informa los paquetes que no se pueden verificar y, lo más importante, aquellos en los que hay los llamados “cambios a peor”, es decir, donde su versión candidata está asociada con nuevos problemas. Tenga en cuenta también que revdep_check() siempre funciona con una biblioteca de paquetes temporal e independiente, es decir, no modificará su biblioteca de usuario o sistema predeterminada.\n\n\n\n\n\n\nequipo tidyverse\n\n\n\nDe hecho, utilizamos una función diferente para nuestras comprobaciones de dependencia inversa: revdepcheck::cloud_check(). Esto ejecuta las comprobaciones en la nube, masivamente en paralelo, lo que hace posible ejecutar comprobaciones de revdep para paquetes como testthat (con &gt;10,000 revdeps) en solo unas pocas horas.\ncloud_check() ha cambiado las reglas del juego para nosotros, permitiéndonos ejecutar comprobaciones revdep con más frecuencia. Por ejemplo, incluso hacemos esto ahora cuando evaluamos el impacto de un posible cambio en un paquete (Sección 21.4), en lugar de hacerlo justo antes de un lanzamiento.\nAl momento de escribir este artículo, cloud_check() solo está disponible para los mantenedores de paquetes en Posit, pero esperamos ofrecer este servicio a la comunidad R en general en el futuro.\n\n\nAdemás de algunos mensajes interactivos, los resultados de la verificación revdep se escriben en la carpeta revdep/:\n\n\nrevdep/README.md: Este es un resumen de alto nivel dirigido a mantenedores. El nombre del archivo y el formato Markdown son muy intencionados para crear una buena página de inicio para la carpeta revdep/ en GitHub.\n\nrevdep/problems.md: enumera los revdeps que parecen estar rotos por su versión candidata.\n\nrevdep/failures.md: enumera los revdep que no se pudieron verificar, generalmente debido a un error de instalación, ya sea del propio revdep o de una de sus dependencias.\n\nrevdep/cran.md: Este es un resumen de alto nivel dirigido a CRAN. Debes copiar y pegar esto en cran-comments.md (Sección 22.6).\nOtros archivos y carpetas, como checks.noindex, data.sqlite y library.noindex. Estos son para uso interno de revdepcheck y no los discutiremos más.\n\nLa forma más sencilla de tener una idea de estos diferentes archivos es consultar los últimos resultados de revdep para algunos paquetes tidyverse, como dplyr o tidyr.\nLos resultados de la verificación revdep (local, en la nube o CRAN) no son perfectos, porque no es una tarea sencilla. Hay varias razones por las que un resultado puede faltar, ser incorrecto o contradictorio en diferentes ejecuciones.\n\nFalsos positivos: a veces revdepcheck informa que un paquete se ha roto, pero en realidad todo está bien (o, al menos, no peor que antes). Esto ocurre más comúnmente debido a pruebas inestables que fallan aleatoriamente (Sección 15.4.1), como las solicitudes HTTP. Esto también puede suceder porque la instancia se queda sin espacio en disco u otros recursos, por lo que la primera verificación con la versión CRAN tiene éxito y la segunda verificación con la versión dev falla. A veces es obvio que el problema no está relacionado con su paquete.\nFalsos negativos: a veces se ha roto un paquete, pero no lo detectas. Para nosotros, esto suele suceder cuando cloud_check() no puede verificar un revdep porque no se puede instalar, generalmente debido a que falta un requisito del sistema (por ejemplo, Java). Estos se informan por separado como “no se pudo probar”, pero aún se incluyen en problems.md, porque aún podría tratarse de una rotura directa causada por su paquete. Por ejemplo, si elimina una función exportada que utiliza otro paquete, la instalación fallará.\n\nEn general, estas diferencias son menos preocupantes ahora que las propias comprobaciones de revdep de CRAN están bien automatizadas, por lo que las nuevas fallas normalmente no involucran a un humano.\n\n22.5.1 Revdeps y cambios importantes\nSi la verificación revdep revela roturas, debe examinar cada falla y determinar si se trata de:\n\nUn falso positivo.\nUn cambio continuo, es decir, una falla causada por el uso no autorizado de su paquete.\nUn error en tu paquete que necesitas corregir.\nUn cambio radical deliberado.\n\nSi su actualización romperá otro paquete (independientemente del motivo), debe informar al mantenedor, para que él lo escuche primero de usted, en lugar de CRAN. La mejor manera de hacerlo es con un parche que actualice su paquete para que funcione bien con el suyo, tal vez en forma de solicitud de extracción. Esto puede suponer una cantidad decente de trabajo y ciertamente no es factible para todos los mantenedores. Pero resolver algunos de ellos puede ser una buena manera de enfrentar el dolor que causa el cambio radical y reconsiderar si los beneficios superan los costos. En la mayoría de los casos, es probable que un cambio que afecte a los revdeps también rompa el código menos visible que se encuentra fuera de los paquetes CRAN, como scripts, informes y aplicaciones Shiny.\nSi decide continuar, funciones como revdepcheck::revdep_maintainers() y revdepcheck::revdep_email() pueden ayudarle a notificar a los mantenedores de revdep en masa. Asegúrese de que el correo electrónico incluya un enlace a la documentación que describa los cambios importantes más comunes y cómo solucionarlos. Debe informar a los mantenedores cuándo planea enviar su versión a CRAN (recomendamos avisar con al menos dos semanas de anticipación), para que puedan enviar su versión actualizada antes de eso. Cuando llegue la fecha de lanzamiento, vuelva a ejecutar sus comprobaciones para ver cuántos problemas se han resuelto. Explique cualquier falla restante en cran-comments.md como se demuestra en Sección 22.6. Los dos casos más comunes son que no puede verificar un paquete porque no puede instalarlo localmente o un cambio legítimo en la API que el mantenedor aún no ha abordado. Siempre que haya avisado con suficiente antelación, CRAN aceptará su actualización, incluso si daña otros paquetes.\n\n\n\n\n\n\nequipo tidyverse\n\n\n\nÚltimamente, el equipo de tidyverse está tratando de cumplir con los mantenedores de revdep a más de la mitad del camino en términos de lidiar con cambios importantes. Por ejemplo, en el problema de GitHub tidyverse/dplyr#6262, los mantenedores de dplyr rastrearon cientos de solicitudes de extracción en el período previo al lanzamiento de dplyr v1. .1.0. A medida que se crean los RP, también es útil agregar enlaces a ellos. A medida que los mantenedores de revdep fusionan los RP, se pueden marcar como resueltos. Si algunos RP todavía están en proceso cuando llega la fecha de envío anunciada, la situación se puede resumir en cran-comments.md, como fue el caso de dplyr v1.1.0.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#sec-release-cran-comments",
    "href": "release.html#sec-release-cran-comments",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.6 Actualizar comentarios para CRAN",
    "text": "22.6 Actualizar comentarios para CRAN\n\nActualizar cran-comments.md\n\nUsamos el archivo cran-comments.md para registrar comentarios sobre un envío, principalmente solo los resultados de R CMD check y controles revdep. Si está realizando un cambio específico a solicitud de CRAN, posiblemente dentro de una fecha límite, también tendría sentido mencionarlo. Nos gusta realizar un seguimiento de este archivo en Git, para poder ver cómo cambia con el tiempo. También debería aparecer en .Rbuildignore, ya que no debería aparecer en su paquete. Cuando esté listo para enviar, devtools::submit_cran() (Sección 22.7) incorpora el contenido de cran-comments.md cuando carga su envío.\nEl público objetivo de estos comentarios es el personal de CRAN, aunque no hay garantía de que lean los comentarios (o cuando en el proceso de envío los lean). Por ejemplo, si su paquete rompe otros paquetes, probablemente recibirá un correo electrónico automático al respecto, incluso si lo ha explicado en los comentarios. A veces, un humano de CRAN lee los comentarios, queda satisfecho y acepta su paquete de todos modos, sin ninguna otra acción por su parte. En otras ocasiones, su paquete puede quedarse atascado en la cola hasta que copie cran-comments.md y lo pegue en un intercambio de correo electrónico para avanzar. En cualquier caso, vale la pena mantener estos comentarios en su propio archivo controlado por versión.\nAquí hay un cran-comments.md bastante típico de una versión reciente de forcats. Tenga en cuenta que los resultados de la R CMD check son limpios, es decir, no hay nada que deba explicarse o justificarse, y hay un resumen conciso del proceso revdep.\n## R CMD check results\n\n0 errors | 0 warnings | 0 notes\n\n## revdepcheck results\n\nWe checked 231 reverse dependencies (228 from CRAN + 3 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.\n\nWe saw 2 new problems:\n\n* epikit\n* stevemisc\n\nBoth maintainers were notified on Jan 12 (~2 week ago) and supplied with patches.\n\nWe failed to check 3 packages\n\n* genekitr     (NA)\n* OlinkAnalyze (NA)\n* SCpubr       (NA)\nEste diseño está diseñado para que sea fácil de leer y fácil de comparar con los resultados de la R CMD check vistos por los mantenedores de CRAN. Incluye dos secciones:\n\n\nVerificar resultados: Siempre afirmamos que no hubo errores ni advertencias (¡y nos aseguramos de que sea cierto!). Idealmente también podemos decir que no hubo notas. Pero si no, las NOTES se presentan en una lista con viñetas. Para cada NOTA, incluimos el mensaje de R CMD check y una breve descripción de por qué creemos que está bien.\nA continuación se explica cómo se explica una NOTA para el paquete de datos nycflights13:\n## R CMD check results\n\n0 errors | 0 warnings | 1 note\n\n* Checking installed package size:\n  installed size is  6.9Mb\n  sub-directories of 1Mb or more:\n    data   6.9Mb\n\n  This is a data package that will be rarely updated.\n\nDependencias inversas: si hay revdeps, aquí es donde pegamos el contenido de revdep/cran.md (Sección 22.5). Si no hay revdeps, le recomendamos que mantenga esta sección, pero diga algo como: “Actualmente no hay dependencias posteriores para este paquete”.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#sec-release-process",
    "href": "release.html#sec-release-process",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.7 El proceso de envío",
    "text": "22.7 El proceso de envío\n\nusethis::use_version('minor') (o ‘patch’ o ‘major’)\ndevtools::submit_cran()\nAprobar correo electrónico\n\nCuando esté realmente listo para enviar, es hora de aumentar el número de versión en DESCRIPCIÓN. Este elemento de la lista de verificación reflejará el tipo de lanzamiento declarado al inicio de este proceso (parche, menor o mayor), en la llamada inicial a use_release_issue().\nLe recomendamos que envíe su paquete a CRAN llamando a devtools::submit_cran(). Esta función de conveniencia resume algunos pasos:\n\nCrea el paquete (Sección 3.3) con pkgbuild::build(manual = TRUE), que finalmente llama a R CMD build.\nPublica el archivo *.tar.gz resultante en el formulario de envío oficial de CRAN (https://cran.r-project.org/submit.html), completando su nombre y correo electrónico desde DESCRIPCIÓN y sus comentarios de envío. de cran-comments.md.\nConfirma que el envío fue exitoso y le recuerda que revise su correo electrónico para ver el enlace de confirmación.\nEscribe los detalles del envío en un archivo local CRAN-SUBMISSION, que registra la versión del paquete, SHA y la hora del envío. Esta información la utiliza más adelante usethis::use_github_release() para crear una versión de GitHub una vez que su paquete haya sido aceptado. CRAN-SUBMISSION se agregará a .Rbuildignore. Generalmente no ignoramos este archivo, pero tampoco lo confirmamos. Es una nota efímera que existe durante el intervalo entre la presentación y (con suerte) la aceptación.\n\nDespués de una carga exitosa, debería recibir un correo electrónico de CRAN en unos minutos. Este correo electrónico le notifica a usted, como mantenedor, del envío y proporciona un enlace de confirmación. Parte de lo que esto hace es confirmar que la dirección de correo electrónico del mantenedor es correcta. En el enlace de confirmación, deberá volver a confirmar que ha seguido las políticas de CRAN y que desea enviar el paquete. Si no completa este paso, ¡su paquete en realidad no se envía a CRAN!\nUna vez que su paquete ingresa al sistema de CRAN, se verifica automáticamente en Windows y Linux, probablemente con las versiones lanzadas y de desarrollo de R. Recibirá otro correo electrónico con enlaces a los resultados de estas comprobaciones, normalmente en cuestión de horas. Una presentación inicial (Sección 22.2) recibirá un escrutinio adicional por parte del personal de CRAN. El proceso está potencialmente completamente automatizado cuando se actualiza un paquete que ya está en CRAN. Si la actualización de un paquete pasa sus comprobaciones iniciales, CRAN ejecutará comprobaciones de dependencia inversa.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#modos-de-fallo",
    "href": "release.html#modos-de-fallo",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.8 Modos de fallo",
    "text": "22.8 Modos de fallo\nHay al menos tres formas de que falle el envío de CRAN:\n\nNo pasa R CMD check. Este es un resultado automatizado.\nLa revisión humana determina que el paquete infringe las políticas de CRAN. Esto se aplica principalmente a los envíos iniciales, pero a veces el personal de CRAN decide participar en una revisión ad hoc de actualizaciones de paquetes existentes que no superan las comprobaciones automáticas.\nLas comprobaciones de dependencia inversa sugieren que hay “cambios a peor”. Este es un resultado automatizado.\n\nLos fracasos son frustrantes y la retroalimentación puede ser cortante y francamente insultante. Siéntase cómodo sabiendo que esta es una experiencia ampliamente compartida en toda la comunidad R. Nos pasa habitualmente. No se apresure a responder, especialmente si se siente a la defensiva.\nEspere hasta que pueda centrar su atención en los problemas técnicos que se han planteado. Lea atentamente los resultados de las comprobaciones o los correos electrónicos e investigue los hallazgos. A menos que crea firmemente que se merece la discusión, no responda el correo electrónico. En cambio:\n\nSolucione los problemas identificados y realice los cambios recomendados. Vuelva a ejecutar devtools::check() en cualquier plataforma relevante para asegurarse de no introducir accidentalmente ningún problema nuevo.\nAumente la versión de parche de su paquete. Sí, esto significa que puede haber lagunas en los números de versión publicada. Esto no es gran cosa.\n\nAgregue una sección “Resubmission” en la parte superior de cran-comments.md. Esto debería identificar claramente que el paquete es un reenvío y enumerar los cambios que realizó.\n## Resubmission\nThis is a resubmission. In this version I have:\n\n* Converted the DESCRIPTION title to title case.\n\n* More clearly identified the copyright holders in the DESCRIPTION\n  and LICENSE files.\n\nSi es necesario, actualice las secciones de resultados de verificación y revisión.\nEjecute devtools::submit_cran() para volver a enviar el paquete.\n\nSi su análisis indica que el error inicial fue un falso positivo, responda al correo electrónico de CRAN con una explicación concisa. Para nosotros, este escenario surge principalmente con respecto a los controles de revdep. Es extremadamente raro que veamos fallas en las ejecuciones iniciales de R CMD check de CRAN y, cuando sucede, a menudo es legítima. Por otro lado, para paquetes con una gran cantidad de revdeps, es inevitable que un subconjunto de estos paquetes tenga algunas pruebas inestables o ejemplos frágiles. Por lo tanto, es bastante común ver fallas de revdep que no tienen nada que ver con la actualización del paquete propuesta. En este caso, lo adecuado es enviar un correo electrónico de respuesta a CRAN explicando por qué cree que se trata de falsos positivos.",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#sec-release-post-acceptance",
    "href": "release.html#sec-release-post-acceptance",
    "title": "22  Subiendo a CRAN",
    "section": "\n22.9 Celebrando el éxito",
    "text": "22.9 Celebrando el éxito\nAhora pasamos a la sección más feliz de la lista de verificación.\n\nAceptada 🎉\nTermina y publica en blog\nAñade link de la punlicación en pkgdown news menu\nusethis::use_github_release()\nusethis::use_dev_version(push = TRUE)\ngit push\nCompartir en las redes sociales\n\nCRAN le notificará por correo electrónico una vez que su paquete sea aceptado. Este es un buen momento para terminar una entrada de blog, si es relevante. usethis::use_github_release() realiza un par de cosas importantes. En primer lugar, es cuando subimos por primera vez a GitHub el nuevo número de versión; es decir, esperamos hasta que estemos seguros de que esta versión se publicará en CRAN. Esta función también crea una versión de GitHub correspondiente a esta versión de CRAN. Una versión de GitHub es básicamente una etiqueta de Git glorificada. El único aspecto de las versiones de GitHub que aprovechamos regularmente son las notas de la versión. usethis::use_github_release() crea notas de la versión a partir de las viñetas NEWS relevantes para la versión actual. Tenga en cuenta que usethis::use_github_release() depende crucialmente del archivo CRAN-SUBMISSION que fue escrito por devtools::submit_cran(): así es como sabe qué SHA etiquetar. Después de la creación exitosa de la versión de GitHub, use_github_release() elimina este archivo temporal.\nAhora nos preparamos para la próxima versión incrementando el número de versión una vez más, esta vez a una versión de desarrollo usando usethis::use_dev_version(). Tiene sentido enviar inmediatamente este estado a GitHub para que, por ejemplo, cualquier rama nueva o solicitud de extracción tenga claramente una versión de desarrollo como base.\nUna vez que CRAN acepta el paquete, se crean archivos binarios para macOS y Windows. También se verificará en el panel de tipos de verificación CRAN. Estos procesos se desarrollan a lo largo de unos días, después de la aceptación, y a veces descubren errores que no fueron detectados por las comprobaciones entrantes menos exhaustivas. Es una buena idea visitar la página de inicio de CRAN de su paquete unos días después del lanzamiento y asegurarse de que todo parezca estar bien. Figura 22.1 resalta dónde están vinculados estos resultados desde una página de inicio de CRAN.\n\n\n\n\n\n\n\n\nFigura 22.1: Enlace a los resultados de la verificación CRAN.\n\n\n\n\nSi hay un problema, prepare una versión de parche para solucionarlo y envíelo utilizando el mismo proceso que antes. Si esto significa que va a realizar un segundo envío menos de una semana después del anterior, explique la situación en cran-comments.md. Lograr que un paquete se establezca en CRAN puede llevar un par de rondas, aunque la orientación de este capítulo tiene como objetivo maximizar las posibilidades de éxito en el primer intento. Las versiones futuras, iniciadas por usted, deben tener un intervalo de al menos uno o dos meses, de acuerdo con la política de CRAN.\nUna vez que los binarios de su paquete estén creados y hayan pasado las comprobaciones de los distintos tipos de CRAN, es hora de la parte divertida: dar a conocer su paquete. Esto adopta diferentes formas, según el tipo de liberación. Si este es su lanzamiento inicial (o, al menos, el primer lanzamiento para el que realmente desea atraer usuarios), es especialmente importante correr la voz. Nadie utilizará su nuevo y útil paquete si no sabe que existe. Hay varios lugares para anunciar su paquete, como Twitter, Mastodon, LinkedIn, comunidades de Slack, etc. Asegúrese de utilizar etiquetas relevantes, como el hashtag #rstats. Si tienes un blog, es una gran idea escribir una publicación sobre tu lanzamiento.\nAl presentar un paquete, la sensación debería ser bastante similar a escribir su README o una viñeta de “Introducción”. Asegúrese de describir lo que hace el paquete, para que las personas que no lo hayan usado antes puedan entender por qué debería importarles. Para los paquetes existentes, tendemos a escribir publicaciones de blog para versiones menores y principales, pero no para una versión de parche. En todos los casos, encontramos que estas publicaciones de blog son más efectivas cuando incluyen muchos ejemplos, es decir, “muestre, no cuente”. Para actualizaciones de paquetes, recuerde que la existencia de un archivo completo NEWS lo libera de la necesidad de enumerar hasta el último cambio en la publicación de su blog. En su lugar, puede centrarse en los cambios más importantes y vincular a las notas de la versión completas, para aquellos que quieran conocer los detalles sangrientos.\nSi escribe un blog sobre su paquete, es bueno capturarlo como otra documentación más en su sitio web de pkgdown. Un sitio típico de pkgdown tiene un elemento de “News” en la barra de navegación superior, que enlaza con un “Changelog” que se crea a partir de NEWS.md. Este menú desplegable es un lugar común para insertar enlaces a cualquier publicación de blog sobre el paquete. Puedes lograr esto teniendo YAML como este en tu archivo de configuración _pkgdown.yml:\nnews:\n  releases:\n  - text: \"Renaming the default branch (usethis &gt;= 2.1.2)\"\n    href: https://www.tidyverse.org/blog/2021/10/renaming-default-branch/\n  - text: \"usethis 2.0.0\"\n    href: https://www.tidyverse.org/blog/2020/12/usethis-2-0-0/\n  - text: \"usethis 1.6.0\"\n    href: https://www.tidyverse.org/blog/2020/04/usethis-1-6-0/\n¡Felicidades! ¡Has lanzado tu primer paquete a CRAN y has llegado al final del libro!",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "release.html#footnotes",
    "href": "release.html#footnotes",
    "title": "22  Subiendo a CRAN",
    "section": "",
    "text": "La publicación del blog de Fowler “FrequencyReducesDifficulty” es una excelente lectura sobre este tema, https://martinfowler.com/bliki/FrequencyReducesDifficulty.html.↩︎\nDurante muchos años, existió, en cambio, una cuenta de Twitter de CRAN Policy Watch. Pero gracias a los nuevos límites de acceso a la API para ese “cadáver podrido de una plataforma”, la cuenta de Twitter ya no puede funcionar.↩︎",
    "crumbs": [
      "Mantenimiento y distribución",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Subiendo a CRAN</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Bryan, Jennifer. 2018. “Excuse Me, Do You Have a Moment to Talk\nabout Version Control?” The American Statistician 72\n(1): 20–27. https://doi.org/10.1080/00031305.2017.1399928.\n\n\nMarwick, Ben, Carl Boettiger, and Lincoln Mullen. 2018a.\n“Packaging Data Analytical Work Reproducibly Using r (and\nFriends).” The American Statistician 72 (1): 80–88. https://doi.org/10.1080/00031305.2017.1375986.\n\n\n———. 2018b. “Packaging Data Analytical Work Reproducibly Using r\n(and Friends).” PeerJ Preprints 6 (March): e3192v2. https://doi.org/10.7287/peerj.preprints.3192v2.\n\n\nMüller, Kirill, and Lorenz Walthert. 2018. Styler: Non-Invasive\nPretty Printing of R Code. http://styler.r-lib.org.\n\n\nSilge, Julia, John C. Nash, and Spencer Graves. 2018. “Navigating the R Package Universe.”\nThe R Journal 10 (2): 558–63. https://doi.org/10.32614/RJ-2018-058.",
    "crumbs": [
      "Referencias"
    ]
  },
  {
    "objectID": "R-CMD-check.html",
    "href": "R-CMD-check.html",
    "title": "Apéndice A — R CMD check",
    "section": "",
    "text": "A.1 Verificar metadatos\nR CMD check se compone de más de 50 controles individuales, que se describen en las siguientes secciones. Para cada verificación, describimos brevemente qué hace, cuáles son los problemas más comunes y cómo solucionarlos. Cuando tenga un problema con R CMD check y no sepa cómo solucionarlo, utilice esta lista para descubrir qué debe hacer. Para que sea más fácil comprender cómo encajan los cheques, los hemos organizado en secciones que corresponden aproximadamente a los capítulos de este libro. Esto significa que estarán en un orden algo diferente al que verá cuando ejecute devtools::check(), que es nuestra forma principal de ejecutar R CMD check.\nSi este capítulo no coincide con lo que está viendo, considere que las comprobaciones pueden haber cambiado desde que se redactó. R continúa evolucionando, incluida la R CMD check. Quizás desee consultar la versión en línea más reciente de este capítulo: https://r-pkgs.org/R-CMD-check.html. Abra un problema si encuentra un problema con el que este capítulo no ayuda.\nAl final (Sección A.12), destacamos algunas NOTAS que surgen durante la “verificación de R CMD” que no requieren ninguna respuesta por su parte. En general, recomendamos eliminar todas las NOTAS, especialmente para los paquetes destinados a CRAN, pero hay un pequeño puñado de NOTAS que realmente son informativas. Son la excepción a la regla.\nR CMD check siempre comienza describiendo tu entorno actual.\nA continuación, se analiza el archivo DESCRIPTION y se imprime la versión y codificación del paquete.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#verificar-metadatos",
    "href": "R-CMD-check.html#verificar-metadatos",
    "title": "Apéndice A — R CMD check",
    "section": "",
    "text": "Using log directory ‘/some/tmp/path/googledrive.Rcheck’\n\nUsing R version 4.2.2 (2022-10-31)\n\nUsing platform: x86_64-apple-darwin17.0 (64-bit)\n\nUsing session charset: UTF-8\n\n\n\n\n\nChecking for file ‘googledrive/DESCRIPTION’\n\nThis is package ‘googledrive’ version ‘2.1.0.9000’\n\nPackage encoding: UTF-8",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#estructura-del-paquete",
    "href": "R-CMD-check.html#estructura-del-paquete",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.2 Estructura del paquete",
    "text": "A.2 Estructura del paquete\n\n\n\nComprobando el directorio de paquetes. El directorio que estás comprobando debe existir; devtools::check() te protege contra este problema.\n\n\n\nComprobando si se trata de un paquete fuente. Debe verificar un paquete fuente, no un paquete binario o instalado. Esto nunca debería fallar si usa devtools::check().\n\n\n\nBuscando archivos ejecutables. No debe tener archivos ejecutables en su paquete: no son portátiles, no son de código abierto y representan un riesgo para la seguridad. Elimine cualquier archivo ejecutable de su paquete. (Si no realiza envíos a CRAN, puede silenciar esta advertencia enumerando cada archivo ejecutable en el campo BinaryFiles en su DESCRIPTION).\n\n\n\nBuscando archivos y directorios ocultos. En Linux y macOS, los archivos con un nombre que comienza con . están ocultos de forma predeterminada y probablemente los haya incluido en su paquete por error. Elimínelos o, si son importantes, use .Rbuildignore para eliminarlos del paquete. R elimina automáticamente algunos directorios comunes como .git y .svn.\n\n\n\nBuscando nombres de archivos portátiles. Los paquetes R deben funcionar en Windows, Linux y macOS, por lo que solo puedes usar nombres de archivos que funcionen en todas las plataformas. La forma más sencilla de hacerlo es limitarse a letras, números, guiones bajos y guiones. Evite letras y espacios que no estén en inglés. Solucione esta verificación cambiando el nombre de los archivos enumerados.\n\n\n\nComprobación de permisos de archivo suficientes/correctos. Si no puede leer un archivo, no puede verificarlo. Esta verificación detecta el caso poco probable de que tenga archivos en el paquete que no tenga permiso para leer. Solucione este problema arreglando los permisos del archivo.\n\n\n\nComprobando si se puede instalar el paquete ‘XYZ’. R CMD check ejecuta R CMD INSTALL para asegurarse de que sea posible instalar su paquete. Si esto falla, debe ejecutar devtools::install() o su equivalente desde los menús de RStudio y depurar cualquier problema antes de continuar.\n\n\n\nComprobando el tamaño del paquete instalado. Es fácil incluir accidentalmente archivos grandes que aumentan el tamaño de su paquete. Esta verificación garantiza que todo el paquete tenga menos de 5 MB y que cada subdirectorio tenga menos de 1 MB. Si ve este mensaje, verifique que no haya incluido accidentalmente un archivo grande.\nSi lo envía a CRAN, deberá justificar el tamaño de su paquete. Primero, asegúrese de que el paquete sea lo más pequeño posible: intente recomprimir los datos, Sección 7.1.1; y minimizando viñetas, Capítulo 17. Si todavía es demasiado grande, considere mover los datos a su propio paquete.\n\n\n\n\nComprobando archivos de nivel superior. Solo se permiten archivos y directorios específicos en el nivel superior del paquete (por ejemplo, DESCRIPTION, R/, src/). Para incluir otros archivos, tiene dos opciones:\n\nSi no es necesario instalarlos (es decir, solo se usan para tareas de desarrollo), agréguelos a .Rbuildignore con usethis::use_build_ignore().\nSi es necesario instalarlos: muévalos a inst/. Se moverán nuevamente al directorio de paquetes de nivel superior cuando se instalen. Obtenga más información en Sección 8.2.\n\n\n\n\n\nComprobando subdirectorios de paquetes.\n\nNo incluya ningún directorio vacío. Por lo general, estos se eliminan automáticamente con R CMD build, por lo que no deberías ver este error. Si lo hace, simplemente elimine el directorio vacío.\nEs importante el caso de archivos y directorios. Todos los subdirectorios deben estar en minúsculas, excepto R/. Un archivo de cita, si está presente, debe estar en inst/CITATION. Cambie el nombre según sea necesario.\nEl contenido de inst/ no debe chocar con el contenido de nivel superior del paquete, como data/ o R/. Si es así, cambie el nombre de sus archivos/directorios. Obtenga más información en Sección 8.2.\n\n\n\n\n\nBuscando archivos sobrantes. Elimine los archivos enumerados aquí. Han sido incluidos en tu paquete por accidente.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#description",
    "href": "R-CMD-check.html#description",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.3 DESCRIPTION\n",
    "text": "A.3 DESCRIPTION\n\n\n\n\nComprobando la metainformación de DESCRIPTION.\n\nLa DESCRIPTION debe ser válida. Es poco probable que vea este error, porque devtools::load_all() ejecuta la misma comprobación cada vez que recarga el paquete.\nSi utiliza caracteres que no sean ASCII en la descripción, también debe especificar una codificación. Sólo hay tres codificaciones que funcionan en todas las plataformas: latin1, latin2 y UTF-8. Recomendamos encarecidamente UTF-8: Codificación: UTF-8. Obtenga más información en Sección 7.1.3.\nLa License debe hacer referencia a una licencia conocida (puede encontrar una lista completa en https://svn.r-project.org/R/trunk/share/licenses/license.db), o debe usar file LICENSE y ese archivo debe existir. Lo más probable es que los errores aquí sean errores tipográficos. Obtenga más información en Capítulo 12.\nDebes proporcionar Autores@R o Authorz y Maintainer. Recibirá un error si ha especificado ambos, que puede solucionar eliminando el que no deseaba. Obtenga más información en Sección 9.3.\n\n\n\n\n\nComprobación de dependencias de paquetes.\n\nTodos los paquetes enumerados en Depends, Imports y LinkingTo deben estar instalados y se deben cumplir sus requisitos de versión; de lo contrario, no se podrá verificar su paquete.\nLos paquetes enumerados en Suggests deben instalarse, a menos que haya configurado la variable de entorno _R_CHECK_FORCE_SUGGESTS_ en un valor falso (por ejemplo, con check(force_suggests = FALSE)). Esto resulta útil si algunos de los paquetes sugeridos no están disponibles en todas las plataformas.\nUna manera fácil de instalar cualquier dependencia faltante o desactualizada es ejecutar devtools::install_deps(dependencies = TRUE). Consulte también pak::local_install_deps() y pak::local_install_dev_deps().\nLos paquetes R no pueden tener un ciclo de dependencias: es decir, si el paquete A requiere B, entonces B no puede requerir A (de lo contrario, ¿cuál cargarías primero?). Si ve este error, deberá reconsiderar el diseño de su paquete. Una solución sencilla es mover el paquete en conflicto de Imports o Depends a Suggests.\nCualquier paquete utilizado en NAMESPACE debe aparecer en uno de Imports (más comúnmente) o Depends (solo en casos especiales).\nCada paquete enumerado en Depends también debe importarse en NAMESPACE o accederse con pkg::foo(). Si no hace esto, su paquete funcionará cuando esté adjunto a la ruta de búsqueda (con library(mypackage)) pero no funcionará cuando solo esté cargado (por ejemplo, mypackage::foo()).\n\n\n\n\n\nComprobando la viabilidad entrante de CRAN. Estas comprobaciones solo se aplican si realiza el envío a CRAN.\n\nSi envía un paquete nuevo, no puede usar el mismo nombre que un paquete existente. Tendrás que pensar en un nuevo nombre.\nSi envía una actualización, el número de versión debe ser superior a la versión actual de CRAN. Actualice el campo Version en DESCRIPTION.\nSi el responsable del paquete ha cambiado (incluso si es solo un cambio en la dirección de correo electrónico), el nuevo responsable debe enviarlo a CRAN y el antiguo responsable recibirá un correo electrónico solicitándole que confirme el cambio.\nDebe utilizar una licencia estándar de código abierto, como se indica en https://svn.r-project.org/R/trunk/share/licenses/license.db. No puede utilizar una licencia personalizada ya que CRAN no tiene los recursos legales para revisar los acuerdos personalizados.\nEl Title y la Description deben estar libres de errores ortográficos. El título del paquete debe estar en mayúsculas y minúsculas. Ni el título ni la descripción deben incluir el nombre de su paquete ni la palabra “paquete”. Vuelva a redactar su título y descripción según sea necesario.\nSi envía un paquete nuevo, siempre recibirá una “NOTA”. Esto recuerda a los mantenedores de CRAN que deben realizar algunas comprobaciones manuales adicionales.\nEvite enviar múltiples versiones del mismo paquete en un corto período de tiempo. CRAN prefiere como máximo un envío por mes. Si necesita corregir un error importante, pida disculpas.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#namespace",
    "href": "R-CMD-check.html#namespace",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.4 Namespace",
    "text": "A.4 Namespace\n\n\n\nComprobando si hay un espacio de nombres. Debe tener un archivo NAMESPACE. Esto lo maneja automáticamente el flujo de trabajo de devtools.\n\n\n\nComprobando la información del espacio de nombres del paquete. El NAMESPACE debe ser analizable por parseNamespaceFile() y válido. Si esta verificación falla, es un error en roxygen2.\n\n\n\nComprobando si el paquete se puede cargar con las dependencias indicadas. Ejecuta library(pkg) con R_DEFAULT_PACKAGES=NULL, por lo que la ruta de búsqueda está vacía (es decir, estadísticas, gráficos, grDevices, utilidades, conjuntos de datos y métodos no se adjuntan como de costumbre). Un error aquí normalmente indica que le falta una dependencia en uno de esos paquetes.\n\n\n\nComprobando si el espacio de nombres se puede cargar con las dependencias indicadas. Ejecuta loadNamespace(pkg) con R_DEFAULT_PACKAGES=NULL. El error suele indicar un problema con el espacio de nombres.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#código-r",
    "href": "R-CMD-check.html#código-r",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.5 Código R",
    "text": "A.5 Código R\n\n\n\nComprobación de archivos R en busca de caracteres que no sean ASCII. Para una máxima portabilidad (es decir, para que las personas puedan usar su paquete en Windows), debe evitar el uso de caracteres que no sean ASCII en archivos R. Está bien usarlos en los comentarios, pero los nombres de los objetos no deberían usarlos, y en las cadenas deberías usar escapes Unicode. Consulte las notas específicas de CRAN en Capítulo 6 para obtener más detalles.\n\n\n\nComprobación de archivos R en busca de errores de sintaxis. Obviamente su código R debe ser válido. Es poco probable que veas este error si has estado usando devtools::load_all() con regularidad.\n\n\n\nComprobación de dependencias en código R. Los errores aquí a menudo indican que olvidó declarar un paquete necesario en la DESCRIPTION. Recuerde que nunca debe usar require() o library() dentro de un paquete; consulte Sección 9.6, Capítulo 10 y Capítulo 11 para obtener más información. más detalles sobre las mejores prácticas.\nAlternativamente, es posible que haya utilizado accidentalmente ::: para acceder a una función exportada desde un paquete. Cambie a :: en su lugar.\n\n\n\n\nComprobación de la coherencia genérica/método de S3. Los métodos S3 deben tener una firma de función compatible con su genérico. Esto significa que el método debe tener los mismos argumentos que su genérico, con una excepción: si el genérico incluye ... el método puede tener argumentos adicionales.\nUna causa común de este error es definir métodos de impresión, porque el genérico print() contiene...:\n\n# MAL\nprint.my_class &lt;- function(x) cat(\"Hi\")\n\n# BIEN\nprint.my_class &lt;- function(x, ...) cat(\"Hi\")\n\n# también ok\nprint.my_class &lt;- function(x, ..., my_arg = TRUE) cat(\"Hi\")\n\n\n\n\n\nComprobación de funciones de sustitución. Las funciones de reemplazo (por ejemplo, funciones que se llaman como foo(x) &lt;- y) deben tener valor como último argumento.\n\n\n\nComprobando el código R para detectar posibles problemas. Esta es una verificación compuesta para una amplia gama de problemas:\n\nLas llamadas a library.dynam() (y library.dynam.unload()) deberían verse como library.dynam(\"name\"), no como library.dynam(\"name.dll\"). Elimine la extensión para corregir este error.\nColoque library.dynam() en .onLoad(), no en .onAttach(); coloque packageStartupMessage() en .onAttach(), no en .onLoad(). Coloque library.dynam.unload() en .onUnload(). Si utiliza alguna de estas funciones, asegúrese de que esté en el lugar correcto.\nNo utilices unlockBinding() o assignInNamespace() para modificar objetos que no te pertenecen.\nSe llama a codetools::checkUsagePackage() para comprobar que sus funciones no utilizan variables que no existen. Esto a veces genera falsos positivos con funciones que usan evaluación no estándar (NSE), como subset() o with(). Generalmente, creemos que debería evitar NSE en las funciones del paquete y, por lo tanto, evitar esta NOTA, pero si no puede, consulte ?globalVariables para saber cómo suprimir esta NOTA.\nNo está permitido utilizar .Internal() en un paquete. Llame a la función contenedora de R o escriba su propia función de C. (Si copia y pega la función C desde la base R, asegúrese de mantener el aviso de derechos de autor, use una licencia compatible con GPL-2 y incluya R-core en el campo Authors@R).\nDe manera similar, no se le permite usar ::: para acceder a funciones no exportadas de otros paquetes. Pídale al responsable del paquete que exporte la función que necesita o escriba su propia versión utilizando funciones exportadas. Alternativamente, si las licencias son compatibles, puede copiar y pegar la función exportada en su propio paquete. Si hace esto, recuerde actualizar Authors@R.\nNo utilice assign() para modificar objetos en el entorno global. Si necesita mantener el estado en todas las llamadas a funciones, cree su propio entorno, como se describe en Sección 7.4.\nNo utilices attach() en tu código. En su lugar, haga referencia explícita a las variables.\nNo utilice data() sin especificar el argumento envir. De lo contrario, los datos se cargarán en el entorno global.\nNo utilice funciones obsoletas o obsoletas. Actualice su código para usar las últimas versiones.\nDebes usar TRUE y FALSE en tu código (y ejemplos), no T y F.\n\n\n\n\n\nComprobando si el paquete se puede cargar. R carga su paquete con library(). Un error aquí normalmente indica un problema con .onLoad() o .onAttach().\n\n\n\nComprobando si el paquete se puede descargar limpiamente. Se carga con library() y luego detach()es. Si esto falla, verifique .onUnload() y .onDetach().\n\n\n\nComprobando si el espacio de nombres se puede descargar limpiamente. Ejecuta loadNamespace(\"pkg\"); descargarNamespace(\"paquete\"). Verifique .onUnload() para ver si hay problemas.\n\n\n\nComprobando la carga sin estar en la ruta de búsqueda de la biblioteca. Llama a library(x, lib.loc = ...). El error aquí indica que está haciendo una suposición falsa en .onLoad() o .onAttach().",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#datos",
    "href": "R-CMD-check.html#datos",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.6 Datos",
    "text": "A.6 Datos\n\n\n\nComprobando el contenido del directorio ‘data’.\n\nEl directorio de datos solo puede contener los tipos de archivos descritos en Sección 7.1.\nLos archivos de datos pueden contener caracteres que no sean ASCII sólo si la codificación está configurada correctamente. Por lo general, esto no debería ser un problema si está guardando archivos .Rdata. Si ve este error, mire la Codificación() de cada columna en el marco de datos y asegúrese de que ninguna sea “desconocida”. (Por lo general, necesitarás solucionar este problema en algún momento del proceso de importación). Obtenga más información en Sección 7.1.3.\nSi ha comprimido un archivo de datos con bzip2 o xz, debe declarar al menos Depende: R (&gt;= 2.10) en su DESCRIPTION.\nSi ha utilizado un algoritmo de compresión subóptimo para sus datos, vuelva a comprimirlos con el algoritmo sugerido.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#documentación",
    "href": "R-CMD-check.html#documentación",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.7 Documentación",
    "text": "A.7 Documentación\nSi está lidiando específicamente con problemas de documentación, es posible que pueda iterar más rápidamente usando devtools::check_man(), que intenta ejecutar solo el subconjunto relevante de comprobaciones. También llama automáticamente a devtools::document() por usted.\n\n\n\nComprobando archivos Rd. Esto verifica que todos los archivos man/*.Rd utilicen la sintaxis Rd correcta. Si esto falla, indica un error en roxygen2.\n\n\n\nComprobando metadatos Rd. Los nombres y alias deben ser únicos en todos los archivos de documentación de un paquete. Si encuentra este problema, accidentalmente ha utilizado el mismo @nombre o @alias en varios lugares; asegúrate de que sean únicos.\n\n\n\nComprobando anchos de línea Rd. Las líneas de los archivos Rd deben tener menos de 90 caracteres de ancho. Es poco probable que esto ocurra si ajusta su código R, y por lo tanto los comentarios de roxygen, a 80 caracteres. Para URL muy largas, utilice un servicio de acortamiento de enlaces como bit.ly.\n\n\n\nComprobando referencias cruzadas de Rd. Los errores aquí suelen representar errores tipográficos.\n\n\n\nComprobación de entradas de documentación faltantes. Todos los objetos exportados deben estar documentados. Consulte ?tools::undoc para obtener más detalles.\n\n\n\nComprobación de discrepancias en códigos/documentaciones. Esta verificación garantiza que la documentación coincida con el código. Esto nunca debería fallar porque estás usando roxygen2, que automáticamente los mantiene sincronizados y check() normalmente debería volver a document() tu paquete. En cualquier caso, la solución suele ser volver a ejecutar devtools::document().\n\n\n\nComprobando las secciones Rd \\usage. Todos los argumentos deben estar documentados y todos los @params deben documentar un argumento existente. Es posible que haya olvidado documentar un argumento, que haya olvidado eliminar la documentación de un argumento que eliminó o que haya escrito mal el nombre de un argumento.\nLos métodos S3 y S4 necesitan usar marcas especiales \\S3method{} y \\S4method{} en el archivo Rd. Roxygen2 generará esto automáticamente.\n\n\n\n\nComprobando el contenido de Rd. Esto busca contenido generado automáticamente por package.skeleton(). Como no estás usando package.skeleton() nunca deberías tener un problema aquí.\n\n\n\nComprobación de dependencias no declaradas en ejemplos. Si usa un paquete solo como ejemplo, asegúrese de que aparezca en el campo Suggests. Obtenga más información sobre cómo utilizar diferentes tipos de dependencias en sus ejemplos en Capítulo 11.\n\n\n\nComprobando ejemplos. Cada ejemplo de documentación debe ejecutarse sin errores y no debe tardar demasiado. Consulte Sección 16.5 para obtener más detalles.\n\n\n\nConsultando la versión PDF del manual. Ocasionalmente recibirás un error al crear el manual en PDF. Esto suele deberse a que el pdf está creado con látex y te has olvidado de escapar de algo. Depurar esto es doloroso: lo mejor que puede hacer es buscar los registros de látex y el archivo tex combinado y volver desde allí a los archivos .Rd y luego volver a un comentario de roxygen. Cualquier falla de este tipo es potencialmente un error en roxygen2, así que abra un problema.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#demos",
    "href": "R-CMD-check.html#demos",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.8 Demos",
    "text": "A.8 Demos\n\n\n\nComprobando información del índice. Si ha escrito demostraciones, cada demostración debe aparecer en demo/00Index. El archivo debería verse así:\ndemo-name-without-extension  Demo description\nanother-demo-name            Another description",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#código-compilado",
    "href": "R-CMD-check.html#código-compilado",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.9 Código compilado",
    "text": "A.9 Código compilado\n\n\n\nComprobando llamadas a funciones externas. .Call(), .C(), .Fortran(), .External() siempre deben llamarse con un objeto NativeSymbolInfo (como se creó con @useDynLib) o usar el Argumento .paquete. Consulte ?tools::checkFF para obtener más detalles.\n\n\n\nComprobando finales de línea en C/C++/fuentes/encabezados de Fortran. Utilice siempre LF como final de línea.\n\n\n\nComprobando finales de línea en Makefiles. Como anteriormente.\n\n\n\nComprobando el uso portátil de $(BLAS_LIBS) y $(LAPACK_LIBS). Los errores aquí indican un problema con el uso de BLAS y LAPACK.\n\n\n\nComprobando el código compilado. Comprueba que no estás utilizando ninguna función de C que no deberías.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#pruebas",
    "href": "R-CMD-check.html#pruebas",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.10 Pruebas",
    "text": "A.10 Pruebas\n\n\n\nComprobación de dependencias no declaradas en las pruebas. Cada paquete utilizado por las pruebas debe incluirse en las dependencias.\n\n\n\nComprobación de pruebas. Se ejecuta cada archivo en tests/. Si ha seguido las instrucciones en Capítulo 13, tendrá al menos un archivo: testthat.R. El resultado de R CMD check no suele ser tan útil, por lo que es posible que deba consultar el archivo de registro package.Rcheck/tests/testthat.Rout. Corrija cualquier prueba fallida iterando con devtools::test().\nOcasionalmente, puede tener un problema donde las pruebas pasan cuando se ejecutan interactivamente con devtools::test(), pero fallan cuando se ejecutan en R CMD check. Esto generalmente indica que ha hecho una suposición errónea sobre el entorno de prueba y, a menudo, es difícil descifrarla.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#viñetas",
    "href": "R-CMD-check.html#viñetas",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.11 Viñetas",
    "text": "A.11 Viñetas\nEste es un tema bastante complicado que también recibe una cobertura sustancial en la parte principal del libro; consulte Sección 17.5.\n\n\n\nComprobando el directorio ‘build’. build/ se utiliza para realizar un seguimiento de las compilaciones de viñetas. Es difícil imaginar cómo esta verificación podría fallar a menos que accidentalmente hayas ignorado .Rbuild el directorio build/.\n\n\n\nComprobando archivos instalados desde ‘inst/doc’. No coloque archivos en inst/doc; mantenga sus viñetas y los archivos que necesitan en vignettes/.\n\n\n\nComprobación de archivos en ‘viñetas’. Los problemas aquí suelen ser sencillos: ha incluido archivos que ya están incluidos en R (como jss.cls, jss.bst o Sweave.sty), o le sobran archivos de compilación de látex. Elimina estos archivos.\n\n\n\nComprobación del tamaño de los archivos PDF en ‘inst/doc’. Si está creando viñetas en PDF, puede hacerlas lo más pequeñas posible ejecutando tools::compactPDF().\n\n\n\nComprobación de dependencias no declaradas en viñetas. Al igual que con las pruebas, cada paquete que utilice en una viñeta debe aparecer en la DESCRIPTION. Si un paquete se usa solo para una viñeta y no en ningún otro lugar, asegúrese de que aparezca en Suggests. Si realmente desea utilizar un paquete y no desea incluirlo en DESCRIPTION, escriba un artículo en lugar de una viñeta.\n\n\n\nComprobación de viñetas de paquetes en ‘inst/doc’. Esto verifica que cada viñeta fuente (es decir, .Rmd) tenga un equivalente integrado (es decir, .html) en inst/doc. Esto no debería fallar si ha utilizado el proceso estándar descrito en Capítulo 17. Si hay algún problema, comience revisando su .Rbuildignore.\n\n\n\nComprobación del código R en ejecución a partir de viñetas. Se ejecuta el código R de cada viñeta. Si desea ejecutar errores deliberadamente (para mostrarle al usuario cómo se ve la falla), asegúrese de que el fragmento tenga error = TRUE, purl = FALSE.\n\n\n\nComprobando la reconstrucción de los resultados de las viñetas. Cada viñeta se vuelve a tejer para garantizar que la salida corresponda con la entrada. Nuevamente, esto no debería fallar en circunstancias normales.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  },
  {
    "objectID": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "href": "R-CMD-check.html#sec-r-cmd-check-informational-notes",
    "title": "Apéndice A — R CMD check",
    "section": "\nA.12 NOTAS que son informativas",
    "text": "A.12 NOTAS que son informativas\nNuestro consejo general es eliminar todos los ERRORES, ADVERTENCIAS e incluso NOTAS que vea en “R CMD check”. Pero hay algunas excepciones, es decir, hay un par de NOTAS que no necesita corregir (y, de hecho, probablemente no pueda corregir).\n\nA.12.1 Envío inicial de CRAN\nCuando un paquete llega por primera vez a CRAN, siempre habrá una NOTA que alerta a los mantenedores de CRAN que se trata de un nuevo envío y que necesitarán realizar algunas comprobaciones adicionales. No puedes eliminar esta NOTA.\n* checking CRAN incoming feasibility ... NOTE\nMaintainer: 'Jane Doe &lt;jane@example.com&gt;'\n\nNew submission\n\nA.12.2 Caracteres no ASCII en datos\nSi los datos de su paquete contienen caracteres que no son ASCII, recibirá una NOTA como esta, pero eso no significa necesariamente que deba hacer algo al respecto.\nCheck: data for non-ASCII characters\nResult: NOTE\n     Note: found 25 marked UTF-8 strings\nSiempre que conozca los caracteres que no son ASCII y la NOTA mencione su codificación prevista y declarada (preferiblemente UTF-8), todo estará bien.\n\nA.12.3 Rd referencias cruzadas\nSi sus comentarios de roxygen contienen una referencia cruzada a un paquete que no es una dependencia directa y formal, es posible que vea una NOTA como esta:\nCheck: Rd cross-references\nResult: NOTE\n    Undeclared package ‘jsonlite’ in Rd xrefs\nEsto podría suceder si desea documentar algo relacionado con una dependencia indirecta estricta: hay una razón legítima para vincular un tema en el otro paquete y básicamente se garantiza su instalación. Por lo tanto, en la práctica, a menudo se obtienen más beneficios que daños de la referencia cruzada.\nSegún nuestra experiencia, esta NOTA solo se ve en ciertos sabores de cheques CRAN y no en otros. Hasta ahora, los mantenedores de CRAN nunca nos han indicado que abordemos esta NOTA.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R CMD check`</span>"
    ]
  }
]